
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Baby
 * 
 */
export type Baby = $Result.DefaultSelection<Prisma.$BabyPayload>
/**
 * Model BabyCaregiver
 * 
 */
export type BabyCaregiver = $Result.DefaultSelection<Prisma.$BabyCaregiverPayload>
/**
 * Model Elimination
 * 
 */
export type Elimination = $Result.DefaultSelection<Prisma.$EliminationPayload>
/**
 * Model Feeding
 * 
 */
export type Feeding = $Result.DefaultSelection<Prisma.$FeedingPayload>
/**
 * Model Sleep
 * 
 */
export type Sleep = $Result.DefaultSelection<Prisma.$SleepPayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model Milestone
 * 
 */
export type Milestone = $Result.DefaultSelection<Prisma.$MilestonePayload>
/**
 * Model HealthRecord
 * 
 */
export type HealthRecord = $Result.DefaultSelection<Prisma.$HealthRecordPayload>
/**
 * Model Measurement
 * 
 */
export type Measurement = $Result.DefaultSelection<Prisma.$MeasurementPayload>
/**
 * Model Album
 * 
 */
export type Album = $Result.DefaultSelection<Prisma.$AlbumPayload>
/**
 * Model Photo
 * 
 */
export type Photo = $Result.DefaultSelection<Prisma.$PhotoPayload>
/**
 * Model BabyPhoto
 * 
 */
export type BabyPhoto = $Result.DefaultSelection<Prisma.$BabyPhotoPayload>
/**
 * Model AlbumPhoto
 * 
 */
export type AlbumPhoto = $Result.DefaultSelection<Prisma.$AlbumPhotoPayload>
/**
 * Model ActivityPhoto
 * 
 */
export type ActivityPhoto = $Result.DefaultSelection<Prisma.$ActivityPhotoPayload>
/**
 * Model MilestonePhoto
 * 
 */
export type MilestonePhoto = $Result.DefaultSelection<Prisma.$MilestonePhotoPayload>
/**
 * Model AlbumAccess
 * 
 */
export type AlbumAccess = $Result.DefaultSelection<Prisma.$AlbumAccessPayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model ParentInvite
 * 
 */
export type ParentInvite = $Result.DefaultSelection<Prisma.$ParentInvitePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.baby`: Exposes CRUD operations for the **Baby** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Babies
    * const babies = await prisma.baby.findMany()
    * ```
    */
  get baby(): Prisma.BabyDelegate<ExtArgs>;

  /**
   * `prisma.babyCaregiver`: Exposes CRUD operations for the **BabyCaregiver** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BabyCaregivers
    * const babyCaregivers = await prisma.babyCaregiver.findMany()
    * ```
    */
  get babyCaregiver(): Prisma.BabyCaregiverDelegate<ExtArgs>;

  /**
   * `prisma.elimination`: Exposes CRUD operations for the **Elimination** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Eliminations
    * const eliminations = await prisma.elimination.findMany()
    * ```
    */
  get elimination(): Prisma.EliminationDelegate<ExtArgs>;

  /**
   * `prisma.feeding`: Exposes CRUD operations for the **Feeding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedings
    * const feedings = await prisma.feeding.findMany()
    * ```
    */
  get feeding(): Prisma.FeedingDelegate<ExtArgs>;

  /**
   * `prisma.sleep`: Exposes CRUD operations for the **Sleep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sleeps
    * const sleeps = await prisma.sleep.findMany()
    * ```
    */
  get sleep(): Prisma.SleepDelegate<ExtArgs>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs>;

  /**
   * `prisma.milestone`: Exposes CRUD operations for the **Milestone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Milestones
    * const milestones = await prisma.milestone.findMany()
    * ```
    */
  get milestone(): Prisma.MilestoneDelegate<ExtArgs>;

  /**
   * `prisma.healthRecord`: Exposes CRUD operations for the **HealthRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HealthRecords
    * const healthRecords = await prisma.healthRecord.findMany()
    * ```
    */
  get healthRecord(): Prisma.HealthRecordDelegate<ExtArgs>;

  /**
   * `prisma.measurement`: Exposes CRUD operations for the **Measurement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Measurements
    * const measurements = await prisma.measurement.findMany()
    * ```
    */
  get measurement(): Prisma.MeasurementDelegate<ExtArgs>;

  /**
   * `prisma.album`: Exposes CRUD operations for the **Album** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Albums
    * const albums = await prisma.album.findMany()
    * ```
    */
  get album(): Prisma.AlbumDelegate<ExtArgs>;

  /**
   * `prisma.photo`: Exposes CRUD operations for the **Photo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photos
    * const photos = await prisma.photo.findMany()
    * ```
    */
  get photo(): Prisma.PhotoDelegate<ExtArgs>;

  /**
   * `prisma.babyPhoto`: Exposes CRUD operations for the **BabyPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BabyPhotos
    * const babyPhotos = await prisma.babyPhoto.findMany()
    * ```
    */
  get babyPhoto(): Prisma.BabyPhotoDelegate<ExtArgs>;

  /**
   * `prisma.albumPhoto`: Exposes CRUD operations for the **AlbumPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlbumPhotos
    * const albumPhotos = await prisma.albumPhoto.findMany()
    * ```
    */
  get albumPhoto(): Prisma.AlbumPhotoDelegate<ExtArgs>;

  /**
   * `prisma.activityPhoto`: Exposes CRUD operations for the **ActivityPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityPhotos
    * const activityPhotos = await prisma.activityPhoto.findMany()
    * ```
    */
  get activityPhoto(): Prisma.ActivityPhotoDelegate<ExtArgs>;

  /**
   * `prisma.milestonePhoto`: Exposes CRUD operations for the **MilestonePhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MilestonePhotos
    * const milestonePhotos = await prisma.milestonePhoto.findMany()
    * ```
    */
  get milestonePhoto(): Prisma.MilestonePhotoDelegate<ExtArgs>;

  /**
   * `prisma.albumAccess`: Exposes CRUD operations for the **AlbumAccess** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlbumAccesses
    * const albumAccesses = await prisma.albumAccess.findMany()
    * ```
    */
  get albumAccess(): Prisma.AlbumAccessDelegate<ExtArgs>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.parentInvite`: Exposes CRUD operations for the **ParentInvite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParentInvites
    * const parentInvites = await prisma.parentInvite.findMany()
    * ```
    */
  get parentInvite(): Prisma.ParentInviteDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.11.0
   * Query Engine version: efd2449663b3d73d637ea1fd226bafbcf45b3102
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Baby: 'Baby',
    BabyCaregiver: 'BabyCaregiver',
    Elimination: 'Elimination',
    Feeding: 'Feeding',
    Sleep: 'Sleep',
    Activity: 'Activity',
    Milestone: 'Milestone',
    HealthRecord: 'HealthRecord',
    Measurement: 'Measurement',
    Album: 'Album',
    Photo: 'Photo',
    BabyPhoto: 'BabyPhoto',
    AlbumPhoto: 'AlbumPhoto',
    ActivityPhoto: 'ActivityPhoto',
    MilestonePhoto: 'MilestonePhoto',
    AlbumAccess: 'AlbumAccess',
    Post: 'Post',
    Comment: 'Comment',
    ParentInvite: 'ParentInvite'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'baby' | 'babyCaregiver' | 'elimination' | 'feeding' | 'sleep' | 'activity' | 'milestone' | 'healthRecord' | 'measurement' | 'album' | 'photo' | 'babyPhoto' | 'albumPhoto' | 'activityPhoto' | 'milestonePhoto' | 'albumAccess' | 'post' | 'comment' | 'parentInvite'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Baby: {
        payload: Prisma.$BabyPayload<ExtArgs>
        fields: Prisma.BabyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BabyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BabyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyPayload>
          }
          findFirst: {
            args: Prisma.BabyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BabyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyPayload>
          }
          findMany: {
            args: Prisma.BabyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyPayload>[]
          }
          create: {
            args: Prisma.BabyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyPayload>
          }
          createMany: {
            args: Prisma.BabyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BabyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyPayload>
          }
          update: {
            args: Prisma.BabyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyPayload>
          }
          deleteMany: {
            args: Prisma.BabyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BabyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BabyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyPayload>
          }
          aggregate: {
            args: Prisma.BabyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBaby>
          }
          groupBy: {
            args: Prisma.BabyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BabyGroupByOutputType>[]
          }
          count: {
            args: Prisma.BabyCountArgs<ExtArgs>,
            result: $Utils.Optional<BabyCountAggregateOutputType> | number
          }
        }
      }
      BabyCaregiver: {
        payload: Prisma.$BabyCaregiverPayload<ExtArgs>
        fields: Prisma.BabyCaregiverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BabyCaregiverFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyCaregiverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BabyCaregiverFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyCaregiverPayload>
          }
          findFirst: {
            args: Prisma.BabyCaregiverFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyCaregiverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BabyCaregiverFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyCaregiverPayload>
          }
          findMany: {
            args: Prisma.BabyCaregiverFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyCaregiverPayload>[]
          }
          create: {
            args: Prisma.BabyCaregiverCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyCaregiverPayload>
          }
          createMany: {
            args: Prisma.BabyCaregiverCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BabyCaregiverDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyCaregiverPayload>
          }
          update: {
            args: Prisma.BabyCaregiverUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyCaregiverPayload>
          }
          deleteMany: {
            args: Prisma.BabyCaregiverDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BabyCaregiverUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BabyCaregiverUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyCaregiverPayload>
          }
          aggregate: {
            args: Prisma.BabyCaregiverAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBabyCaregiver>
          }
          groupBy: {
            args: Prisma.BabyCaregiverGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BabyCaregiverGroupByOutputType>[]
          }
          count: {
            args: Prisma.BabyCaregiverCountArgs<ExtArgs>,
            result: $Utils.Optional<BabyCaregiverCountAggregateOutputType> | number
          }
        }
      }
      Elimination: {
        payload: Prisma.$EliminationPayload<ExtArgs>
        fields: Prisma.EliminationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EliminationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EliminationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EliminationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EliminationPayload>
          }
          findFirst: {
            args: Prisma.EliminationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EliminationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EliminationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EliminationPayload>
          }
          findMany: {
            args: Prisma.EliminationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EliminationPayload>[]
          }
          create: {
            args: Prisma.EliminationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EliminationPayload>
          }
          createMany: {
            args: Prisma.EliminationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EliminationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EliminationPayload>
          }
          update: {
            args: Prisma.EliminationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EliminationPayload>
          }
          deleteMany: {
            args: Prisma.EliminationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EliminationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EliminationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EliminationPayload>
          }
          aggregate: {
            args: Prisma.EliminationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateElimination>
          }
          groupBy: {
            args: Prisma.EliminationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EliminationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EliminationCountArgs<ExtArgs>,
            result: $Utils.Optional<EliminationCountAggregateOutputType> | number
          }
        }
      }
      Feeding: {
        payload: Prisma.$FeedingPayload<ExtArgs>
        fields: Prisma.FeedingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedingPayload>
          }
          findFirst: {
            args: Prisma.FeedingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedingPayload>
          }
          findMany: {
            args: Prisma.FeedingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedingPayload>[]
          }
          create: {
            args: Prisma.FeedingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedingPayload>
          }
          createMany: {
            args: Prisma.FeedingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FeedingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedingPayload>
          }
          update: {
            args: Prisma.FeedingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedingPayload>
          }
          deleteMany: {
            args: Prisma.FeedingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FeedingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FeedingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedingPayload>
          }
          aggregate: {
            args: Prisma.FeedingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFeeding>
          }
          groupBy: {
            args: Prisma.FeedingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FeedingGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedingCountArgs<ExtArgs>,
            result: $Utils.Optional<FeedingCountAggregateOutputType> | number
          }
        }
      }
      Sleep: {
        payload: Prisma.$SleepPayload<ExtArgs>
        fields: Prisma.SleepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SleepFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SleepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SleepFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SleepPayload>
          }
          findFirst: {
            args: Prisma.SleepFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SleepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SleepFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SleepPayload>
          }
          findMany: {
            args: Prisma.SleepFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SleepPayload>[]
          }
          create: {
            args: Prisma.SleepCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SleepPayload>
          }
          createMany: {
            args: Prisma.SleepCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SleepDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SleepPayload>
          }
          update: {
            args: Prisma.SleepUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SleepPayload>
          }
          deleteMany: {
            args: Prisma.SleepDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SleepUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SleepUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SleepPayload>
          }
          aggregate: {
            args: Prisma.SleepAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSleep>
          }
          groupBy: {
            args: Prisma.SleepGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SleepGroupByOutputType>[]
          }
          count: {
            args: Prisma.SleepCountArgs<ExtArgs>,
            result: $Utils.Optional<SleepCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>,
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      Milestone: {
        payload: Prisma.$MilestonePayload<ExtArgs>
        fields: Prisma.MilestoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MilestoneFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MilestoneFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findFirst: {
            args: Prisma.MilestoneFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MilestoneFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findMany: {
            args: Prisma.MilestoneFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          create: {
            args: Prisma.MilestoneCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          createMany: {
            args: Prisma.MilestoneCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MilestoneDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          update: {
            args: Prisma.MilestoneUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          deleteMany: {
            args: Prisma.MilestoneDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MilestoneUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MilestoneUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          aggregate: {
            args: Prisma.MilestoneAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMilestone>
          }
          groupBy: {
            args: Prisma.MilestoneGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MilestoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.MilestoneCountArgs<ExtArgs>,
            result: $Utils.Optional<MilestoneCountAggregateOutputType> | number
          }
        }
      }
      HealthRecord: {
        payload: Prisma.$HealthRecordPayload<ExtArgs>
        fields: Prisma.HealthRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HealthRecordFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HealthRecordFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>
          }
          findFirst: {
            args: Prisma.HealthRecordFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HealthRecordFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>
          }
          findMany: {
            args: Prisma.HealthRecordFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>[]
          }
          create: {
            args: Prisma.HealthRecordCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>
          }
          createMany: {
            args: Prisma.HealthRecordCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.HealthRecordDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>
          }
          update: {
            args: Prisma.HealthRecordUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>
          }
          deleteMany: {
            args: Prisma.HealthRecordDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.HealthRecordUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.HealthRecordUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>
          }
          aggregate: {
            args: Prisma.HealthRecordAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHealthRecord>
          }
          groupBy: {
            args: Prisma.HealthRecordGroupByArgs<ExtArgs>,
            result: $Utils.Optional<HealthRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.HealthRecordCountArgs<ExtArgs>,
            result: $Utils.Optional<HealthRecordCountAggregateOutputType> | number
          }
        }
      }
      Measurement: {
        payload: Prisma.$MeasurementPayload<ExtArgs>
        fields: Prisma.MeasurementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeasurementFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeasurementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeasurementFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeasurementPayload>
          }
          findFirst: {
            args: Prisma.MeasurementFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeasurementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeasurementFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeasurementPayload>
          }
          findMany: {
            args: Prisma.MeasurementFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeasurementPayload>[]
          }
          create: {
            args: Prisma.MeasurementCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeasurementPayload>
          }
          createMany: {
            args: Prisma.MeasurementCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MeasurementDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeasurementPayload>
          }
          update: {
            args: Prisma.MeasurementUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeasurementPayload>
          }
          deleteMany: {
            args: Prisma.MeasurementDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MeasurementUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MeasurementUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeasurementPayload>
          }
          aggregate: {
            args: Prisma.MeasurementAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMeasurement>
          }
          groupBy: {
            args: Prisma.MeasurementGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MeasurementGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeasurementCountArgs<ExtArgs>,
            result: $Utils.Optional<MeasurementCountAggregateOutputType> | number
          }
        }
      }
      Album: {
        payload: Prisma.$AlbumPayload<ExtArgs>
        fields: Prisma.AlbumFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlbumFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlbumFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>
          }
          findFirst: {
            args: Prisma.AlbumFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlbumFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>
          }
          findMany: {
            args: Prisma.AlbumFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>[]
          }
          create: {
            args: Prisma.AlbumCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>
          }
          createMany: {
            args: Prisma.AlbumCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AlbumDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>
          }
          update: {
            args: Prisma.AlbumUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>
          }
          deleteMany: {
            args: Prisma.AlbumDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AlbumUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AlbumUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumPayload>
          }
          aggregate: {
            args: Prisma.AlbumAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAlbum>
          }
          groupBy: {
            args: Prisma.AlbumGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AlbumGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlbumCountArgs<ExtArgs>,
            result: $Utils.Optional<AlbumCountAggregateOutputType> | number
          }
        }
      }
      Photo: {
        payload: Prisma.$PhotoPayload<ExtArgs>
        fields: Prisma.PhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhotoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhotoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          findFirst: {
            args: Prisma.PhotoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhotoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          findMany: {
            args: Prisma.PhotoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>[]
          }
          create: {
            args: Prisma.PhotoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          createMany: {
            args: Prisma.PhotoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PhotoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          update: {
            args: Prisma.PhotoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          deleteMany: {
            args: Prisma.PhotoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PhotoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PhotoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          aggregate: {
            args: Prisma.PhotoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePhoto>
          }
          groupBy: {
            args: Prisma.PhotoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhotoCountArgs<ExtArgs>,
            result: $Utils.Optional<PhotoCountAggregateOutputType> | number
          }
        }
      }
      BabyPhoto: {
        payload: Prisma.$BabyPhotoPayload<ExtArgs>
        fields: Prisma.BabyPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BabyPhotoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BabyPhotoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyPhotoPayload>
          }
          findFirst: {
            args: Prisma.BabyPhotoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BabyPhotoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyPhotoPayload>
          }
          findMany: {
            args: Prisma.BabyPhotoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyPhotoPayload>[]
          }
          create: {
            args: Prisma.BabyPhotoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyPhotoPayload>
          }
          createMany: {
            args: Prisma.BabyPhotoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BabyPhotoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyPhotoPayload>
          }
          update: {
            args: Prisma.BabyPhotoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyPhotoPayload>
          }
          deleteMany: {
            args: Prisma.BabyPhotoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BabyPhotoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BabyPhotoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BabyPhotoPayload>
          }
          aggregate: {
            args: Prisma.BabyPhotoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBabyPhoto>
          }
          groupBy: {
            args: Prisma.BabyPhotoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BabyPhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.BabyPhotoCountArgs<ExtArgs>,
            result: $Utils.Optional<BabyPhotoCountAggregateOutputType> | number
          }
        }
      }
      AlbumPhoto: {
        payload: Prisma.$AlbumPhotoPayload<ExtArgs>
        fields: Prisma.AlbumPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlbumPhotoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlbumPhotoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumPhotoPayload>
          }
          findFirst: {
            args: Prisma.AlbumPhotoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlbumPhotoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumPhotoPayload>
          }
          findMany: {
            args: Prisma.AlbumPhotoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumPhotoPayload>[]
          }
          create: {
            args: Prisma.AlbumPhotoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumPhotoPayload>
          }
          createMany: {
            args: Prisma.AlbumPhotoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AlbumPhotoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumPhotoPayload>
          }
          update: {
            args: Prisma.AlbumPhotoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumPhotoPayload>
          }
          deleteMany: {
            args: Prisma.AlbumPhotoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AlbumPhotoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AlbumPhotoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumPhotoPayload>
          }
          aggregate: {
            args: Prisma.AlbumPhotoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAlbumPhoto>
          }
          groupBy: {
            args: Prisma.AlbumPhotoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AlbumPhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlbumPhotoCountArgs<ExtArgs>,
            result: $Utils.Optional<AlbumPhotoCountAggregateOutputType> | number
          }
        }
      }
      ActivityPhoto: {
        payload: Prisma.$ActivityPhotoPayload<ExtArgs>
        fields: Prisma.ActivityPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityPhotoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActivityPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityPhotoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActivityPhotoPayload>
          }
          findFirst: {
            args: Prisma.ActivityPhotoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActivityPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityPhotoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActivityPhotoPayload>
          }
          findMany: {
            args: Prisma.ActivityPhotoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActivityPhotoPayload>[]
          }
          create: {
            args: Prisma.ActivityPhotoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActivityPhotoPayload>
          }
          createMany: {
            args: Prisma.ActivityPhotoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ActivityPhotoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActivityPhotoPayload>
          }
          update: {
            args: Prisma.ActivityPhotoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActivityPhotoPayload>
          }
          deleteMany: {
            args: Prisma.ActivityPhotoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityPhotoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ActivityPhotoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ActivityPhotoPayload>
          }
          aggregate: {
            args: Prisma.ActivityPhotoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateActivityPhoto>
          }
          groupBy: {
            args: Prisma.ActivityPhotoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ActivityPhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityPhotoCountArgs<ExtArgs>,
            result: $Utils.Optional<ActivityPhotoCountAggregateOutputType> | number
          }
        }
      }
      MilestonePhoto: {
        payload: Prisma.$MilestonePhotoPayload<ExtArgs>
        fields: Prisma.MilestonePhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MilestonePhotoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MilestonePhotoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePhotoPayload>
          }
          findFirst: {
            args: Prisma.MilestonePhotoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MilestonePhotoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePhotoPayload>
          }
          findMany: {
            args: Prisma.MilestonePhotoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePhotoPayload>[]
          }
          create: {
            args: Prisma.MilestonePhotoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePhotoPayload>
          }
          createMany: {
            args: Prisma.MilestonePhotoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MilestonePhotoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePhotoPayload>
          }
          update: {
            args: Prisma.MilestonePhotoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePhotoPayload>
          }
          deleteMany: {
            args: Prisma.MilestonePhotoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MilestonePhotoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MilestonePhotoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MilestonePhotoPayload>
          }
          aggregate: {
            args: Prisma.MilestonePhotoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMilestonePhoto>
          }
          groupBy: {
            args: Prisma.MilestonePhotoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MilestonePhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.MilestonePhotoCountArgs<ExtArgs>,
            result: $Utils.Optional<MilestonePhotoCountAggregateOutputType> | number
          }
        }
      }
      AlbumAccess: {
        payload: Prisma.$AlbumAccessPayload<ExtArgs>
        fields: Prisma.AlbumAccessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlbumAccessFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumAccessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlbumAccessFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumAccessPayload>
          }
          findFirst: {
            args: Prisma.AlbumAccessFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumAccessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlbumAccessFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumAccessPayload>
          }
          findMany: {
            args: Prisma.AlbumAccessFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumAccessPayload>[]
          }
          create: {
            args: Prisma.AlbumAccessCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumAccessPayload>
          }
          createMany: {
            args: Prisma.AlbumAccessCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AlbumAccessDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumAccessPayload>
          }
          update: {
            args: Prisma.AlbumAccessUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumAccessPayload>
          }
          deleteMany: {
            args: Prisma.AlbumAccessDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AlbumAccessUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AlbumAccessUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlbumAccessPayload>
          }
          aggregate: {
            args: Prisma.AlbumAccessAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAlbumAccess>
          }
          groupBy: {
            args: Prisma.AlbumAccessGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AlbumAccessGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlbumAccessCountArgs<ExtArgs>,
            result: $Utils.Optional<AlbumAccessCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>,
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>,
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      ParentInvite: {
        payload: Prisma.$ParentInvitePayload<ExtArgs>
        fields: Prisma.ParentInviteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParentInviteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParentInvitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParentInviteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParentInvitePayload>
          }
          findFirst: {
            args: Prisma.ParentInviteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParentInvitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParentInviteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParentInvitePayload>
          }
          findMany: {
            args: Prisma.ParentInviteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParentInvitePayload>[]
          }
          create: {
            args: Prisma.ParentInviteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParentInvitePayload>
          }
          createMany: {
            args: Prisma.ParentInviteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ParentInviteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParentInvitePayload>
          }
          update: {
            args: Prisma.ParentInviteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParentInvitePayload>
          }
          deleteMany: {
            args: Prisma.ParentInviteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ParentInviteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ParentInviteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParentInvitePayload>
          }
          aggregate: {
            args: Prisma.ParentInviteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateParentInvite>
          }
          groupBy: {
            args: Prisma.ParentInviteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ParentInviteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParentInviteCountArgs<ExtArgs>,
            result: $Utils.Optional<ParentInviteCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.DriverAdapter | null
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    babies: number
    ownedBabies: number
    posts: number
    comments: number
    ParentInvite: number
    AlbumAccess: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    babies?: boolean | UserCountOutputTypeCountBabiesArgs
    ownedBabies?: boolean | UserCountOutputTypeCountOwnedBabiesArgs
    posts?: boolean | UserCountOutputTypeCountPostsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    ParentInvite?: boolean | UserCountOutputTypeCountParentInviteArgs
    AlbumAccess?: boolean | UserCountOutputTypeCountAlbumAccessArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBabiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BabyCaregiverWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedBabiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BabyWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountParentInviteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentInviteWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAlbumAccessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlbumAccessWhereInput
  }



  /**
   * Count Type BabyCountOutputType
   */

  export type BabyCountOutputType = {
    caregivers: number
    eliminations: number
    feedings: number
    sleepsleepSessions: number
    activities: number
    photos: number
    milestones: number
    healthRecords: number
    measurements: number
    albums: number
    parentInvites: number
  }

  export type BabyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caregivers?: boolean | BabyCountOutputTypeCountCaregiversArgs
    eliminations?: boolean | BabyCountOutputTypeCountEliminationsArgs
    feedings?: boolean | BabyCountOutputTypeCountFeedingsArgs
    sleepsleepSessions?: boolean | BabyCountOutputTypeCountSleepsleepSessionsArgs
    activities?: boolean | BabyCountOutputTypeCountActivitiesArgs
    photos?: boolean | BabyCountOutputTypeCountPhotosArgs
    milestones?: boolean | BabyCountOutputTypeCountMilestonesArgs
    healthRecords?: boolean | BabyCountOutputTypeCountHealthRecordsArgs
    measurements?: boolean | BabyCountOutputTypeCountMeasurementsArgs
    albums?: boolean | BabyCountOutputTypeCountAlbumsArgs
    parentInvites?: boolean | BabyCountOutputTypeCountParentInvitesArgs
  }

  // Custom InputTypes

  /**
   * BabyCountOutputType without action
   */
  export type BabyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BabyCountOutputType
     */
    select?: BabyCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BabyCountOutputType without action
   */
  export type BabyCountOutputTypeCountCaregiversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BabyCaregiverWhereInput
  }


  /**
   * BabyCountOutputType without action
   */
  export type BabyCountOutputTypeCountEliminationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EliminationWhereInput
  }


  /**
   * BabyCountOutputType without action
   */
  export type BabyCountOutputTypeCountFeedingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedingWhereInput
  }


  /**
   * BabyCountOutputType without action
   */
  export type BabyCountOutputTypeCountSleepsleepSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SleepWhereInput
  }


  /**
   * BabyCountOutputType without action
   */
  export type BabyCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }


  /**
   * BabyCountOutputType without action
   */
  export type BabyCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BabyPhotoWhereInput
  }


  /**
   * BabyCountOutputType without action
   */
  export type BabyCountOutputTypeCountMilestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
  }


  /**
   * BabyCountOutputType without action
   */
  export type BabyCountOutputTypeCountHealthRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthRecordWhereInput
  }


  /**
   * BabyCountOutputType without action
   */
  export type BabyCountOutputTypeCountMeasurementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeasurementWhereInput
  }


  /**
   * BabyCountOutputType without action
   */
  export type BabyCountOutputTypeCountAlbumsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlbumWhereInput
  }


  /**
   * BabyCountOutputType without action
   */
  export type BabyCountOutputTypeCountParentInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentInviteWhereInput
  }



  /**
   * Count Type ActivityCountOutputType
   */

  export type ActivityCountOutputType = {
    photos: number
  }

  export type ActivityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | ActivityCountOutputTypeCountPhotosArgs
  }

  // Custom InputTypes

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCountOutputType
     */
    select?: ActivityCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityPhotoWhereInput
  }



  /**
   * Count Type MilestoneCountOutputType
   */

  export type MilestoneCountOutputType = {
    photos: number
  }

  export type MilestoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | MilestoneCountOutputTypeCountPhotosArgs
  }

  // Custom InputTypes

  /**
   * MilestoneCountOutputType without action
   */
  export type MilestoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilestoneCountOutputType
     */
    select?: MilestoneCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MilestoneCountOutputType without action
   */
  export type MilestoneCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestonePhotoWhereInput
  }



  /**
   * Count Type AlbumCountOutputType
   */

  export type AlbumCountOutputType = {
    photos: number
    access: number
  }

  export type AlbumCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | AlbumCountOutputTypeCountPhotosArgs
    access?: boolean | AlbumCountOutputTypeCountAccessArgs
  }

  // Custom InputTypes

  /**
   * AlbumCountOutputType without action
   */
  export type AlbumCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumCountOutputType
     */
    select?: AlbumCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AlbumCountOutputType without action
   */
  export type AlbumCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlbumPhotoWhereInput
  }


  /**
   * AlbumCountOutputType without action
   */
  export type AlbumCountOutputTypeCountAccessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlbumAccessWhereInput
  }



  /**
   * Count Type PhotoCountOutputType
   */

  export type PhotoCountOutputType = {
    babyPhotos: number
    albumPhotos: number
    activityPhotos: number
    milestonePhotos: number
  }

  export type PhotoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    babyPhotos?: boolean | PhotoCountOutputTypeCountBabyPhotosArgs
    albumPhotos?: boolean | PhotoCountOutputTypeCountAlbumPhotosArgs
    activityPhotos?: boolean | PhotoCountOutputTypeCountActivityPhotosArgs
    milestonePhotos?: boolean | PhotoCountOutputTypeCountMilestonePhotosArgs
  }

  // Custom InputTypes

  /**
   * PhotoCountOutputType without action
   */
  export type PhotoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoCountOutputType
     */
    select?: PhotoCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PhotoCountOutputType without action
   */
  export type PhotoCountOutputTypeCountBabyPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BabyPhotoWhereInput
  }


  /**
   * PhotoCountOutputType without action
   */
  export type PhotoCountOutputTypeCountAlbumPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlbumPhotoWhereInput
  }


  /**
   * PhotoCountOutputType without action
   */
  export type PhotoCountOutputTypeCountActivityPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityPhotoWhereInput
  }


  /**
   * PhotoCountOutputType without action
   */
  export type PhotoCountOutputTypeCountMilestonePhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestonePhotoWhereInput
  }



  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    comments: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | PostCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    firstName: number
    lastName: number
    phone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    phone: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    babies?: boolean | User$babiesArgs<ExtArgs>
    ownedBabies?: boolean | User$ownedBabiesArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    ParentInvite?: boolean | User$ParentInviteArgs<ExtArgs>
    AlbumAccess?: boolean | User$AlbumAccessArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    babies?: boolean | User$babiesArgs<ExtArgs>
    ownedBabies?: boolean | User$ownedBabiesArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    ParentInvite?: boolean | User$ParentInviteArgs<ExtArgs>
    AlbumAccess?: boolean | User$AlbumAccessArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      babies: Prisma.$BabyCaregiverPayload<ExtArgs>[]
      ownedBabies: Prisma.$BabyPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      ParentInvite: Prisma.$ParentInvitePayload<ExtArgs>[]
      AlbumAccess: Prisma.$AlbumAccessPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      passwordHash: string
      firstName: string
      lastName: string
      phone: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    babies<T extends User$babiesArgs<ExtArgs> = {}>(args?: Subset<T, User$babiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BabyCaregiverPayload<ExtArgs>, T, 'findMany'> | Null>;

    ownedBabies<T extends User$ownedBabiesArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedBabiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BabyPayload<ExtArgs>, T, 'findMany'> | Null>;

    posts<T extends User$postsArgs<ExtArgs> = {}>(args?: Subset<T, User$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findMany'> | Null>;

    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'> | Null>;

    ParentInvite<T extends User$ParentInviteArgs<ExtArgs> = {}>(args?: Subset<T, User$ParentInviteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentInvitePayload<ExtArgs>, T, 'findMany'> | Null>;

    AlbumAccess<T extends User$AlbumAccessArgs<ExtArgs> = {}>(args?: Subset<T, User$AlbumAccessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlbumAccessPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.babies
   */
  export type User$babiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BabyCaregiver
     */
    select?: BabyCaregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyCaregiverInclude<ExtArgs> | null
    where?: BabyCaregiverWhereInput
    orderBy?: BabyCaregiverOrderByWithRelationInput | BabyCaregiverOrderByWithRelationInput[]
    cursor?: BabyCaregiverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BabyCaregiverScalarFieldEnum | BabyCaregiverScalarFieldEnum[]
  }


  /**
   * User.ownedBabies
   */
  export type User$ownedBabiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baby
     */
    select?: BabySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyInclude<ExtArgs> | null
    where?: BabyWhereInput
    orderBy?: BabyOrderByWithRelationInput | BabyOrderByWithRelationInput[]
    cursor?: BabyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BabyScalarFieldEnum | BabyScalarFieldEnum[]
  }


  /**
   * User.posts
   */
  export type User$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }


  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * User.ParentInvite
   */
  export type User$ParentInviteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvite
     */
    select?: ParentInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParentInviteInclude<ExtArgs> | null
    where?: ParentInviteWhereInput
    orderBy?: ParentInviteOrderByWithRelationInput | ParentInviteOrderByWithRelationInput[]
    cursor?: ParentInviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParentInviteScalarFieldEnum | ParentInviteScalarFieldEnum[]
  }


  /**
   * User.AlbumAccess
   */
  export type User$AlbumAccessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumAccess
     */
    select?: AlbumAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumAccessInclude<ExtArgs> | null
    where?: AlbumAccessWhereInput
    orderBy?: AlbumAccessOrderByWithRelationInput | AlbumAccessOrderByWithRelationInput[]
    cursor?: AlbumAccessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlbumAccessScalarFieldEnum | AlbumAccessScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Baby
   */

  export type AggregateBaby = {
    _count: BabyCountAggregateOutputType | null
    _avg: BabyAvgAggregateOutputType | null
    _sum: BabySumAggregateOutputType | null
    _min: BabyMinAggregateOutputType | null
    _max: BabyMaxAggregateOutputType | null
  }

  export type BabyAvgAggregateOutputType = {
    id: number | null
    ownerId: number | null
  }

  export type BabySumAggregateOutputType = {
    id: number | null
    ownerId: number | null
  }

  export type BabyMinAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    dateOfBirth: Date | null
    gender: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ownerId: number | null
  }

  export type BabyMaxAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    dateOfBirth: Date | null
    gender: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ownerId: number | null
  }

  export type BabyCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    dateOfBirth: number
    gender: number
    createdAt: number
    updatedAt: number
    ownerId: number
    _all: number
  }


  export type BabyAvgAggregateInputType = {
    id?: true
    ownerId?: true
  }

  export type BabySumAggregateInputType = {
    id?: true
    ownerId?: true
  }

  export type BabyMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    gender?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
  }

  export type BabyMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    gender?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
  }

  export type BabyCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    gender?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
    _all?: true
  }

  export type BabyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Baby to aggregate.
     */
    where?: BabyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Babies to fetch.
     */
    orderBy?: BabyOrderByWithRelationInput | BabyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BabyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Babies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Babies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Babies
    **/
    _count?: true | BabyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BabyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BabySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BabyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BabyMaxAggregateInputType
  }

  export type GetBabyAggregateType<T extends BabyAggregateArgs> = {
        [P in keyof T & keyof AggregateBaby]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBaby[P]>
      : GetScalarType<T[P], AggregateBaby[P]>
  }




  export type BabyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BabyWhereInput
    orderBy?: BabyOrderByWithAggregationInput | BabyOrderByWithAggregationInput[]
    by: BabyScalarFieldEnum[] | BabyScalarFieldEnum
    having?: BabyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BabyCountAggregateInputType | true
    _avg?: BabyAvgAggregateInputType
    _sum?: BabySumAggregateInputType
    _min?: BabyMinAggregateInputType
    _max?: BabyMaxAggregateInputType
  }

  export type BabyGroupByOutputType = {
    id: number
    firstName: string
    lastName: string
    dateOfBirth: Date
    gender: string | null
    createdAt: Date
    updatedAt: Date
    ownerId: number
    _count: BabyCountAggregateOutputType | null
    _avg: BabyAvgAggregateOutputType | null
    _sum: BabySumAggregateOutputType | null
    _min: BabyMinAggregateOutputType | null
    _max: BabyMaxAggregateOutputType | null
  }

  type GetBabyGroupByPayload<T extends BabyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BabyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BabyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BabyGroupByOutputType[P]>
            : GetScalarType<T[P], BabyGroupByOutputType[P]>
        }
      >
    >


  export type BabySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    caregivers?: boolean | Baby$caregiversArgs<ExtArgs>
    eliminations?: boolean | Baby$eliminationsArgs<ExtArgs>
    feedings?: boolean | Baby$feedingsArgs<ExtArgs>
    sleepsleepSessions?: boolean | Baby$sleepsleepSessionsArgs<ExtArgs>
    activities?: boolean | Baby$activitiesArgs<ExtArgs>
    photos?: boolean | Baby$photosArgs<ExtArgs>
    milestones?: boolean | Baby$milestonesArgs<ExtArgs>
    healthRecords?: boolean | Baby$healthRecordsArgs<ExtArgs>
    measurements?: boolean | Baby$measurementsArgs<ExtArgs>
    albums?: boolean | Baby$albumsArgs<ExtArgs>
    parentInvites?: boolean | Baby$parentInvitesArgs<ExtArgs>
    _count?: boolean | BabyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["baby"]>

  export type BabySelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
  }

  export type BabyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    caregivers?: boolean | Baby$caregiversArgs<ExtArgs>
    eliminations?: boolean | Baby$eliminationsArgs<ExtArgs>
    feedings?: boolean | Baby$feedingsArgs<ExtArgs>
    sleepsleepSessions?: boolean | Baby$sleepsleepSessionsArgs<ExtArgs>
    activities?: boolean | Baby$activitiesArgs<ExtArgs>
    photos?: boolean | Baby$photosArgs<ExtArgs>
    milestones?: boolean | Baby$milestonesArgs<ExtArgs>
    healthRecords?: boolean | Baby$healthRecordsArgs<ExtArgs>
    measurements?: boolean | Baby$measurementsArgs<ExtArgs>
    albums?: boolean | Baby$albumsArgs<ExtArgs>
    parentInvites?: boolean | Baby$parentInvitesArgs<ExtArgs>
    _count?: boolean | BabyCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $BabyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Baby"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      caregivers: Prisma.$BabyCaregiverPayload<ExtArgs>[]
      eliminations: Prisma.$EliminationPayload<ExtArgs>[]
      feedings: Prisma.$FeedingPayload<ExtArgs>[]
      sleepsleepSessions: Prisma.$SleepPayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      photos: Prisma.$BabyPhotoPayload<ExtArgs>[]
      milestones: Prisma.$MilestonePayload<ExtArgs>[]
      healthRecords: Prisma.$HealthRecordPayload<ExtArgs>[]
      measurements: Prisma.$MeasurementPayload<ExtArgs>[]
      albums: Prisma.$AlbumPayload<ExtArgs>[]
      parentInvites: Prisma.$ParentInvitePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      firstName: string
      lastName: string
      dateOfBirth: Date
      gender: string | null
      createdAt: Date
      updatedAt: Date
      ownerId: number
    }, ExtArgs["result"]["baby"]>
    composites: {}
  }


  type BabyGetPayload<S extends boolean | null | undefined | BabyDefaultArgs> = $Result.GetResult<Prisma.$BabyPayload, S>

  type BabyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BabyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BabyCountAggregateInputType | true
    }

  export interface BabyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Baby'], meta: { name: 'Baby' } }
    /**
     * Find zero or one Baby that matches the filter.
     * @param {BabyFindUniqueArgs} args - Arguments to find a Baby
     * @example
     * // Get one Baby
     * const baby = await prisma.baby.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BabyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BabyFindUniqueArgs<ExtArgs>>
    ): Prisma__BabyClient<$Result.GetResult<Prisma.$BabyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Baby that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BabyFindUniqueOrThrowArgs} args - Arguments to find a Baby
     * @example
     * // Get one Baby
     * const baby = await prisma.baby.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BabyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BabyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BabyClient<$Result.GetResult<Prisma.$BabyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Baby that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BabyFindFirstArgs} args - Arguments to find a Baby
     * @example
     * // Get one Baby
     * const baby = await prisma.baby.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BabyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BabyFindFirstArgs<ExtArgs>>
    ): Prisma__BabyClient<$Result.GetResult<Prisma.$BabyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Baby that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BabyFindFirstOrThrowArgs} args - Arguments to find a Baby
     * @example
     * // Get one Baby
     * const baby = await prisma.baby.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BabyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BabyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BabyClient<$Result.GetResult<Prisma.$BabyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Babies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BabyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Babies
     * const babies = await prisma.baby.findMany()
     * 
     * // Get first 10 Babies
     * const babies = await prisma.baby.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const babyWithIdOnly = await prisma.baby.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BabyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BabyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BabyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Baby.
     * @param {BabyCreateArgs} args - Arguments to create a Baby.
     * @example
     * // Create one Baby
     * const Baby = await prisma.baby.create({
     *   data: {
     *     // ... data to create a Baby
     *   }
     * })
     * 
    **/
    create<T extends BabyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BabyCreateArgs<ExtArgs>>
    ): Prisma__BabyClient<$Result.GetResult<Prisma.$BabyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Babies.
     *     @param {BabyCreateManyArgs} args - Arguments to create many Babies.
     *     @example
     *     // Create many Babies
     *     const baby = await prisma.baby.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BabyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BabyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Baby.
     * @param {BabyDeleteArgs} args - Arguments to delete one Baby.
     * @example
     * // Delete one Baby
     * const Baby = await prisma.baby.delete({
     *   where: {
     *     // ... filter to delete one Baby
     *   }
     * })
     * 
    **/
    delete<T extends BabyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BabyDeleteArgs<ExtArgs>>
    ): Prisma__BabyClient<$Result.GetResult<Prisma.$BabyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Baby.
     * @param {BabyUpdateArgs} args - Arguments to update one Baby.
     * @example
     * // Update one Baby
     * const baby = await prisma.baby.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BabyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BabyUpdateArgs<ExtArgs>>
    ): Prisma__BabyClient<$Result.GetResult<Prisma.$BabyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Babies.
     * @param {BabyDeleteManyArgs} args - Arguments to filter Babies to delete.
     * @example
     * // Delete a few Babies
     * const { count } = await prisma.baby.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BabyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BabyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Babies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BabyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Babies
     * const baby = await prisma.baby.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BabyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BabyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Baby.
     * @param {BabyUpsertArgs} args - Arguments to update or create a Baby.
     * @example
     * // Update or create a Baby
     * const baby = await prisma.baby.upsert({
     *   create: {
     *     // ... data to create a Baby
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Baby we want to update
     *   }
     * })
    **/
    upsert<T extends BabyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BabyUpsertArgs<ExtArgs>>
    ): Prisma__BabyClient<$Result.GetResult<Prisma.$BabyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Babies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BabyCountArgs} args - Arguments to filter Babies to count.
     * @example
     * // Count the number of Babies
     * const count = await prisma.baby.count({
     *   where: {
     *     // ... the filter for the Babies we want to count
     *   }
     * })
    **/
    count<T extends BabyCountArgs>(
      args?: Subset<T, BabyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BabyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Baby.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BabyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BabyAggregateArgs>(args: Subset<T, BabyAggregateArgs>): Prisma.PrismaPromise<GetBabyAggregateType<T>>

    /**
     * Group by Baby.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BabyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BabyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BabyGroupByArgs['orderBy'] }
        : { orderBy?: BabyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BabyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBabyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Baby model
   */
  readonly fields: BabyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Baby.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BabyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    caregivers<T extends Baby$caregiversArgs<ExtArgs> = {}>(args?: Subset<T, Baby$caregiversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BabyCaregiverPayload<ExtArgs>, T, 'findMany'> | Null>;

    eliminations<T extends Baby$eliminationsArgs<ExtArgs> = {}>(args?: Subset<T, Baby$eliminationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EliminationPayload<ExtArgs>, T, 'findMany'> | Null>;

    feedings<T extends Baby$feedingsArgs<ExtArgs> = {}>(args?: Subset<T, Baby$feedingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedingPayload<ExtArgs>, T, 'findMany'> | Null>;

    sleepsleepSessions<T extends Baby$sleepsleepSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Baby$sleepsleepSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SleepPayload<ExtArgs>, T, 'findMany'> | Null>;

    activities<T extends Baby$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Baby$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, 'findMany'> | Null>;

    photos<T extends Baby$photosArgs<ExtArgs> = {}>(args?: Subset<T, Baby$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BabyPhotoPayload<ExtArgs>, T, 'findMany'> | Null>;

    milestones<T extends Baby$milestonesArgs<ExtArgs> = {}>(args?: Subset<T, Baby$milestonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, 'findMany'> | Null>;

    healthRecords<T extends Baby$healthRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Baby$healthRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, 'findMany'> | Null>;

    measurements<T extends Baby$measurementsArgs<ExtArgs> = {}>(args?: Subset<T, Baby$measurementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeasurementPayload<ExtArgs>, T, 'findMany'> | Null>;

    albums<T extends Baby$albumsArgs<ExtArgs> = {}>(args?: Subset<T, Baby$albumsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, 'findMany'> | Null>;

    parentInvites<T extends Baby$parentInvitesArgs<ExtArgs> = {}>(args?: Subset<T, Baby$parentInvitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentInvitePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Baby model
   */ 
  interface BabyFieldRefs {
    readonly id: FieldRef<"Baby", 'Int'>
    readonly firstName: FieldRef<"Baby", 'String'>
    readonly lastName: FieldRef<"Baby", 'String'>
    readonly dateOfBirth: FieldRef<"Baby", 'DateTime'>
    readonly gender: FieldRef<"Baby", 'String'>
    readonly createdAt: FieldRef<"Baby", 'DateTime'>
    readonly updatedAt: FieldRef<"Baby", 'DateTime'>
    readonly ownerId: FieldRef<"Baby", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Baby findUnique
   */
  export type BabyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baby
     */
    select?: BabySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyInclude<ExtArgs> | null
    /**
     * Filter, which Baby to fetch.
     */
    where: BabyWhereUniqueInput
  }


  /**
   * Baby findUniqueOrThrow
   */
  export type BabyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baby
     */
    select?: BabySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyInclude<ExtArgs> | null
    /**
     * Filter, which Baby to fetch.
     */
    where: BabyWhereUniqueInput
  }


  /**
   * Baby findFirst
   */
  export type BabyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baby
     */
    select?: BabySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyInclude<ExtArgs> | null
    /**
     * Filter, which Baby to fetch.
     */
    where?: BabyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Babies to fetch.
     */
    orderBy?: BabyOrderByWithRelationInput | BabyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Babies.
     */
    cursor?: BabyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Babies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Babies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Babies.
     */
    distinct?: BabyScalarFieldEnum | BabyScalarFieldEnum[]
  }


  /**
   * Baby findFirstOrThrow
   */
  export type BabyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baby
     */
    select?: BabySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyInclude<ExtArgs> | null
    /**
     * Filter, which Baby to fetch.
     */
    where?: BabyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Babies to fetch.
     */
    orderBy?: BabyOrderByWithRelationInput | BabyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Babies.
     */
    cursor?: BabyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Babies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Babies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Babies.
     */
    distinct?: BabyScalarFieldEnum | BabyScalarFieldEnum[]
  }


  /**
   * Baby findMany
   */
  export type BabyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baby
     */
    select?: BabySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyInclude<ExtArgs> | null
    /**
     * Filter, which Babies to fetch.
     */
    where?: BabyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Babies to fetch.
     */
    orderBy?: BabyOrderByWithRelationInput | BabyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Babies.
     */
    cursor?: BabyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Babies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Babies.
     */
    skip?: number
    distinct?: BabyScalarFieldEnum | BabyScalarFieldEnum[]
  }


  /**
   * Baby create
   */
  export type BabyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baby
     */
    select?: BabySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyInclude<ExtArgs> | null
    /**
     * The data needed to create a Baby.
     */
    data: XOR<BabyCreateInput, BabyUncheckedCreateInput>
  }


  /**
   * Baby createMany
   */
  export type BabyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Babies.
     */
    data: BabyCreateManyInput | BabyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Baby update
   */
  export type BabyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baby
     */
    select?: BabySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyInclude<ExtArgs> | null
    /**
     * The data needed to update a Baby.
     */
    data: XOR<BabyUpdateInput, BabyUncheckedUpdateInput>
    /**
     * Choose, which Baby to update.
     */
    where: BabyWhereUniqueInput
  }


  /**
   * Baby updateMany
   */
  export type BabyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Babies.
     */
    data: XOR<BabyUpdateManyMutationInput, BabyUncheckedUpdateManyInput>
    /**
     * Filter which Babies to update
     */
    where?: BabyWhereInput
  }


  /**
   * Baby upsert
   */
  export type BabyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baby
     */
    select?: BabySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyInclude<ExtArgs> | null
    /**
     * The filter to search for the Baby to update in case it exists.
     */
    where: BabyWhereUniqueInput
    /**
     * In case the Baby found by the `where` argument doesn't exist, create a new Baby with this data.
     */
    create: XOR<BabyCreateInput, BabyUncheckedCreateInput>
    /**
     * In case the Baby was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BabyUpdateInput, BabyUncheckedUpdateInput>
  }


  /**
   * Baby delete
   */
  export type BabyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baby
     */
    select?: BabySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyInclude<ExtArgs> | null
    /**
     * Filter which Baby to delete.
     */
    where: BabyWhereUniqueInput
  }


  /**
   * Baby deleteMany
   */
  export type BabyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Babies to delete
     */
    where?: BabyWhereInput
  }


  /**
   * Baby.caregivers
   */
  export type Baby$caregiversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BabyCaregiver
     */
    select?: BabyCaregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyCaregiverInclude<ExtArgs> | null
    where?: BabyCaregiverWhereInput
    orderBy?: BabyCaregiverOrderByWithRelationInput | BabyCaregiverOrderByWithRelationInput[]
    cursor?: BabyCaregiverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BabyCaregiverScalarFieldEnum | BabyCaregiverScalarFieldEnum[]
  }


  /**
   * Baby.eliminations
   */
  export type Baby$eliminationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Elimination
     */
    select?: EliminationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EliminationInclude<ExtArgs> | null
    where?: EliminationWhereInput
    orderBy?: EliminationOrderByWithRelationInput | EliminationOrderByWithRelationInput[]
    cursor?: EliminationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EliminationScalarFieldEnum | EliminationScalarFieldEnum[]
  }


  /**
   * Baby.feedings
   */
  export type Baby$feedingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feeding
     */
    select?: FeedingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedingInclude<ExtArgs> | null
    where?: FeedingWhereInput
    orderBy?: FeedingOrderByWithRelationInput | FeedingOrderByWithRelationInput[]
    cursor?: FeedingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedingScalarFieldEnum | FeedingScalarFieldEnum[]
  }


  /**
   * Baby.sleepsleepSessions
   */
  export type Baby$sleepsleepSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sleep
     */
    select?: SleepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SleepInclude<ExtArgs> | null
    where?: SleepWhereInput
    orderBy?: SleepOrderByWithRelationInput | SleepOrderByWithRelationInput[]
    cursor?: SleepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SleepScalarFieldEnum | SleepScalarFieldEnum[]
  }


  /**
   * Baby.activities
   */
  export type Baby$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }


  /**
   * Baby.photos
   */
  export type Baby$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BabyPhoto
     */
    select?: BabyPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyPhotoInclude<ExtArgs> | null
    where?: BabyPhotoWhereInput
    orderBy?: BabyPhotoOrderByWithRelationInput | BabyPhotoOrderByWithRelationInput[]
    cursor?: BabyPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BabyPhotoScalarFieldEnum | BabyPhotoScalarFieldEnum[]
  }


  /**
   * Baby.milestones
   */
  export type Baby$milestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestoneInclude<ExtArgs> | null
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    cursor?: MilestoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }


  /**
   * Baby.healthRecords
   */
  export type Baby$healthRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HealthRecordInclude<ExtArgs> | null
    where?: HealthRecordWhereInput
    orderBy?: HealthRecordOrderByWithRelationInput | HealthRecordOrderByWithRelationInput[]
    cursor?: HealthRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HealthRecordScalarFieldEnum | HealthRecordScalarFieldEnum[]
  }


  /**
   * Baby.measurements
   */
  export type Baby$measurementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Measurement
     */
    select?: MeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeasurementInclude<ExtArgs> | null
    where?: MeasurementWhereInput
    orderBy?: MeasurementOrderByWithRelationInput | MeasurementOrderByWithRelationInput[]
    cursor?: MeasurementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeasurementScalarFieldEnum | MeasurementScalarFieldEnum[]
  }


  /**
   * Baby.albums
   */
  export type Baby$albumsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumInclude<ExtArgs> | null
    where?: AlbumWhereInput
    orderBy?: AlbumOrderByWithRelationInput | AlbumOrderByWithRelationInput[]
    cursor?: AlbumWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlbumScalarFieldEnum | AlbumScalarFieldEnum[]
  }


  /**
   * Baby.parentInvites
   */
  export type Baby$parentInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvite
     */
    select?: ParentInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParentInviteInclude<ExtArgs> | null
    where?: ParentInviteWhereInput
    orderBy?: ParentInviteOrderByWithRelationInput | ParentInviteOrderByWithRelationInput[]
    cursor?: ParentInviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParentInviteScalarFieldEnum | ParentInviteScalarFieldEnum[]
  }


  /**
   * Baby without action
   */
  export type BabyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baby
     */
    select?: BabySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyInclude<ExtArgs> | null
  }



  /**
   * Model BabyCaregiver
   */

  export type AggregateBabyCaregiver = {
    _count: BabyCaregiverCountAggregateOutputType | null
    _avg: BabyCaregiverAvgAggregateOutputType | null
    _sum: BabyCaregiverSumAggregateOutputType | null
    _min: BabyCaregiverMinAggregateOutputType | null
    _max: BabyCaregiverMaxAggregateOutputType | null
  }

  export type BabyCaregiverAvgAggregateOutputType = {
    id: number | null
    babyId: number | null
    userId: number | null
  }

  export type BabyCaregiverSumAggregateOutputType = {
    id: number | null
    babyId: number | null
    userId: number | null
  }

  export type BabyCaregiverMinAggregateOutputType = {
    id: number | null
    relationship: string | null
    createdAt: Date | null
    updatedAt: Date | null
    babyId: number | null
    userId: number | null
  }

  export type BabyCaregiverMaxAggregateOutputType = {
    id: number | null
    relationship: string | null
    createdAt: Date | null
    updatedAt: Date | null
    babyId: number | null
    userId: number | null
  }

  export type BabyCaregiverCountAggregateOutputType = {
    id: number
    relationship: number
    permissions: number
    createdAt: number
    updatedAt: number
    babyId: number
    userId: number
    _all: number
  }


  export type BabyCaregiverAvgAggregateInputType = {
    id?: true
    babyId?: true
    userId?: true
  }

  export type BabyCaregiverSumAggregateInputType = {
    id?: true
    babyId?: true
    userId?: true
  }

  export type BabyCaregiverMinAggregateInputType = {
    id?: true
    relationship?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
    userId?: true
  }

  export type BabyCaregiverMaxAggregateInputType = {
    id?: true
    relationship?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
    userId?: true
  }

  export type BabyCaregiverCountAggregateInputType = {
    id?: true
    relationship?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
    userId?: true
    _all?: true
  }

  export type BabyCaregiverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BabyCaregiver to aggregate.
     */
    where?: BabyCaregiverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BabyCaregivers to fetch.
     */
    orderBy?: BabyCaregiverOrderByWithRelationInput | BabyCaregiverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BabyCaregiverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BabyCaregivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BabyCaregivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BabyCaregivers
    **/
    _count?: true | BabyCaregiverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BabyCaregiverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BabyCaregiverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BabyCaregiverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BabyCaregiverMaxAggregateInputType
  }

  export type GetBabyCaregiverAggregateType<T extends BabyCaregiverAggregateArgs> = {
        [P in keyof T & keyof AggregateBabyCaregiver]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBabyCaregiver[P]>
      : GetScalarType<T[P], AggregateBabyCaregiver[P]>
  }




  export type BabyCaregiverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BabyCaregiverWhereInput
    orderBy?: BabyCaregiverOrderByWithAggregationInput | BabyCaregiverOrderByWithAggregationInput[]
    by: BabyCaregiverScalarFieldEnum[] | BabyCaregiverScalarFieldEnum
    having?: BabyCaregiverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BabyCaregiverCountAggregateInputType | true
    _avg?: BabyCaregiverAvgAggregateInputType
    _sum?: BabyCaregiverSumAggregateInputType
    _min?: BabyCaregiverMinAggregateInputType
    _max?: BabyCaregiverMaxAggregateInputType
  }

  export type BabyCaregiverGroupByOutputType = {
    id: number
    relationship: string
    permissions: string[]
    createdAt: Date
    updatedAt: Date
    babyId: number
    userId: number
    _count: BabyCaregiverCountAggregateOutputType | null
    _avg: BabyCaregiverAvgAggregateOutputType | null
    _sum: BabyCaregiverSumAggregateOutputType | null
    _min: BabyCaregiverMinAggregateOutputType | null
    _max: BabyCaregiverMaxAggregateOutputType | null
  }

  type GetBabyCaregiverGroupByPayload<T extends BabyCaregiverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BabyCaregiverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BabyCaregiverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BabyCaregiverGroupByOutputType[P]>
            : GetScalarType<T[P], BabyCaregiverGroupByOutputType[P]>
        }
      >
    >


  export type BabyCaregiverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationship?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    babyId?: boolean
    userId?: boolean
    baby?: boolean | BabyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["babyCaregiver"]>

  export type BabyCaregiverSelectScalar = {
    id?: boolean
    relationship?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    babyId?: boolean
    userId?: boolean
  }

  export type BabyCaregiverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    baby?: boolean | BabyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $BabyCaregiverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BabyCaregiver"
    objects: {
      baby: Prisma.$BabyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      relationship: string
      permissions: string[]
      createdAt: Date
      updatedAt: Date
      babyId: number
      userId: number
    }, ExtArgs["result"]["babyCaregiver"]>
    composites: {}
  }


  type BabyCaregiverGetPayload<S extends boolean | null | undefined | BabyCaregiverDefaultArgs> = $Result.GetResult<Prisma.$BabyCaregiverPayload, S>

  type BabyCaregiverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BabyCaregiverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BabyCaregiverCountAggregateInputType | true
    }

  export interface BabyCaregiverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BabyCaregiver'], meta: { name: 'BabyCaregiver' } }
    /**
     * Find zero or one BabyCaregiver that matches the filter.
     * @param {BabyCaregiverFindUniqueArgs} args - Arguments to find a BabyCaregiver
     * @example
     * // Get one BabyCaregiver
     * const babyCaregiver = await prisma.babyCaregiver.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BabyCaregiverFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BabyCaregiverFindUniqueArgs<ExtArgs>>
    ): Prisma__BabyCaregiverClient<$Result.GetResult<Prisma.$BabyCaregiverPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BabyCaregiver that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BabyCaregiverFindUniqueOrThrowArgs} args - Arguments to find a BabyCaregiver
     * @example
     * // Get one BabyCaregiver
     * const babyCaregiver = await prisma.babyCaregiver.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BabyCaregiverFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BabyCaregiverFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BabyCaregiverClient<$Result.GetResult<Prisma.$BabyCaregiverPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BabyCaregiver that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BabyCaregiverFindFirstArgs} args - Arguments to find a BabyCaregiver
     * @example
     * // Get one BabyCaregiver
     * const babyCaregiver = await prisma.babyCaregiver.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BabyCaregiverFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BabyCaregiverFindFirstArgs<ExtArgs>>
    ): Prisma__BabyCaregiverClient<$Result.GetResult<Prisma.$BabyCaregiverPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BabyCaregiver that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BabyCaregiverFindFirstOrThrowArgs} args - Arguments to find a BabyCaregiver
     * @example
     * // Get one BabyCaregiver
     * const babyCaregiver = await prisma.babyCaregiver.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BabyCaregiverFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BabyCaregiverFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BabyCaregiverClient<$Result.GetResult<Prisma.$BabyCaregiverPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BabyCaregivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BabyCaregiverFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BabyCaregivers
     * const babyCaregivers = await prisma.babyCaregiver.findMany()
     * 
     * // Get first 10 BabyCaregivers
     * const babyCaregivers = await prisma.babyCaregiver.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const babyCaregiverWithIdOnly = await prisma.babyCaregiver.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BabyCaregiverFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BabyCaregiverFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BabyCaregiverPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BabyCaregiver.
     * @param {BabyCaregiverCreateArgs} args - Arguments to create a BabyCaregiver.
     * @example
     * // Create one BabyCaregiver
     * const BabyCaregiver = await prisma.babyCaregiver.create({
     *   data: {
     *     // ... data to create a BabyCaregiver
     *   }
     * })
     * 
    **/
    create<T extends BabyCaregiverCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BabyCaregiverCreateArgs<ExtArgs>>
    ): Prisma__BabyCaregiverClient<$Result.GetResult<Prisma.$BabyCaregiverPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BabyCaregivers.
     *     @param {BabyCaregiverCreateManyArgs} args - Arguments to create many BabyCaregivers.
     *     @example
     *     // Create many BabyCaregivers
     *     const babyCaregiver = await prisma.babyCaregiver.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BabyCaregiverCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BabyCaregiverCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BabyCaregiver.
     * @param {BabyCaregiverDeleteArgs} args - Arguments to delete one BabyCaregiver.
     * @example
     * // Delete one BabyCaregiver
     * const BabyCaregiver = await prisma.babyCaregiver.delete({
     *   where: {
     *     // ... filter to delete one BabyCaregiver
     *   }
     * })
     * 
    **/
    delete<T extends BabyCaregiverDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BabyCaregiverDeleteArgs<ExtArgs>>
    ): Prisma__BabyCaregiverClient<$Result.GetResult<Prisma.$BabyCaregiverPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BabyCaregiver.
     * @param {BabyCaregiverUpdateArgs} args - Arguments to update one BabyCaregiver.
     * @example
     * // Update one BabyCaregiver
     * const babyCaregiver = await prisma.babyCaregiver.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BabyCaregiverUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BabyCaregiverUpdateArgs<ExtArgs>>
    ): Prisma__BabyCaregiverClient<$Result.GetResult<Prisma.$BabyCaregiverPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BabyCaregivers.
     * @param {BabyCaregiverDeleteManyArgs} args - Arguments to filter BabyCaregivers to delete.
     * @example
     * // Delete a few BabyCaregivers
     * const { count } = await prisma.babyCaregiver.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BabyCaregiverDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BabyCaregiverDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BabyCaregivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BabyCaregiverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BabyCaregivers
     * const babyCaregiver = await prisma.babyCaregiver.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BabyCaregiverUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BabyCaregiverUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BabyCaregiver.
     * @param {BabyCaregiverUpsertArgs} args - Arguments to update or create a BabyCaregiver.
     * @example
     * // Update or create a BabyCaregiver
     * const babyCaregiver = await prisma.babyCaregiver.upsert({
     *   create: {
     *     // ... data to create a BabyCaregiver
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BabyCaregiver we want to update
     *   }
     * })
    **/
    upsert<T extends BabyCaregiverUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BabyCaregiverUpsertArgs<ExtArgs>>
    ): Prisma__BabyCaregiverClient<$Result.GetResult<Prisma.$BabyCaregiverPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BabyCaregivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BabyCaregiverCountArgs} args - Arguments to filter BabyCaregivers to count.
     * @example
     * // Count the number of BabyCaregivers
     * const count = await prisma.babyCaregiver.count({
     *   where: {
     *     // ... the filter for the BabyCaregivers we want to count
     *   }
     * })
    **/
    count<T extends BabyCaregiverCountArgs>(
      args?: Subset<T, BabyCaregiverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BabyCaregiverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BabyCaregiver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BabyCaregiverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BabyCaregiverAggregateArgs>(args: Subset<T, BabyCaregiverAggregateArgs>): Prisma.PrismaPromise<GetBabyCaregiverAggregateType<T>>

    /**
     * Group by BabyCaregiver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BabyCaregiverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BabyCaregiverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BabyCaregiverGroupByArgs['orderBy'] }
        : { orderBy?: BabyCaregiverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BabyCaregiverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBabyCaregiverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BabyCaregiver model
   */
  readonly fields: BabyCaregiverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BabyCaregiver.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BabyCaregiverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    baby<T extends BabyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BabyDefaultArgs<ExtArgs>>): Prisma__BabyClient<$Result.GetResult<Prisma.$BabyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BabyCaregiver model
   */ 
  interface BabyCaregiverFieldRefs {
    readonly id: FieldRef<"BabyCaregiver", 'Int'>
    readonly relationship: FieldRef<"BabyCaregiver", 'String'>
    readonly permissions: FieldRef<"BabyCaregiver", 'String[]'>
    readonly createdAt: FieldRef<"BabyCaregiver", 'DateTime'>
    readonly updatedAt: FieldRef<"BabyCaregiver", 'DateTime'>
    readonly babyId: FieldRef<"BabyCaregiver", 'Int'>
    readonly userId: FieldRef<"BabyCaregiver", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * BabyCaregiver findUnique
   */
  export type BabyCaregiverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BabyCaregiver
     */
    select?: BabyCaregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyCaregiverInclude<ExtArgs> | null
    /**
     * Filter, which BabyCaregiver to fetch.
     */
    where: BabyCaregiverWhereUniqueInput
  }


  /**
   * BabyCaregiver findUniqueOrThrow
   */
  export type BabyCaregiverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BabyCaregiver
     */
    select?: BabyCaregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyCaregiverInclude<ExtArgs> | null
    /**
     * Filter, which BabyCaregiver to fetch.
     */
    where: BabyCaregiverWhereUniqueInput
  }


  /**
   * BabyCaregiver findFirst
   */
  export type BabyCaregiverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BabyCaregiver
     */
    select?: BabyCaregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyCaregiverInclude<ExtArgs> | null
    /**
     * Filter, which BabyCaregiver to fetch.
     */
    where?: BabyCaregiverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BabyCaregivers to fetch.
     */
    orderBy?: BabyCaregiverOrderByWithRelationInput | BabyCaregiverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BabyCaregivers.
     */
    cursor?: BabyCaregiverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BabyCaregivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BabyCaregivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BabyCaregivers.
     */
    distinct?: BabyCaregiverScalarFieldEnum | BabyCaregiverScalarFieldEnum[]
  }


  /**
   * BabyCaregiver findFirstOrThrow
   */
  export type BabyCaregiverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BabyCaregiver
     */
    select?: BabyCaregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyCaregiverInclude<ExtArgs> | null
    /**
     * Filter, which BabyCaregiver to fetch.
     */
    where?: BabyCaregiverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BabyCaregivers to fetch.
     */
    orderBy?: BabyCaregiverOrderByWithRelationInput | BabyCaregiverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BabyCaregivers.
     */
    cursor?: BabyCaregiverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BabyCaregivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BabyCaregivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BabyCaregivers.
     */
    distinct?: BabyCaregiverScalarFieldEnum | BabyCaregiverScalarFieldEnum[]
  }


  /**
   * BabyCaregiver findMany
   */
  export type BabyCaregiverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BabyCaregiver
     */
    select?: BabyCaregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyCaregiverInclude<ExtArgs> | null
    /**
     * Filter, which BabyCaregivers to fetch.
     */
    where?: BabyCaregiverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BabyCaregivers to fetch.
     */
    orderBy?: BabyCaregiverOrderByWithRelationInput | BabyCaregiverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BabyCaregivers.
     */
    cursor?: BabyCaregiverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BabyCaregivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BabyCaregivers.
     */
    skip?: number
    distinct?: BabyCaregiverScalarFieldEnum | BabyCaregiverScalarFieldEnum[]
  }


  /**
   * BabyCaregiver create
   */
  export type BabyCaregiverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BabyCaregiver
     */
    select?: BabyCaregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyCaregiverInclude<ExtArgs> | null
    /**
     * The data needed to create a BabyCaregiver.
     */
    data: XOR<BabyCaregiverCreateInput, BabyCaregiverUncheckedCreateInput>
  }


  /**
   * BabyCaregiver createMany
   */
  export type BabyCaregiverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BabyCaregivers.
     */
    data: BabyCaregiverCreateManyInput | BabyCaregiverCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BabyCaregiver update
   */
  export type BabyCaregiverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BabyCaregiver
     */
    select?: BabyCaregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyCaregiverInclude<ExtArgs> | null
    /**
     * The data needed to update a BabyCaregiver.
     */
    data: XOR<BabyCaregiverUpdateInput, BabyCaregiverUncheckedUpdateInput>
    /**
     * Choose, which BabyCaregiver to update.
     */
    where: BabyCaregiverWhereUniqueInput
  }


  /**
   * BabyCaregiver updateMany
   */
  export type BabyCaregiverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BabyCaregivers.
     */
    data: XOR<BabyCaregiverUpdateManyMutationInput, BabyCaregiverUncheckedUpdateManyInput>
    /**
     * Filter which BabyCaregivers to update
     */
    where?: BabyCaregiverWhereInput
  }


  /**
   * BabyCaregiver upsert
   */
  export type BabyCaregiverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BabyCaregiver
     */
    select?: BabyCaregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyCaregiverInclude<ExtArgs> | null
    /**
     * The filter to search for the BabyCaregiver to update in case it exists.
     */
    where: BabyCaregiverWhereUniqueInput
    /**
     * In case the BabyCaregiver found by the `where` argument doesn't exist, create a new BabyCaregiver with this data.
     */
    create: XOR<BabyCaregiverCreateInput, BabyCaregiverUncheckedCreateInput>
    /**
     * In case the BabyCaregiver was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BabyCaregiverUpdateInput, BabyCaregiverUncheckedUpdateInput>
  }


  /**
   * BabyCaregiver delete
   */
  export type BabyCaregiverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BabyCaregiver
     */
    select?: BabyCaregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyCaregiverInclude<ExtArgs> | null
    /**
     * Filter which BabyCaregiver to delete.
     */
    where: BabyCaregiverWhereUniqueInput
  }


  /**
   * BabyCaregiver deleteMany
   */
  export type BabyCaregiverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BabyCaregivers to delete
     */
    where?: BabyCaregiverWhereInput
  }


  /**
   * BabyCaregiver without action
   */
  export type BabyCaregiverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BabyCaregiver
     */
    select?: BabyCaregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyCaregiverInclude<ExtArgs> | null
  }



  /**
   * Model Elimination
   */

  export type AggregateElimination = {
    _count: EliminationCountAggregateOutputType | null
    _avg: EliminationAvgAggregateOutputType | null
    _sum: EliminationSumAggregateOutputType | null
    _min: EliminationMinAggregateOutputType | null
    _max: EliminationMaxAggregateOutputType | null
  }

  export type EliminationAvgAggregateOutputType = {
    id: number | null
    weight: number | null
    babyId: number | null
  }

  export type EliminationSumAggregateOutputType = {
    id: number | null
    weight: number | null
    babyId: number | null
  }

  export type EliminationMinAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    type: string | null
    weight: number | null
    success: boolean | null
    location: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    babyId: number | null
  }

  export type EliminationMaxAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    type: string | null
    weight: number | null
    success: boolean | null
    location: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    babyId: number | null
  }

  export type EliminationCountAggregateOutputType = {
    id: number
    timestamp: number
    type: number
    weight: number
    success: number
    location: number
    notes: number
    createdAt: number
    updatedAt: number
    babyId: number
    _all: number
  }


  export type EliminationAvgAggregateInputType = {
    id?: true
    weight?: true
    babyId?: true
  }

  export type EliminationSumAggregateInputType = {
    id?: true
    weight?: true
    babyId?: true
  }

  export type EliminationMinAggregateInputType = {
    id?: true
    timestamp?: true
    type?: true
    weight?: true
    success?: true
    location?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
  }

  export type EliminationMaxAggregateInputType = {
    id?: true
    timestamp?: true
    type?: true
    weight?: true
    success?: true
    location?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
  }

  export type EliminationCountAggregateInputType = {
    id?: true
    timestamp?: true
    type?: true
    weight?: true
    success?: true
    location?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
    _all?: true
  }

  export type EliminationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Elimination to aggregate.
     */
    where?: EliminationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eliminations to fetch.
     */
    orderBy?: EliminationOrderByWithRelationInput | EliminationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EliminationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eliminations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eliminations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Eliminations
    **/
    _count?: true | EliminationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EliminationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EliminationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EliminationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EliminationMaxAggregateInputType
  }

  export type GetEliminationAggregateType<T extends EliminationAggregateArgs> = {
        [P in keyof T & keyof AggregateElimination]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateElimination[P]>
      : GetScalarType<T[P], AggregateElimination[P]>
  }




  export type EliminationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EliminationWhereInput
    orderBy?: EliminationOrderByWithAggregationInput | EliminationOrderByWithAggregationInput[]
    by: EliminationScalarFieldEnum[] | EliminationScalarFieldEnum
    having?: EliminationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EliminationCountAggregateInputType | true
    _avg?: EliminationAvgAggregateInputType
    _sum?: EliminationSumAggregateInputType
    _min?: EliminationMinAggregateInputType
    _max?: EliminationMaxAggregateInputType
  }

  export type EliminationGroupByOutputType = {
    id: number
    timestamp: Date
    type: string
    weight: number | null
    success: boolean
    location: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    babyId: number
    _count: EliminationCountAggregateOutputType | null
    _avg: EliminationAvgAggregateOutputType | null
    _sum: EliminationSumAggregateOutputType | null
    _min: EliminationMinAggregateOutputType | null
    _max: EliminationMaxAggregateOutputType | null
  }

  type GetEliminationGroupByPayload<T extends EliminationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EliminationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EliminationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EliminationGroupByOutputType[P]>
            : GetScalarType<T[P], EliminationGroupByOutputType[P]>
        }
      >
    >


  export type EliminationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    type?: boolean
    weight?: boolean
    success?: boolean
    location?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    babyId?: boolean
    baby?: boolean | BabyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["elimination"]>

  export type EliminationSelectScalar = {
    id?: boolean
    timestamp?: boolean
    type?: boolean
    weight?: boolean
    success?: boolean
    location?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    babyId?: boolean
  }

  export type EliminationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    baby?: boolean | BabyDefaultArgs<ExtArgs>
  }


  export type $EliminationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Elimination"
    objects: {
      baby: Prisma.$BabyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      timestamp: Date
      type: string
      weight: number | null
      success: boolean
      location: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      babyId: number
    }, ExtArgs["result"]["elimination"]>
    composites: {}
  }


  type EliminationGetPayload<S extends boolean | null | undefined | EliminationDefaultArgs> = $Result.GetResult<Prisma.$EliminationPayload, S>

  type EliminationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EliminationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EliminationCountAggregateInputType | true
    }

  export interface EliminationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Elimination'], meta: { name: 'Elimination' } }
    /**
     * Find zero or one Elimination that matches the filter.
     * @param {EliminationFindUniqueArgs} args - Arguments to find a Elimination
     * @example
     * // Get one Elimination
     * const elimination = await prisma.elimination.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EliminationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EliminationFindUniqueArgs<ExtArgs>>
    ): Prisma__EliminationClient<$Result.GetResult<Prisma.$EliminationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Elimination that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EliminationFindUniqueOrThrowArgs} args - Arguments to find a Elimination
     * @example
     * // Get one Elimination
     * const elimination = await prisma.elimination.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EliminationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EliminationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EliminationClient<$Result.GetResult<Prisma.$EliminationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Elimination that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EliminationFindFirstArgs} args - Arguments to find a Elimination
     * @example
     * // Get one Elimination
     * const elimination = await prisma.elimination.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EliminationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EliminationFindFirstArgs<ExtArgs>>
    ): Prisma__EliminationClient<$Result.GetResult<Prisma.$EliminationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Elimination that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EliminationFindFirstOrThrowArgs} args - Arguments to find a Elimination
     * @example
     * // Get one Elimination
     * const elimination = await prisma.elimination.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EliminationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EliminationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EliminationClient<$Result.GetResult<Prisma.$EliminationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Eliminations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EliminationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Eliminations
     * const eliminations = await prisma.elimination.findMany()
     * 
     * // Get first 10 Eliminations
     * const eliminations = await prisma.elimination.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eliminationWithIdOnly = await prisma.elimination.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EliminationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EliminationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EliminationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Elimination.
     * @param {EliminationCreateArgs} args - Arguments to create a Elimination.
     * @example
     * // Create one Elimination
     * const Elimination = await prisma.elimination.create({
     *   data: {
     *     // ... data to create a Elimination
     *   }
     * })
     * 
    **/
    create<T extends EliminationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EliminationCreateArgs<ExtArgs>>
    ): Prisma__EliminationClient<$Result.GetResult<Prisma.$EliminationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Eliminations.
     *     @param {EliminationCreateManyArgs} args - Arguments to create many Eliminations.
     *     @example
     *     // Create many Eliminations
     *     const elimination = await prisma.elimination.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EliminationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EliminationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Elimination.
     * @param {EliminationDeleteArgs} args - Arguments to delete one Elimination.
     * @example
     * // Delete one Elimination
     * const Elimination = await prisma.elimination.delete({
     *   where: {
     *     // ... filter to delete one Elimination
     *   }
     * })
     * 
    **/
    delete<T extends EliminationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EliminationDeleteArgs<ExtArgs>>
    ): Prisma__EliminationClient<$Result.GetResult<Prisma.$EliminationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Elimination.
     * @param {EliminationUpdateArgs} args - Arguments to update one Elimination.
     * @example
     * // Update one Elimination
     * const elimination = await prisma.elimination.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EliminationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EliminationUpdateArgs<ExtArgs>>
    ): Prisma__EliminationClient<$Result.GetResult<Prisma.$EliminationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Eliminations.
     * @param {EliminationDeleteManyArgs} args - Arguments to filter Eliminations to delete.
     * @example
     * // Delete a few Eliminations
     * const { count } = await prisma.elimination.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EliminationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EliminationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Eliminations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EliminationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Eliminations
     * const elimination = await prisma.elimination.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EliminationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EliminationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Elimination.
     * @param {EliminationUpsertArgs} args - Arguments to update or create a Elimination.
     * @example
     * // Update or create a Elimination
     * const elimination = await prisma.elimination.upsert({
     *   create: {
     *     // ... data to create a Elimination
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Elimination we want to update
     *   }
     * })
    **/
    upsert<T extends EliminationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EliminationUpsertArgs<ExtArgs>>
    ): Prisma__EliminationClient<$Result.GetResult<Prisma.$EliminationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Eliminations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EliminationCountArgs} args - Arguments to filter Eliminations to count.
     * @example
     * // Count the number of Eliminations
     * const count = await prisma.elimination.count({
     *   where: {
     *     // ... the filter for the Eliminations we want to count
     *   }
     * })
    **/
    count<T extends EliminationCountArgs>(
      args?: Subset<T, EliminationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EliminationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Elimination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EliminationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EliminationAggregateArgs>(args: Subset<T, EliminationAggregateArgs>): Prisma.PrismaPromise<GetEliminationAggregateType<T>>

    /**
     * Group by Elimination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EliminationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EliminationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EliminationGroupByArgs['orderBy'] }
        : { orderBy?: EliminationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EliminationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEliminationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Elimination model
   */
  readonly fields: EliminationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Elimination.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EliminationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    baby<T extends BabyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BabyDefaultArgs<ExtArgs>>): Prisma__BabyClient<$Result.GetResult<Prisma.$BabyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Elimination model
   */ 
  interface EliminationFieldRefs {
    readonly id: FieldRef<"Elimination", 'Int'>
    readonly timestamp: FieldRef<"Elimination", 'DateTime'>
    readonly type: FieldRef<"Elimination", 'String'>
    readonly weight: FieldRef<"Elimination", 'Float'>
    readonly success: FieldRef<"Elimination", 'Boolean'>
    readonly location: FieldRef<"Elimination", 'String'>
    readonly notes: FieldRef<"Elimination", 'String'>
    readonly createdAt: FieldRef<"Elimination", 'DateTime'>
    readonly updatedAt: FieldRef<"Elimination", 'DateTime'>
    readonly babyId: FieldRef<"Elimination", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Elimination findUnique
   */
  export type EliminationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Elimination
     */
    select?: EliminationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EliminationInclude<ExtArgs> | null
    /**
     * Filter, which Elimination to fetch.
     */
    where: EliminationWhereUniqueInput
  }


  /**
   * Elimination findUniqueOrThrow
   */
  export type EliminationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Elimination
     */
    select?: EliminationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EliminationInclude<ExtArgs> | null
    /**
     * Filter, which Elimination to fetch.
     */
    where: EliminationWhereUniqueInput
  }


  /**
   * Elimination findFirst
   */
  export type EliminationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Elimination
     */
    select?: EliminationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EliminationInclude<ExtArgs> | null
    /**
     * Filter, which Elimination to fetch.
     */
    where?: EliminationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eliminations to fetch.
     */
    orderBy?: EliminationOrderByWithRelationInput | EliminationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Eliminations.
     */
    cursor?: EliminationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eliminations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eliminations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Eliminations.
     */
    distinct?: EliminationScalarFieldEnum | EliminationScalarFieldEnum[]
  }


  /**
   * Elimination findFirstOrThrow
   */
  export type EliminationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Elimination
     */
    select?: EliminationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EliminationInclude<ExtArgs> | null
    /**
     * Filter, which Elimination to fetch.
     */
    where?: EliminationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eliminations to fetch.
     */
    orderBy?: EliminationOrderByWithRelationInput | EliminationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Eliminations.
     */
    cursor?: EliminationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eliminations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eliminations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Eliminations.
     */
    distinct?: EliminationScalarFieldEnum | EliminationScalarFieldEnum[]
  }


  /**
   * Elimination findMany
   */
  export type EliminationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Elimination
     */
    select?: EliminationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EliminationInclude<ExtArgs> | null
    /**
     * Filter, which Eliminations to fetch.
     */
    where?: EliminationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eliminations to fetch.
     */
    orderBy?: EliminationOrderByWithRelationInput | EliminationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Eliminations.
     */
    cursor?: EliminationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eliminations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eliminations.
     */
    skip?: number
    distinct?: EliminationScalarFieldEnum | EliminationScalarFieldEnum[]
  }


  /**
   * Elimination create
   */
  export type EliminationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Elimination
     */
    select?: EliminationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EliminationInclude<ExtArgs> | null
    /**
     * The data needed to create a Elimination.
     */
    data: XOR<EliminationCreateInput, EliminationUncheckedCreateInput>
  }


  /**
   * Elimination createMany
   */
  export type EliminationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Eliminations.
     */
    data: EliminationCreateManyInput | EliminationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Elimination update
   */
  export type EliminationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Elimination
     */
    select?: EliminationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EliminationInclude<ExtArgs> | null
    /**
     * The data needed to update a Elimination.
     */
    data: XOR<EliminationUpdateInput, EliminationUncheckedUpdateInput>
    /**
     * Choose, which Elimination to update.
     */
    where: EliminationWhereUniqueInput
  }


  /**
   * Elimination updateMany
   */
  export type EliminationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Eliminations.
     */
    data: XOR<EliminationUpdateManyMutationInput, EliminationUncheckedUpdateManyInput>
    /**
     * Filter which Eliminations to update
     */
    where?: EliminationWhereInput
  }


  /**
   * Elimination upsert
   */
  export type EliminationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Elimination
     */
    select?: EliminationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EliminationInclude<ExtArgs> | null
    /**
     * The filter to search for the Elimination to update in case it exists.
     */
    where: EliminationWhereUniqueInput
    /**
     * In case the Elimination found by the `where` argument doesn't exist, create a new Elimination with this data.
     */
    create: XOR<EliminationCreateInput, EliminationUncheckedCreateInput>
    /**
     * In case the Elimination was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EliminationUpdateInput, EliminationUncheckedUpdateInput>
  }


  /**
   * Elimination delete
   */
  export type EliminationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Elimination
     */
    select?: EliminationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EliminationInclude<ExtArgs> | null
    /**
     * Filter which Elimination to delete.
     */
    where: EliminationWhereUniqueInput
  }


  /**
   * Elimination deleteMany
   */
  export type EliminationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Eliminations to delete
     */
    where?: EliminationWhereInput
  }


  /**
   * Elimination without action
   */
  export type EliminationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Elimination
     */
    select?: EliminationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EliminationInclude<ExtArgs> | null
  }



  /**
   * Model Feeding
   */

  export type AggregateFeeding = {
    _count: FeedingCountAggregateOutputType | null
    _avg: FeedingAvgAggregateOutputType | null
    _sum: FeedingSumAggregateOutputType | null
    _min: FeedingMinAggregateOutputType | null
    _max: FeedingMaxAggregateOutputType | null
  }

  export type FeedingAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    babyId: number | null
  }

  export type FeedingSumAggregateOutputType = {
    id: number | null
    amount: number | null
    babyId: number | null
  }

  export type FeedingMinAggregateOutputType = {
    id: number | null
    startTime: Date | null
    endTime: Date | null
    type: string | null
    side: string | null
    amount: number | null
    food: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    babyId: number | null
  }

  export type FeedingMaxAggregateOutputType = {
    id: number | null
    startTime: Date | null
    endTime: Date | null
    type: string | null
    side: string | null
    amount: number | null
    food: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    babyId: number | null
  }

  export type FeedingCountAggregateOutputType = {
    id: number
    startTime: number
    endTime: number
    type: number
    side: number
    amount: number
    food: number
    notes: number
    createdAt: number
    updatedAt: number
    babyId: number
    _all: number
  }


  export type FeedingAvgAggregateInputType = {
    id?: true
    amount?: true
    babyId?: true
  }

  export type FeedingSumAggregateInputType = {
    id?: true
    amount?: true
    babyId?: true
  }

  export type FeedingMinAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    type?: true
    side?: true
    amount?: true
    food?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
  }

  export type FeedingMaxAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    type?: true
    side?: true
    amount?: true
    food?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
  }

  export type FeedingCountAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    type?: true
    side?: true
    amount?: true
    food?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
    _all?: true
  }

  export type FeedingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feeding to aggregate.
     */
    where?: FeedingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedings to fetch.
     */
    orderBy?: FeedingOrderByWithRelationInput | FeedingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feedings
    **/
    _count?: true | FeedingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedingMaxAggregateInputType
  }

  export type GetFeedingAggregateType<T extends FeedingAggregateArgs> = {
        [P in keyof T & keyof AggregateFeeding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeeding[P]>
      : GetScalarType<T[P], AggregateFeeding[P]>
  }




  export type FeedingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedingWhereInput
    orderBy?: FeedingOrderByWithAggregationInput | FeedingOrderByWithAggregationInput[]
    by: FeedingScalarFieldEnum[] | FeedingScalarFieldEnum
    having?: FeedingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedingCountAggregateInputType | true
    _avg?: FeedingAvgAggregateInputType
    _sum?: FeedingSumAggregateInputType
    _min?: FeedingMinAggregateInputType
    _max?: FeedingMaxAggregateInputType
  }

  export type FeedingGroupByOutputType = {
    id: number
    startTime: Date
    endTime: Date | null
    type: string
    side: string | null
    amount: number | null
    food: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    babyId: number
    _count: FeedingCountAggregateOutputType | null
    _avg: FeedingAvgAggregateOutputType | null
    _sum: FeedingSumAggregateOutputType | null
    _min: FeedingMinAggregateOutputType | null
    _max: FeedingMaxAggregateOutputType | null
  }

  type GetFeedingGroupByPayload<T extends FeedingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedingGroupByOutputType[P]>
            : GetScalarType<T[P], FeedingGroupByOutputType[P]>
        }
      >
    >


  export type FeedingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    type?: boolean
    side?: boolean
    amount?: boolean
    food?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    babyId?: boolean
    baby?: boolean | BabyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeding"]>

  export type FeedingSelectScalar = {
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    type?: boolean
    side?: boolean
    amount?: boolean
    food?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    babyId?: boolean
  }

  export type FeedingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    baby?: boolean | BabyDefaultArgs<ExtArgs>
  }


  export type $FeedingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feeding"
    objects: {
      baby: Prisma.$BabyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      startTime: Date
      endTime: Date | null
      type: string
      side: string | null
      amount: number | null
      food: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      babyId: number
    }, ExtArgs["result"]["feeding"]>
    composites: {}
  }


  type FeedingGetPayload<S extends boolean | null | undefined | FeedingDefaultArgs> = $Result.GetResult<Prisma.$FeedingPayload, S>

  type FeedingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeedingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeedingCountAggregateInputType | true
    }

  export interface FeedingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feeding'], meta: { name: 'Feeding' } }
    /**
     * Find zero or one Feeding that matches the filter.
     * @param {FeedingFindUniqueArgs} args - Arguments to find a Feeding
     * @example
     * // Get one Feeding
     * const feeding = await prisma.feeding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FeedingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FeedingFindUniqueArgs<ExtArgs>>
    ): Prisma__FeedingClient<$Result.GetResult<Prisma.$FeedingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Feeding that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FeedingFindUniqueOrThrowArgs} args - Arguments to find a Feeding
     * @example
     * // Get one Feeding
     * const feeding = await prisma.feeding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FeedingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FeedingClient<$Result.GetResult<Prisma.$FeedingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Feeding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedingFindFirstArgs} args - Arguments to find a Feeding
     * @example
     * // Get one Feeding
     * const feeding = await prisma.feeding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FeedingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedingFindFirstArgs<ExtArgs>>
    ): Prisma__FeedingClient<$Result.GetResult<Prisma.$FeedingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Feeding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedingFindFirstOrThrowArgs} args - Arguments to find a Feeding
     * @example
     * // Get one Feeding
     * const feeding = await prisma.feeding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FeedingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FeedingClient<$Result.GetResult<Prisma.$FeedingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Feedings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedings
     * const feedings = await prisma.feeding.findMany()
     * 
     * // Get first 10 Feedings
     * const feedings = await prisma.feeding.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedingWithIdOnly = await prisma.feeding.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FeedingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Feeding.
     * @param {FeedingCreateArgs} args - Arguments to create a Feeding.
     * @example
     * // Create one Feeding
     * const Feeding = await prisma.feeding.create({
     *   data: {
     *     // ... data to create a Feeding
     *   }
     * })
     * 
    **/
    create<T extends FeedingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FeedingCreateArgs<ExtArgs>>
    ): Prisma__FeedingClient<$Result.GetResult<Prisma.$FeedingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Feedings.
     *     @param {FeedingCreateManyArgs} args - Arguments to create many Feedings.
     *     @example
     *     // Create many Feedings
     *     const feeding = await prisma.feeding.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FeedingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Feeding.
     * @param {FeedingDeleteArgs} args - Arguments to delete one Feeding.
     * @example
     * // Delete one Feeding
     * const Feeding = await prisma.feeding.delete({
     *   where: {
     *     // ... filter to delete one Feeding
     *   }
     * })
     * 
    **/
    delete<T extends FeedingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FeedingDeleteArgs<ExtArgs>>
    ): Prisma__FeedingClient<$Result.GetResult<Prisma.$FeedingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Feeding.
     * @param {FeedingUpdateArgs} args - Arguments to update one Feeding.
     * @example
     * // Update one Feeding
     * const feeding = await prisma.feeding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FeedingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FeedingUpdateArgs<ExtArgs>>
    ): Prisma__FeedingClient<$Result.GetResult<Prisma.$FeedingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Feedings.
     * @param {FeedingDeleteManyArgs} args - Arguments to filter Feedings to delete.
     * @example
     * // Delete a few Feedings
     * const { count } = await prisma.feeding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FeedingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedings
     * const feeding = await prisma.feeding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FeedingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FeedingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Feeding.
     * @param {FeedingUpsertArgs} args - Arguments to update or create a Feeding.
     * @example
     * // Update or create a Feeding
     * const feeding = await prisma.feeding.upsert({
     *   create: {
     *     // ... data to create a Feeding
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feeding we want to update
     *   }
     * })
    **/
    upsert<T extends FeedingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FeedingUpsertArgs<ExtArgs>>
    ): Prisma__FeedingClient<$Result.GetResult<Prisma.$FeedingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Feedings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedingCountArgs} args - Arguments to filter Feedings to count.
     * @example
     * // Count the number of Feedings
     * const count = await prisma.feeding.count({
     *   where: {
     *     // ... the filter for the Feedings we want to count
     *   }
     * })
    **/
    count<T extends FeedingCountArgs>(
      args?: Subset<T, FeedingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feeding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedingAggregateArgs>(args: Subset<T, FeedingAggregateArgs>): Prisma.PrismaPromise<GetFeedingAggregateType<T>>

    /**
     * Group by Feeding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedingGroupByArgs['orderBy'] }
        : { orderBy?: FeedingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feeding model
   */
  readonly fields: FeedingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feeding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    baby<T extends BabyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BabyDefaultArgs<ExtArgs>>): Prisma__BabyClient<$Result.GetResult<Prisma.$BabyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Feeding model
   */ 
  interface FeedingFieldRefs {
    readonly id: FieldRef<"Feeding", 'Int'>
    readonly startTime: FieldRef<"Feeding", 'DateTime'>
    readonly endTime: FieldRef<"Feeding", 'DateTime'>
    readonly type: FieldRef<"Feeding", 'String'>
    readonly side: FieldRef<"Feeding", 'String'>
    readonly amount: FieldRef<"Feeding", 'Float'>
    readonly food: FieldRef<"Feeding", 'String'>
    readonly notes: FieldRef<"Feeding", 'String'>
    readonly createdAt: FieldRef<"Feeding", 'DateTime'>
    readonly updatedAt: FieldRef<"Feeding", 'DateTime'>
    readonly babyId: FieldRef<"Feeding", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Feeding findUnique
   */
  export type FeedingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feeding
     */
    select?: FeedingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedingInclude<ExtArgs> | null
    /**
     * Filter, which Feeding to fetch.
     */
    where: FeedingWhereUniqueInput
  }


  /**
   * Feeding findUniqueOrThrow
   */
  export type FeedingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feeding
     */
    select?: FeedingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedingInclude<ExtArgs> | null
    /**
     * Filter, which Feeding to fetch.
     */
    where: FeedingWhereUniqueInput
  }


  /**
   * Feeding findFirst
   */
  export type FeedingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feeding
     */
    select?: FeedingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedingInclude<ExtArgs> | null
    /**
     * Filter, which Feeding to fetch.
     */
    where?: FeedingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedings to fetch.
     */
    orderBy?: FeedingOrderByWithRelationInput | FeedingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedings.
     */
    cursor?: FeedingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedings.
     */
    distinct?: FeedingScalarFieldEnum | FeedingScalarFieldEnum[]
  }


  /**
   * Feeding findFirstOrThrow
   */
  export type FeedingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feeding
     */
    select?: FeedingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedingInclude<ExtArgs> | null
    /**
     * Filter, which Feeding to fetch.
     */
    where?: FeedingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedings to fetch.
     */
    orderBy?: FeedingOrderByWithRelationInput | FeedingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedings.
     */
    cursor?: FeedingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedings.
     */
    distinct?: FeedingScalarFieldEnum | FeedingScalarFieldEnum[]
  }


  /**
   * Feeding findMany
   */
  export type FeedingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feeding
     */
    select?: FeedingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedingInclude<ExtArgs> | null
    /**
     * Filter, which Feedings to fetch.
     */
    where?: FeedingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedings to fetch.
     */
    orderBy?: FeedingOrderByWithRelationInput | FeedingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feedings.
     */
    cursor?: FeedingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedings.
     */
    skip?: number
    distinct?: FeedingScalarFieldEnum | FeedingScalarFieldEnum[]
  }


  /**
   * Feeding create
   */
  export type FeedingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feeding
     */
    select?: FeedingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedingInclude<ExtArgs> | null
    /**
     * The data needed to create a Feeding.
     */
    data: XOR<FeedingCreateInput, FeedingUncheckedCreateInput>
  }


  /**
   * Feeding createMany
   */
  export type FeedingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feedings.
     */
    data: FeedingCreateManyInput | FeedingCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Feeding update
   */
  export type FeedingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feeding
     */
    select?: FeedingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedingInclude<ExtArgs> | null
    /**
     * The data needed to update a Feeding.
     */
    data: XOR<FeedingUpdateInput, FeedingUncheckedUpdateInput>
    /**
     * Choose, which Feeding to update.
     */
    where: FeedingWhereUniqueInput
  }


  /**
   * Feeding updateMany
   */
  export type FeedingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feedings.
     */
    data: XOR<FeedingUpdateManyMutationInput, FeedingUncheckedUpdateManyInput>
    /**
     * Filter which Feedings to update
     */
    where?: FeedingWhereInput
  }


  /**
   * Feeding upsert
   */
  export type FeedingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feeding
     */
    select?: FeedingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedingInclude<ExtArgs> | null
    /**
     * The filter to search for the Feeding to update in case it exists.
     */
    where: FeedingWhereUniqueInput
    /**
     * In case the Feeding found by the `where` argument doesn't exist, create a new Feeding with this data.
     */
    create: XOR<FeedingCreateInput, FeedingUncheckedCreateInput>
    /**
     * In case the Feeding was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedingUpdateInput, FeedingUncheckedUpdateInput>
  }


  /**
   * Feeding delete
   */
  export type FeedingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feeding
     */
    select?: FeedingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedingInclude<ExtArgs> | null
    /**
     * Filter which Feeding to delete.
     */
    where: FeedingWhereUniqueInput
  }


  /**
   * Feeding deleteMany
   */
  export type FeedingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedings to delete
     */
    where?: FeedingWhereInput
  }


  /**
   * Feeding without action
   */
  export type FeedingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feeding
     */
    select?: FeedingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedingInclude<ExtArgs> | null
  }



  /**
   * Model Sleep
   */

  export type AggregateSleep = {
    _count: SleepCountAggregateOutputType | null
    _avg: SleepAvgAggregateOutputType | null
    _sum: SleepSumAggregateOutputType | null
    _min: SleepMinAggregateOutputType | null
    _max: SleepMaxAggregateOutputType | null
  }

  export type SleepAvgAggregateOutputType = {
    id: number | null
    quality: number | null
    babyId: number | null
  }

  export type SleepSumAggregateOutputType = {
    id: number | null
    quality: number | null
    babyId: number | null
  }

  export type SleepMinAggregateOutputType = {
    id: number | null
    startTime: Date | null
    endTime: Date | null
    how: string | null
    whereFellAsleep: string | null
    whereSlept: string | null
    type: string | null
    quality: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    babyId: number | null
  }

  export type SleepMaxAggregateOutputType = {
    id: number | null
    startTime: Date | null
    endTime: Date | null
    how: string | null
    whereFellAsleep: string | null
    whereSlept: string | null
    type: string | null
    quality: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    babyId: number | null
  }

  export type SleepCountAggregateOutputType = {
    id: number
    startTime: number
    endTime: number
    how: number
    whereFellAsleep: number
    whereSlept: number
    type: number
    quality: number
    notes: number
    createdAt: number
    updatedAt: number
    babyId: number
    _all: number
  }


  export type SleepAvgAggregateInputType = {
    id?: true
    quality?: true
    babyId?: true
  }

  export type SleepSumAggregateInputType = {
    id?: true
    quality?: true
    babyId?: true
  }

  export type SleepMinAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    how?: true
    whereFellAsleep?: true
    whereSlept?: true
    type?: true
    quality?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
  }

  export type SleepMaxAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    how?: true
    whereFellAsleep?: true
    whereSlept?: true
    type?: true
    quality?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
  }

  export type SleepCountAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    how?: true
    whereFellAsleep?: true
    whereSlept?: true
    type?: true
    quality?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
    _all?: true
  }

  export type SleepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sleep to aggregate.
     */
    where?: SleepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sleeps to fetch.
     */
    orderBy?: SleepOrderByWithRelationInput | SleepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SleepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sleeps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sleeps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sleeps
    **/
    _count?: true | SleepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SleepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SleepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SleepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SleepMaxAggregateInputType
  }

  export type GetSleepAggregateType<T extends SleepAggregateArgs> = {
        [P in keyof T & keyof AggregateSleep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSleep[P]>
      : GetScalarType<T[P], AggregateSleep[P]>
  }




  export type SleepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SleepWhereInput
    orderBy?: SleepOrderByWithAggregationInput | SleepOrderByWithAggregationInput[]
    by: SleepScalarFieldEnum[] | SleepScalarFieldEnum
    having?: SleepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SleepCountAggregateInputType | true
    _avg?: SleepAvgAggregateInputType
    _sum?: SleepSumAggregateInputType
    _min?: SleepMinAggregateInputType
    _max?: SleepMaxAggregateInputType
  }

  export type SleepGroupByOutputType = {
    id: number
    startTime: Date
    endTime: Date | null
    how: string | null
    whereFellAsleep: string | null
    whereSlept: string | null
    type: string
    quality: number | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    babyId: number
    _count: SleepCountAggregateOutputType | null
    _avg: SleepAvgAggregateOutputType | null
    _sum: SleepSumAggregateOutputType | null
    _min: SleepMinAggregateOutputType | null
    _max: SleepMaxAggregateOutputType | null
  }

  type GetSleepGroupByPayload<T extends SleepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SleepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SleepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SleepGroupByOutputType[P]>
            : GetScalarType<T[P], SleepGroupByOutputType[P]>
        }
      >
    >


  export type SleepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    how?: boolean
    whereFellAsleep?: boolean
    whereSlept?: boolean
    type?: boolean
    quality?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    babyId?: boolean
    baby?: boolean | BabyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sleep"]>

  export type SleepSelectScalar = {
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    how?: boolean
    whereFellAsleep?: boolean
    whereSlept?: boolean
    type?: boolean
    quality?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    babyId?: boolean
  }

  export type SleepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    baby?: boolean | BabyDefaultArgs<ExtArgs>
  }


  export type $SleepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sleep"
    objects: {
      baby: Prisma.$BabyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      startTime: Date
      endTime: Date | null
      how: string | null
      whereFellAsleep: string | null
      whereSlept: string | null
      type: string
      quality: number | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      babyId: number
    }, ExtArgs["result"]["sleep"]>
    composites: {}
  }


  type SleepGetPayload<S extends boolean | null | undefined | SleepDefaultArgs> = $Result.GetResult<Prisma.$SleepPayload, S>

  type SleepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SleepFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SleepCountAggregateInputType | true
    }

  export interface SleepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sleep'], meta: { name: 'Sleep' } }
    /**
     * Find zero or one Sleep that matches the filter.
     * @param {SleepFindUniqueArgs} args - Arguments to find a Sleep
     * @example
     * // Get one Sleep
     * const sleep = await prisma.sleep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SleepFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SleepFindUniqueArgs<ExtArgs>>
    ): Prisma__SleepClient<$Result.GetResult<Prisma.$SleepPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Sleep that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SleepFindUniqueOrThrowArgs} args - Arguments to find a Sleep
     * @example
     * // Get one Sleep
     * const sleep = await prisma.sleep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SleepFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SleepFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SleepClient<$Result.GetResult<Prisma.$SleepPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Sleep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SleepFindFirstArgs} args - Arguments to find a Sleep
     * @example
     * // Get one Sleep
     * const sleep = await prisma.sleep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SleepFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SleepFindFirstArgs<ExtArgs>>
    ): Prisma__SleepClient<$Result.GetResult<Prisma.$SleepPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Sleep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SleepFindFirstOrThrowArgs} args - Arguments to find a Sleep
     * @example
     * // Get one Sleep
     * const sleep = await prisma.sleep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SleepFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SleepFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SleepClient<$Result.GetResult<Prisma.$SleepPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sleeps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SleepFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sleeps
     * const sleeps = await prisma.sleep.findMany()
     * 
     * // Get first 10 Sleeps
     * const sleeps = await prisma.sleep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sleepWithIdOnly = await prisma.sleep.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SleepFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SleepFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SleepPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Sleep.
     * @param {SleepCreateArgs} args - Arguments to create a Sleep.
     * @example
     * // Create one Sleep
     * const Sleep = await prisma.sleep.create({
     *   data: {
     *     // ... data to create a Sleep
     *   }
     * })
     * 
    **/
    create<T extends SleepCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SleepCreateArgs<ExtArgs>>
    ): Prisma__SleepClient<$Result.GetResult<Prisma.$SleepPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sleeps.
     *     @param {SleepCreateManyArgs} args - Arguments to create many Sleeps.
     *     @example
     *     // Create many Sleeps
     *     const sleep = await prisma.sleep.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SleepCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SleepCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sleep.
     * @param {SleepDeleteArgs} args - Arguments to delete one Sleep.
     * @example
     * // Delete one Sleep
     * const Sleep = await prisma.sleep.delete({
     *   where: {
     *     // ... filter to delete one Sleep
     *   }
     * })
     * 
    **/
    delete<T extends SleepDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SleepDeleteArgs<ExtArgs>>
    ): Prisma__SleepClient<$Result.GetResult<Prisma.$SleepPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Sleep.
     * @param {SleepUpdateArgs} args - Arguments to update one Sleep.
     * @example
     * // Update one Sleep
     * const sleep = await prisma.sleep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SleepUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SleepUpdateArgs<ExtArgs>>
    ): Prisma__SleepClient<$Result.GetResult<Prisma.$SleepPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sleeps.
     * @param {SleepDeleteManyArgs} args - Arguments to filter Sleeps to delete.
     * @example
     * // Delete a few Sleeps
     * const { count } = await prisma.sleep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SleepDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SleepDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sleeps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SleepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sleeps
     * const sleep = await prisma.sleep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SleepUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SleepUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sleep.
     * @param {SleepUpsertArgs} args - Arguments to update or create a Sleep.
     * @example
     * // Update or create a Sleep
     * const sleep = await prisma.sleep.upsert({
     *   create: {
     *     // ... data to create a Sleep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sleep we want to update
     *   }
     * })
    **/
    upsert<T extends SleepUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SleepUpsertArgs<ExtArgs>>
    ): Prisma__SleepClient<$Result.GetResult<Prisma.$SleepPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Sleeps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SleepCountArgs} args - Arguments to filter Sleeps to count.
     * @example
     * // Count the number of Sleeps
     * const count = await prisma.sleep.count({
     *   where: {
     *     // ... the filter for the Sleeps we want to count
     *   }
     * })
    **/
    count<T extends SleepCountArgs>(
      args?: Subset<T, SleepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SleepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sleep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SleepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SleepAggregateArgs>(args: Subset<T, SleepAggregateArgs>): Prisma.PrismaPromise<GetSleepAggregateType<T>>

    /**
     * Group by Sleep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SleepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SleepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SleepGroupByArgs['orderBy'] }
        : { orderBy?: SleepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SleepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSleepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sleep model
   */
  readonly fields: SleepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sleep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SleepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    baby<T extends BabyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BabyDefaultArgs<ExtArgs>>): Prisma__BabyClient<$Result.GetResult<Prisma.$BabyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Sleep model
   */ 
  interface SleepFieldRefs {
    readonly id: FieldRef<"Sleep", 'Int'>
    readonly startTime: FieldRef<"Sleep", 'DateTime'>
    readonly endTime: FieldRef<"Sleep", 'DateTime'>
    readonly how: FieldRef<"Sleep", 'String'>
    readonly whereFellAsleep: FieldRef<"Sleep", 'String'>
    readonly whereSlept: FieldRef<"Sleep", 'String'>
    readonly type: FieldRef<"Sleep", 'String'>
    readonly quality: FieldRef<"Sleep", 'Int'>
    readonly notes: FieldRef<"Sleep", 'String'>
    readonly createdAt: FieldRef<"Sleep", 'DateTime'>
    readonly updatedAt: FieldRef<"Sleep", 'DateTime'>
    readonly babyId: FieldRef<"Sleep", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Sleep findUnique
   */
  export type SleepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sleep
     */
    select?: SleepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SleepInclude<ExtArgs> | null
    /**
     * Filter, which Sleep to fetch.
     */
    where: SleepWhereUniqueInput
  }


  /**
   * Sleep findUniqueOrThrow
   */
  export type SleepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sleep
     */
    select?: SleepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SleepInclude<ExtArgs> | null
    /**
     * Filter, which Sleep to fetch.
     */
    where: SleepWhereUniqueInput
  }


  /**
   * Sleep findFirst
   */
  export type SleepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sleep
     */
    select?: SleepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SleepInclude<ExtArgs> | null
    /**
     * Filter, which Sleep to fetch.
     */
    where?: SleepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sleeps to fetch.
     */
    orderBy?: SleepOrderByWithRelationInput | SleepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sleeps.
     */
    cursor?: SleepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sleeps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sleeps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sleeps.
     */
    distinct?: SleepScalarFieldEnum | SleepScalarFieldEnum[]
  }


  /**
   * Sleep findFirstOrThrow
   */
  export type SleepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sleep
     */
    select?: SleepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SleepInclude<ExtArgs> | null
    /**
     * Filter, which Sleep to fetch.
     */
    where?: SleepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sleeps to fetch.
     */
    orderBy?: SleepOrderByWithRelationInput | SleepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sleeps.
     */
    cursor?: SleepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sleeps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sleeps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sleeps.
     */
    distinct?: SleepScalarFieldEnum | SleepScalarFieldEnum[]
  }


  /**
   * Sleep findMany
   */
  export type SleepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sleep
     */
    select?: SleepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SleepInclude<ExtArgs> | null
    /**
     * Filter, which Sleeps to fetch.
     */
    where?: SleepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sleeps to fetch.
     */
    orderBy?: SleepOrderByWithRelationInput | SleepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sleeps.
     */
    cursor?: SleepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sleeps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sleeps.
     */
    skip?: number
    distinct?: SleepScalarFieldEnum | SleepScalarFieldEnum[]
  }


  /**
   * Sleep create
   */
  export type SleepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sleep
     */
    select?: SleepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SleepInclude<ExtArgs> | null
    /**
     * The data needed to create a Sleep.
     */
    data: XOR<SleepCreateInput, SleepUncheckedCreateInput>
  }


  /**
   * Sleep createMany
   */
  export type SleepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sleeps.
     */
    data: SleepCreateManyInput | SleepCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Sleep update
   */
  export type SleepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sleep
     */
    select?: SleepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SleepInclude<ExtArgs> | null
    /**
     * The data needed to update a Sleep.
     */
    data: XOR<SleepUpdateInput, SleepUncheckedUpdateInput>
    /**
     * Choose, which Sleep to update.
     */
    where: SleepWhereUniqueInput
  }


  /**
   * Sleep updateMany
   */
  export type SleepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sleeps.
     */
    data: XOR<SleepUpdateManyMutationInput, SleepUncheckedUpdateManyInput>
    /**
     * Filter which Sleeps to update
     */
    where?: SleepWhereInput
  }


  /**
   * Sleep upsert
   */
  export type SleepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sleep
     */
    select?: SleepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SleepInclude<ExtArgs> | null
    /**
     * The filter to search for the Sleep to update in case it exists.
     */
    where: SleepWhereUniqueInput
    /**
     * In case the Sleep found by the `where` argument doesn't exist, create a new Sleep with this data.
     */
    create: XOR<SleepCreateInput, SleepUncheckedCreateInput>
    /**
     * In case the Sleep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SleepUpdateInput, SleepUncheckedUpdateInput>
  }


  /**
   * Sleep delete
   */
  export type SleepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sleep
     */
    select?: SleepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SleepInclude<ExtArgs> | null
    /**
     * Filter which Sleep to delete.
     */
    where: SleepWhereUniqueInput
  }


  /**
   * Sleep deleteMany
   */
  export type SleepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sleeps to delete
     */
    where?: SleepWhereInput
  }


  /**
   * Sleep without action
   */
  export type SleepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sleep
     */
    select?: SleepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SleepInclude<ExtArgs> | null
  }



  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityAvgAggregateOutputType = {
    id: number | null
    babyId: number | null
  }

  export type ActivitySumAggregateOutputType = {
    id: number | null
    babyId: number | null
  }

  export type ActivityMinAggregateOutputType = {
    id: number | null
    startTime: Date | null
    endTime: Date | null
    type: string | null
    description: string | null
    milestone: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    babyId: number | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: number | null
    startTime: Date | null
    endTime: Date | null
    type: string | null
    description: string | null
    milestone: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    babyId: number | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    startTime: number
    endTime: number
    type: number
    description: number
    milestone: number
    notes: number
    createdAt: number
    updatedAt: number
    babyId: number
    _all: number
  }


  export type ActivityAvgAggregateInputType = {
    id?: true
    babyId?: true
  }

  export type ActivitySumAggregateInputType = {
    id?: true
    babyId?: true
  }

  export type ActivityMinAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    type?: true
    description?: true
    milestone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    type?: true
    description?: true
    milestone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    type?: true
    description?: true
    milestone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _avg?: ActivityAvgAggregateInputType
    _sum?: ActivitySumAggregateInputType
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: number
    startTime: Date
    endTime: Date | null
    type: string
    description: string | null
    milestone: boolean
    notes: string | null
    createdAt: Date
    updatedAt: Date
    babyId: number
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    type?: boolean
    description?: boolean
    milestone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    babyId?: boolean
    baby?: boolean | BabyDefaultArgs<ExtArgs>
    photos?: boolean | Activity$photosArgs<ExtArgs>
    _count?: boolean | ActivityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    type?: boolean
    description?: boolean
    milestone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    babyId?: boolean
  }

  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    baby?: boolean | BabyDefaultArgs<ExtArgs>
    photos?: boolean | Activity$photosArgs<ExtArgs>
    _count?: boolean | ActivityCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      baby: Prisma.$BabyPayload<ExtArgs>
      photos: Prisma.$ActivityPhotoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      startTime: Date
      endTime: Date | null
      type: string
      description: string | null
      milestone: boolean
      notes: string | null
      createdAt: Date
      updatedAt: Date
      babyId: number
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }


  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ActivityFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>
    ): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Activity that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ActivityFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>
    ): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ActivityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
    **/
    create<T extends ActivityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>
    ): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Activities.
     *     @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     *     @example
     *     // Create many Activities
     *     const activity = await prisma.activity.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ActivityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
    **/
    delete<T extends ActivityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>
    ): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ActivityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>
    ): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ActivityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ActivityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
    **/
    upsert<T extends ActivityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>
    ): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    baby<T extends BabyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BabyDefaultArgs<ExtArgs>>): Prisma__BabyClient<$Result.GetResult<Prisma.$BabyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    photos<T extends Activity$photosArgs<ExtArgs> = {}>(args?: Subset<T, Activity$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPhotoPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Activity model
   */ 
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'Int'>
    readonly startTime: FieldRef<"Activity", 'DateTime'>
    readonly endTime: FieldRef<"Activity", 'DateTime'>
    readonly type: FieldRef<"Activity", 'String'>
    readonly description: FieldRef<"Activity", 'String'>
    readonly milestone: FieldRef<"Activity", 'Boolean'>
    readonly notes: FieldRef<"Activity", 'String'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
    readonly updatedAt: FieldRef<"Activity", 'DateTime'>
    readonly babyId: FieldRef<"Activity", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }


  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }


  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }


  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }


  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }


  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }


  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }


  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
  }


  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }


  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }


  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
  }


  /**
   * Activity.photos
   */
  export type Activity$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityPhoto
     */
    select?: ActivityPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityPhotoInclude<ExtArgs> | null
    where?: ActivityPhotoWhereInput
    orderBy?: ActivityPhotoOrderByWithRelationInput | ActivityPhotoOrderByWithRelationInput[]
    cursor?: ActivityPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityPhotoScalarFieldEnum | ActivityPhotoScalarFieldEnum[]
  }


  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityInclude<ExtArgs> | null
  }



  /**
   * Model Milestone
   */

  export type AggregateMilestone = {
    _count: MilestoneCountAggregateOutputType | null
    _avg: MilestoneAvgAggregateOutputType | null
    _sum: MilestoneSumAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  export type MilestoneAvgAggregateOutputType = {
    id: number | null
    babyId: number | null
  }

  export type MilestoneSumAggregateOutputType = {
    id: number | null
    babyId: number | null
  }

  export type MilestoneMinAggregateOutputType = {
    id: number | null
    date: Date | null
    category: string | null
    title: string | null
    description: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    babyId: number | null
  }

  export type MilestoneMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    category: string | null
    title: string | null
    description: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    babyId: number | null
  }

  export type MilestoneCountAggregateOutputType = {
    id: number
    date: number
    category: number
    title: number
    description: number
    notes: number
    createdAt: number
    updatedAt: number
    babyId: number
    _all: number
  }


  export type MilestoneAvgAggregateInputType = {
    id?: true
    babyId?: true
  }

  export type MilestoneSumAggregateInputType = {
    id?: true
    babyId?: true
  }

  export type MilestoneMinAggregateInputType = {
    id?: true
    date?: true
    category?: true
    title?: true
    description?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
  }

  export type MilestoneMaxAggregateInputType = {
    id?: true
    date?: true
    category?: true
    title?: true
    description?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
  }

  export type MilestoneCountAggregateInputType = {
    id?: true
    date?: true
    category?: true
    title?: true
    description?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
    _all?: true
  }

  export type MilestoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestone to aggregate.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Milestones
    **/
    _count?: true | MilestoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MilestoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MilestoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MilestoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MilestoneMaxAggregateInputType
  }

  export type GetMilestoneAggregateType<T extends MilestoneAggregateArgs> = {
        [P in keyof T & keyof AggregateMilestone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMilestone[P]>
      : GetScalarType<T[P], AggregateMilestone[P]>
  }




  export type MilestoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithAggregationInput | MilestoneOrderByWithAggregationInput[]
    by: MilestoneScalarFieldEnum[] | MilestoneScalarFieldEnum
    having?: MilestoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MilestoneCountAggregateInputType | true
    _avg?: MilestoneAvgAggregateInputType
    _sum?: MilestoneSumAggregateInputType
    _min?: MilestoneMinAggregateInputType
    _max?: MilestoneMaxAggregateInputType
  }

  export type MilestoneGroupByOutputType = {
    id: number
    date: Date
    category: string
    title: string
    description: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    babyId: number
    _count: MilestoneCountAggregateOutputType | null
    _avg: MilestoneAvgAggregateOutputType | null
    _sum: MilestoneSumAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  type GetMilestoneGroupByPayload<T extends MilestoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MilestoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MilestoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
            : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
        }
      >
    >


  export type MilestoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    babyId?: boolean
    baby?: boolean | BabyDefaultArgs<ExtArgs>
    photos?: boolean | Milestone$photosArgs<ExtArgs>
    _count?: boolean | MilestoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectScalar = {
    id?: boolean
    date?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    babyId?: boolean
  }

  export type MilestoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    baby?: boolean | BabyDefaultArgs<ExtArgs>
    photos?: boolean | Milestone$photosArgs<ExtArgs>
    _count?: boolean | MilestoneCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MilestonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Milestone"
    objects: {
      baby: Prisma.$BabyPayload<ExtArgs>
      photos: Prisma.$MilestonePhotoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      category: string
      title: string
      description: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      babyId: number
    }, ExtArgs["result"]["milestone"]>
    composites: {}
  }


  type MilestoneGetPayload<S extends boolean | null | undefined | MilestoneDefaultArgs> = $Result.GetResult<Prisma.$MilestonePayload, S>

  type MilestoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MilestoneFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MilestoneCountAggregateInputType | true
    }

  export interface MilestoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Milestone'], meta: { name: 'Milestone' } }
    /**
     * Find zero or one Milestone that matches the filter.
     * @param {MilestoneFindUniqueArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MilestoneFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MilestoneFindUniqueArgs<ExtArgs>>
    ): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Milestone that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MilestoneFindUniqueOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MilestoneFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MilestoneFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Milestone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MilestoneFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MilestoneFindFirstArgs<ExtArgs>>
    ): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Milestone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MilestoneFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MilestoneFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Milestones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Milestones
     * const milestones = await prisma.milestone.findMany()
     * 
     * // Get first 10 Milestones
     * const milestones = await prisma.milestone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const milestoneWithIdOnly = await prisma.milestone.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MilestoneFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MilestoneFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Milestone.
     * @param {MilestoneCreateArgs} args - Arguments to create a Milestone.
     * @example
     * // Create one Milestone
     * const Milestone = await prisma.milestone.create({
     *   data: {
     *     // ... data to create a Milestone
     *   }
     * })
     * 
    **/
    create<T extends MilestoneCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MilestoneCreateArgs<ExtArgs>>
    ): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Milestones.
     *     @param {MilestoneCreateManyArgs} args - Arguments to create many Milestones.
     *     @example
     *     // Create many Milestones
     *     const milestone = await prisma.milestone.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MilestoneCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MilestoneCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Milestone.
     * @param {MilestoneDeleteArgs} args - Arguments to delete one Milestone.
     * @example
     * // Delete one Milestone
     * const Milestone = await prisma.milestone.delete({
     *   where: {
     *     // ... filter to delete one Milestone
     *   }
     * })
     * 
    **/
    delete<T extends MilestoneDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MilestoneDeleteArgs<ExtArgs>>
    ): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Milestone.
     * @param {MilestoneUpdateArgs} args - Arguments to update one Milestone.
     * @example
     * // Update one Milestone
     * const milestone = await prisma.milestone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MilestoneUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MilestoneUpdateArgs<ExtArgs>>
    ): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Milestones.
     * @param {MilestoneDeleteManyArgs} args - Arguments to filter Milestones to delete.
     * @example
     * // Delete a few Milestones
     * const { count } = await prisma.milestone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MilestoneDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MilestoneDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Milestones
     * const milestone = await prisma.milestone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MilestoneUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MilestoneUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Milestone.
     * @param {MilestoneUpsertArgs} args - Arguments to update or create a Milestone.
     * @example
     * // Update or create a Milestone
     * const milestone = await prisma.milestone.upsert({
     *   create: {
     *     // ... data to create a Milestone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Milestone we want to update
     *   }
     * })
    **/
    upsert<T extends MilestoneUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MilestoneUpsertArgs<ExtArgs>>
    ): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneCountArgs} args - Arguments to filter Milestones to count.
     * @example
     * // Count the number of Milestones
     * const count = await prisma.milestone.count({
     *   where: {
     *     // ... the filter for the Milestones we want to count
     *   }
     * })
    **/
    count<T extends MilestoneCountArgs>(
      args?: Subset<T, MilestoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MilestoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MilestoneAggregateArgs>(args: Subset<T, MilestoneAggregateArgs>): Prisma.PrismaPromise<GetMilestoneAggregateType<T>>

    /**
     * Group by Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MilestoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MilestoneGroupByArgs['orderBy'] }
        : { orderBy?: MilestoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MilestoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMilestoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Milestone model
   */
  readonly fields: MilestoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Milestone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MilestoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    baby<T extends BabyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BabyDefaultArgs<ExtArgs>>): Prisma__BabyClient<$Result.GetResult<Prisma.$BabyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    photos<T extends Milestone$photosArgs<ExtArgs> = {}>(args?: Subset<T, Milestone$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePhotoPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Milestone model
   */ 
  interface MilestoneFieldRefs {
    readonly id: FieldRef<"Milestone", 'Int'>
    readonly date: FieldRef<"Milestone", 'DateTime'>
    readonly category: FieldRef<"Milestone", 'String'>
    readonly title: FieldRef<"Milestone", 'String'>
    readonly description: FieldRef<"Milestone", 'String'>
    readonly notes: FieldRef<"Milestone", 'String'>
    readonly createdAt: FieldRef<"Milestone", 'DateTime'>
    readonly updatedAt: FieldRef<"Milestone", 'DateTime'>
    readonly babyId: FieldRef<"Milestone", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Milestone findUnique
   */
  export type MilestoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }


  /**
   * Milestone findUniqueOrThrow
   */
  export type MilestoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }


  /**
   * Milestone findFirst
   */
  export type MilestoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }


  /**
   * Milestone findFirstOrThrow
   */
  export type MilestoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }


  /**
   * Milestone findMany
   */
  export type MilestoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestones to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }


  /**
   * Milestone create
   */
  export type MilestoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Milestone.
     */
    data: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
  }


  /**
   * Milestone createMany
   */
  export type MilestoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Milestones.
     */
    data: MilestoneCreateManyInput | MilestoneCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Milestone update
   */
  export type MilestoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Milestone.
     */
    data: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
    /**
     * Choose, which Milestone to update.
     */
    where: MilestoneWhereUniqueInput
  }


  /**
   * Milestone updateMany
   */
  export type MilestoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Milestones.
     */
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyInput>
    /**
     * Filter which Milestones to update
     */
    where?: MilestoneWhereInput
  }


  /**
   * Milestone upsert
   */
  export type MilestoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Milestone to update in case it exists.
     */
    where: MilestoneWhereUniqueInput
    /**
     * In case the Milestone found by the `where` argument doesn't exist, create a new Milestone with this data.
     */
    create: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
    /**
     * In case the Milestone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
  }


  /**
   * Milestone delete
   */
  export type MilestoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter which Milestone to delete.
     */
    where: MilestoneWhereUniqueInput
  }


  /**
   * Milestone deleteMany
   */
  export type MilestoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestones to delete
     */
    where?: MilestoneWhereInput
  }


  /**
   * Milestone.photos
   */
  export type Milestone$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilestonePhoto
     */
    select?: MilestonePhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestonePhotoInclude<ExtArgs> | null
    where?: MilestonePhotoWhereInput
    orderBy?: MilestonePhotoOrderByWithRelationInput | MilestonePhotoOrderByWithRelationInput[]
    cursor?: MilestonePhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MilestonePhotoScalarFieldEnum | MilestonePhotoScalarFieldEnum[]
  }


  /**
   * Milestone without action
   */
  export type MilestoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestoneInclude<ExtArgs> | null
  }



  /**
   * Model HealthRecord
   */

  export type AggregateHealthRecord = {
    _count: HealthRecordCountAggregateOutputType | null
    _avg: HealthRecordAvgAggregateOutputType | null
    _sum: HealthRecordSumAggregateOutputType | null
    _min: HealthRecordMinAggregateOutputType | null
    _max: HealthRecordMaxAggregateOutputType | null
  }

  export type HealthRecordAvgAggregateOutputType = {
    id: number | null
    value: number | null
    babyId: number | null
  }

  export type HealthRecordSumAggregateOutputType = {
    id: number | null
    value: number | null
    babyId: number | null
  }

  export type HealthRecordMinAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    type: string | null
    value: number | null
    description: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    babyId: number | null
  }

  export type HealthRecordMaxAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    type: string | null
    value: number | null
    description: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    babyId: number | null
  }

  export type HealthRecordCountAggregateOutputType = {
    id: number
    timestamp: number
    type: number
    value: number
    description: number
    notes: number
    createdAt: number
    updatedAt: number
    babyId: number
    _all: number
  }


  export type HealthRecordAvgAggregateInputType = {
    id?: true
    value?: true
    babyId?: true
  }

  export type HealthRecordSumAggregateInputType = {
    id?: true
    value?: true
    babyId?: true
  }

  export type HealthRecordMinAggregateInputType = {
    id?: true
    timestamp?: true
    type?: true
    value?: true
    description?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
  }

  export type HealthRecordMaxAggregateInputType = {
    id?: true
    timestamp?: true
    type?: true
    value?: true
    description?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
  }

  export type HealthRecordCountAggregateInputType = {
    id?: true
    timestamp?: true
    type?: true
    value?: true
    description?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
    _all?: true
  }

  export type HealthRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthRecord to aggregate.
     */
    where?: HealthRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthRecords to fetch.
     */
    orderBy?: HealthRecordOrderByWithRelationInput | HealthRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HealthRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HealthRecords
    **/
    _count?: true | HealthRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HealthRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HealthRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HealthRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HealthRecordMaxAggregateInputType
  }

  export type GetHealthRecordAggregateType<T extends HealthRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateHealthRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHealthRecord[P]>
      : GetScalarType<T[P], AggregateHealthRecord[P]>
  }




  export type HealthRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthRecordWhereInput
    orderBy?: HealthRecordOrderByWithAggregationInput | HealthRecordOrderByWithAggregationInput[]
    by: HealthRecordScalarFieldEnum[] | HealthRecordScalarFieldEnum
    having?: HealthRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HealthRecordCountAggregateInputType | true
    _avg?: HealthRecordAvgAggregateInputType
    _sum?: HealthRecordSumAggregateInputType
    _min?: HealthRecordMinAggregateInputType
    _max?: HealthRecordMaxAggregateInputType
  }

  export type HealthRecordGroupByOutputType = {
    id: number
    timestamp: Date
    type: string
    value: number | null
    description: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    babyId: number
    _count: HealthRecordCountAggregateOutputType | null
    _avg: HealthRecordAvgAggregateOutputType | null
    _sum: HealthRecordSumAggregateOutputType | null
    _min: HealthRecordMinAggregateOutputType | null
    _max: HealthRecordMaxAggregateOutputType | null
  }

  type GetHealthRecordGroupByPayload<T extends HealthRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HealthRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HealthRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HealthRecordGroupByOutputType[P]>
            : GetScalarType<T[P], HealthRecordGroupByOutputType[P]>
        }
      >
    >


  export type HealthRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    type?: boolean
    value?: boolean
    description?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    babyId?: boolean
    baby?: boolean | BabyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["healthRecord"]>

  export type HealthRecordSelectScalar = {
    id?: boolean
    timestamp?: boolean
    type?: boolean
    value?: boolean
    description?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    babyId?: boolean
  }

  export type HealthRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    baby?: boolean | BabyDefaultArgs<ExtArgs>
  }


  export type $HealthRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HealthRecord"
    objects: {
      baby: Prisma.$BabyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      timestamp: Date
      type: string
      value: number | null
      description: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      babyId: number
    }, ExtArgs["result"]["healthRecord"]>
    composites: {}
  }


  type HealthRecordGetPayload<S extends boolean | null | undefined | HealthRecordDefaultArgs> = $Result.GetResult<Prisma.$HealthRecordPayload, S>

  type HealthRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HealthRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HealthRecordCountAggregateInputType | true
    }

  export interface HealthRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HealthRecord'], meta: { name: 'HealthRecord' } }
    /**
     * Find zero or one HealthRecord that matches the filter.
     * @param {HealthRecordFindUniqueArgs} args - Arguments to find a HealthRecord
     * @example
     * // Get one HealthRecord
     * const healthRecord = await prisma.healthRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HealthRecordFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, HealthRecordFindUniqueArgs<ExtArgs>>
    ): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one HealthRecord that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HealthRecordFindUniqueOrThrowArgs} args - Arguments to find a HealthRecord
     * @example
     * // Get one HealthRecord
     * const healthRecord = await prisma.healthRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HealthRecordFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HealthRecordFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first HealthRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordFindFirstArgs} args - Arguments to find a HealthRecord
     * @example
     * // Get one HealthRecord
     * const healthRecord = await prisma.healthRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HealthRecordFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, HealthRecordFindFirstArgs<ExtArgs>>
    ): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first HealthRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordFindFirstOrThrowArgs} args - Arguments to find a HealthRecord
     * @example
     * // Get one HealthRecord
     * const healthRecord = await prisma.healthRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HealthRecordFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HealthRecordFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more HealthRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HealthRecords
     * const healthRecords = await prisma.healthRecord.findMany()
     * 
     * // Get first 10 HealthRecords
     * const healthRecords = await prisma.healthRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const healthRecordWithIdOnly = await prisma.healthRecord.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HealthRecordFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HealthRecordFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a HealthRecord.
     * @param {HealthRecordCreateArgs} args - Arguments to create a HealthRecord.
     * @example
     * // Create one HealthRecord
     * const HealthRecord = await prisma.healthRecord.create({
     *   data: {
     *     // ... data to create a HealthRecord
     *   }
     * })
     * 
    **/
    create<T extends HealthRecordCreateArgs<ExtArgs>>(
      args: SelectSubset<T, HealthRecordCreateArgs<ExtArgs>>
    ): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many HealthRecords.
     *     @param {HealthRecordCreateManyArgs} args - Arguments to create many HealthRecords.
     *     @example
     *     // Create many HealthRecords
     *     const healthRecord = await prisma.healthRecord.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HealthRecordCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HealthRecordCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HealthRecord.
     * @param {HealthRecordDeleteArgs} args - Arguments to delete one HealthRecord.
     * @example
     * // Delete one HealthRecord
     * const HealthRecord = await prisma.healthRecord.delete({
     *   where: {
     *     // ... filter to delete one HealthRecord
     *   }
     * })
     * 
    **/
    delete<T extends HealthRecordDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, HealthRecordDeleteArgs<ExtArgs>>
    ): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one HealthRecord.
     * @param {HealthRecordUpdateArgs} args - Arguments to update one HealthRecord.
     * @example
     * // Update one HealthRecord
     * const healthRecord = await prisma.healthRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HealthRecordUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, HealthRecordUpdateArgs<ExtArgs>>
    ): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more HealthRecords.
     * @param {HealthRecordDeleteManyArgs} args - Arguments to filter HealthRecords to delete.
     * @example
     * // Delete a few HealthRecords
     * const { count } = await prisma.healthRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HealthRecordDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HealthRecordDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HealthRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HealthRecords
     * const healthRecord = await prisma.healthRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HealthRecordUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, HealthRecordUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HealthRecord.
     * @param {HealthRecordUpsertArgs} args - Arguments to update or create a HealthRecord.
     * @example
     * // Update or create a HealthRecord
     * const healthRecord = await prisma.healthRecord.upsert({
     *   create: {
     *     // ... data to create a HealthRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HealthRecord we want to update
     *   }
     * })
    **/
    upsert<T extends HealthRecordUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, HealthRecordUpsertArgs<ExtArgs>>
    ): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of HealthRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordCountArgs} args - Arguments to filter HealthRecords to count.
     * @example
     * // Count the number of HealthRecords
     * const count = await prisma.healthRecord.count({
     *   where: {
     *     // ... the filter for the HealthRecords we want to count
     *   }
     * })
    **/
    count<T extends HealthRecordCountArgs>(
      args?: Subset<T, HealthRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HealthRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HealthRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HealthRecordAggregateArgs>(args: Subset<T, HealthRecordAggregateArgs>): Prisma.PrismaPromise<GetHealthRecordAggregateType<T>>

    /**
     * Group by HealthRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HealthRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HealthRecordGroupByArgs['orderBy'] }
        : { orderBy?: HealthRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HealthRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHealthRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HealthRecord model
   */
  readonly fields: HealthRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HealthRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HealthRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    baby<T extends BabyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BabyDefaultArgs<ExtArgs>>): Prisma__BabyClient<$Result.GetResult<Prisma.$BabyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the HealthRecord model
   */ 
  interface HealthRecordFieldRefs {
    readonly id: FieldRef<"HealthRecord", 'Int'>
    readonly timestamp: FieldRef<"HealthRecord", 'DateTime'>
    readonly type: FieldRef<"HealthRecord", 'String'>
    readonly value: FieldRef<"HealthRecord", 'Float'>
    readonly description: FieldRef<"HealthRecord", 'String'>
    readonly notes: FieldRef<"HealthRecord", 'String'>
    readonly createdAt: FieldRef<"HealthRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"HealthRecord", 'DateTime'>
    readonly babyId: FieldRef<"HealthRecord", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * HealthRecord findUnique
   */
  export type HealthRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * Filter, which HealthRecord to fetch.
     */
    where: HealthRecordWhereUniqueInput
  }


  /**
   * HealthRecord findUniqueOrThrow
   */
  export type HealthRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * Filter, which HealthRecord to fetch.
     */
    where: HealthRecordWhereUniqueInput
  }


  /**
   * HealthRecord findFirst
   */
  export type HealthRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * Filter, which HealthRecord to fetch.
     */
    where?: HealthRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthRecords to fetch.
     */
    orderBy?: HealthRecordOrderByWithRelationInput | HealthRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthRecords.
     */
    cursor?: HealthRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthRecords.
     */
    distinct?: HealthRecordScalarFieldEnum | HealthRecordScalarFieldEnum[]
  }


  /**
   * HealthRecord findFirstOrThrow
   */
  export type HealthRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * Filter, which HealthRecord to fetch.
     */
    where?: HealthRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthRecords to fetch.
     */
    orderBy?: HealthRecordOrderByWithRelationInput | HealthRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthRecords.
     */
    cursor?: HealthRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthRecords.
     */
    distinct?: HealthRecordScalarFieldEnum | HealthRecordScalarFieldEnum[]
  }


  /**
   * HealthRecord findMany
   */
  export type HealthRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * Filter, which HealthRecords to fetch.
     */
    where?: HealthRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthRecords to fetch.
     */
    orderBy?: HealthRecordOrderByWithRelationInput | HealthRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HealthRecords.
     */
    cursor?: HealthRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthRecords.
     */
    skip?: number
    distinct?: HealthRecordScalarFieldEnum | HealthRecordScalarFieldEnum[]
  }


  /**
   * HealthRecord create
   */
  export type HealthRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a HealthRecord.
     */
    data: XOR<HealthRecordCreateInput, HealthRecordUncheckedCreateInput>
  }


  /**
   * HealthRecord createMany
   */
  export type HealthRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HealthRecords.
     */
    data: HealthRecordCreateManyInput | HealthRecordCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * HealthRecord update
   */
  export type HealthRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a HealthRecord.
     */
    data: XOR<HealthRecordUpdateInput, HealthRecordUncheckedUpdateInput>
    /**
     * Choose, which HealthRecord to update.
     */
    where: HealthRecordWhereUniqueInput
  }


  /**
   * HealthRecord updateMany
   */
  export type HealthRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HealthRecords.
     */
    data: XOR<HealthRecordUpdateManyMutationInput, HealthRecordUncheckedUpdateManyInput>
    /**
     * Filter which HealthRecords to update
     */
    where?: HealthRecordWhereInput
  }


  /**
   * HealthRecord upsert
   */
  export type HealthRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the HealthRecord to update in case it exists.
     */
    where: HealthRecordWhereUniqueInput
    /**
     * In case the HealthRecord found by the `where` argument doesn't exist, create a new HealthRecord with this data.
     */
    create: XOR<HealthRecordCreateInput, HealthRecordUncheckedCreateInput>
    /**
     * In case the HealthRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HealthRecordUpdateInput, HealthRecordUncheckedUpdateInput>
  }


  /**
   * HealthRecord delete
   */
  export type HealthRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * Filter which HealthRecord to delete.
     */
    where: HealthRecordWhereUniqueInput
  }


  /**
   * HealthRecord deleteMany
   */
  export type HealthRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthRecords to delete
     */
    where?: HealthRecordWhereInput
  }


  /**
   * HealthRecord without action
   */
  export type HealthRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HealthRecordInclude<ExtArgs> | null
  }



  /**
   * Model Measurement
   */

  export type AggregateMeasurement = {
    _count: MeasurementCountAggregateOutputType | null
    _avg: MeasurementAvgAggregateOutputType | null
    _sum: MeasurementSumAggregateOutputType | null
    _min: MeasurementMinAggregateOutputType | null
    _max: MeasurementMaxAggregateOutputType | null
  }

  export type MeasurementAvgAggregateOutputType = {
    id: number | null
    weight: number | null
    height: number | null
    headCirc: number | null
    babyId: number | null
  }

  export type MeasurementSumAggregateOutputType = {
    id: number | null
    weight: number | null
    height: number | null
    headCirc: number | null
    babyId: number | null
  }

  export type MeasurementMinAggregateOutputType = {
    id: number | null
    date: Date | null
    weight: number | null
    height: number | null
    headCirc: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    babyId: number | null
  }

  export type MeasurementMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    weight: number | null
    height: number | null
    headCirc: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    babyId: number | null
  }

  export type MeasurementCountAggregateOutputType = {
    id: number
    date: number
    weight: number
    height: number
    headCirc: number
    notes: number
    createdAt: number
    updatedAt: number
    babyId: number
    _all: number
  }


  export type MeasurementAvgAggregateInputType = {
    id?: true
    weight?: true
    height?: true
    headCirc?: true
    babyId?: true
  }

  export type MeasurementSumAggregateInputType = {
    id?: true
    weight?: true
    height?: true
    headCirc?: true
    babyId?: true
  }

  export type MeasurementMinAggregateInputType = {
    id?: true
    date?: true
    weight?: true
    height?: true
    headCirc?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
  }

  export type MeasurementMaxAggregateInputType = {
    id?: true
    date?: true
    weight?: true
    height?: true
    headCirc?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
  }

  export type MeasurementCountAggregateInputType = {
    id?: true
    date?: true
    weight?: true
    height?: true
    headCirc?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
    _all?: true
  }

  export type MeasurementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Measurement to aggregate.
     */
    where?: MeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Measurements to fetch.
     */
    orderBy?: MeasurementOrderByWithRelationInput | MeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Measurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Measurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Measurements
    **/
    _count?: true | MeasurementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MeasurementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MeasurementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeasurementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeasurementMaxAggregateInputType
  }

  export type GetMeasurementAggregateType<T extends MeasurementAggregateArgs> = {
        [P in keyof T & keyof AggregateMeasurement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeasurement[P]>
      : GetScalarType<T[P], AggregateMeasurement[P]>
  }




  export type MeasurementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeasurementWhereInput
    orderBy?: MeasurementOrderByWithAggregationInput | MeasurementOrderByWithAggregationInput[]
    by: MeasurementScalarFieldEnum[] | MeasurementScalarFieldEnum
    having?: MeasurementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeasurementCountAggregateInputType | true
    _avg?: MeasurementAvgAggregateInputType
    _sum?: MeasurementSumAggregateInputType
    _min?: MeasurementMinAggregateInputType
    _max?: MeasurementMaxAggregateInputType
  }

  export type MeasurementGroupByOutputType = {
    id: number
    date: Date
    weight: number | null
    height: number | null
    headCirc: number | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    babyId: number
    _count: MeasurementCountAggregateOutputType | null
    _avg: MeasurementAvgAggregateOutputType | null
    _sum: MeasurementSumAggregateOutputType | null
    _min: MeasurementMinAggregateOutputType | null
    _max: MeasurementMaxAggregateOutputType | null
  }

  type GetMeasurementGroupByPayload<T extends MeasurementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeasurementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeasurementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeasurementGroupByOutputType[P]>
            : GetScalarType<T[P], MeasurementGroupByOutputType[P]>
        }
      >
    >


  export type MeasurementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    weight?: boolean
    height?: boolean
    headCirc?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    babyId?: boolean
    baby?: boolean | BabyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["measurement"]>

  export type MeasurementSelectScalar = {
    id?: boolean
    date?: boolean
    weight?: boolean
    height?: boolean
    headCirc?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    babyId?: boolean
  }

  export type MeasurementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    baby?: boolean | BabyDefaultArgs<ExtArgs>
  }


  export type $MeasurementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Measurement"
    objects: {
      baby: Prisma.$BabyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      weight: number | null
      height: number | null
      headCirc: number | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      babyId: number
    }, ExtArgs["result"]["measurement"]>
    composites: {}
  }


  type MeasurementGetPayload<S extends boolean | null | undefined | MeasurementDefaultArgs> = $Result.GetResult<Prisma.$MeasurementPayload, S>

  type MeasurementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MeasurementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MeasurementCountAggregateInputType | true
    }

  export interface MeasurementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Measurement'], meta: { name: 'Measurement' } }
    /**
     * Find zero or one Measurement that matches the filter.
     * @param {MeasurementFindUniqueArgs} args - Arguments to find a Measurement
     * @example
     * // Get one Measurement
     * const measurement = await prisma.measurement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MeasurementFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MeasurementFindUniqueArgs<ExtArgs>>
    ): Prisma__MeasurementClient<$Result.GetResult<Prisma.$MeasurementPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Measurement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MeasurementFindUniqueOrThrowArgs} args - Arguments to find a Measurement
     * @example
     * // Get one Measurement
     * const measurement = await prisma.measurement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MeasurementFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MeasurementFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MeasurementClient<$Result.GetResult<Prisma.$MeasurementPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Measurement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasurementFindFirstArgs} args - Arguments to find a Measurement
     * @example
     * // Get one Measurement
     * const measurement = await prisma.measurement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MeasurementFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MeasurementFindFirstArgs<ExtArgs>>
    ): Prisma__MeasurementClient<$Result.GetResult<Prisma.$MeasurementPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Measurement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasurementFindFirstOrThrowArgs} args - Arguments to find a Measurement
     * @example
     * // Get one Measurement
     * const measurement = await prisma.measurement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MeasurementFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MeasurementFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MeasurementClient<$Result.GetResult<Prisma.$MeasurementPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Measurements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasurementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Measurements
     * const measurements = await prisma.measurement.findMany()
     * 
     * // Get first 10 Measurements
     * const measurements = await prisma.measurement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const measurementWithIdOnly = await prisma.measurement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MeasurementFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MeasurementFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeasurementPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Measurement.
     * @param {MeasurementCreateArgs} args - Arguments to create a Measurement.
     * @example
     * // Create one Measurement
     * const Measurement = await prisma.measurement.create({
     *   data: {
     *     // ... data to create a Measurement
     *   }
     * })
     * 
    **/
    create<T extends MeasurementCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MeasurementCreateArgs<ExtArgs>>
    ): Prisma__MeasurementClient<$Result.GetResult<Prisma.$MeasurementPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Measurements.
     *     @param {MeasurementCreateManyArgs} args - Arguments to create many Measurements.
     *     @example
     *     // Create many Measurements
     *     const measurement = await prisma.measurement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MeasurementCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MeasurementCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Measurement.
     * @param {MeasurementDeleteArgs} args - Arguments to delete one Measurement.
     * @example
     * // Delete one Measurement
     * const Measurement = await prisma.measurement.delete({
     *   where: {
     *     // ... filter to delete one Measurement
     *   }
     * })
     * 
    **/
    delete<T extends MeasurementDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MeasurementDeleteArgs<ExtArgs>>
    ): Prisma__MeasurementClient<$Result.GetResult<Prisma.$MeasurementPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Measurement.
     * @param {MeasurementUpdateArgs} args - Arguments to update one Measurement.
     * @example
     * // Update one Measurement
     * const measurement = await prisma.measurement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MeasurementUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MeasurementUpdateArgs<ExtArgs>>
    ): Prisma__MeasurementClient<$Result.GetResult<Prisma.$MeasurementPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Measurements.
     * @param {MeasurementDeleteManyArgs} args - Arguments to filter Measurements to delete.
     * @example
     * // Delete a few Measurements
     * const { count } = await prisma.measurement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MeasurementDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MeasurementDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Measurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasurementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Measurements
     * const measurement = await prisma.measurement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MeasurementUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MeasurementUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Measurement.
     * @param {MeasurementUpsertArgs} args - Arguments to update or create a Measurement.
     * @example
     * // Update or create a Measurement
     * const measurement = await prisma.measurement.upsert({
     *   create: {
     *     // ... data to create a Measurement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Measurement we want to update
     *   }
     * })
    **/
    upsert<T extends MeasurementUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MeasurementUpsertArgs<ExtArgs>>
    ): Prisma__MeasurementClient<$Result.GetResult<Prisma.$MeasurementPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Measurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasurementCountArgs} args - Arguments to filter Measurements to count.
     * @example
     * // Count the number of Measurements
     * const count = await prisma.measurement.count({
     *   where: {
     *     // ... the filter for the Measurements we want to count
     *   }
     * })
    **/
    count<T extends MeasurementCountArgs>(
      args?: Subset<T, MeasurementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeasurementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Measurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasurementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeasurementAggregateArgs>(args: Subset<T, MeasurementAggregateArgs>): Prisma.PrismaPromise<GetMeasurementAggregateType<T>>

    /**
     * Group by Measurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasurementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeasurementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeasurementGroupByArgs['orderBy'] }
        : { orderBy?: MeasurementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeasurementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeasurementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Measurement model
   */
  readonly fields: MeasurementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Measurement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeasurementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    baby<T extends BabyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BabyDefaultArgs<ExtArgs>>): Prisma__BabyClient<$Result.GetResult<Prisma.$BabyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Measurement model
   */ 
  interface MeasurementFieldRefs {
    readonly id: FieldRef<"Measurement", 'Int'>
    readonly date: FieldRef<"Measurement", 'DateTime'>
    readonly weight: FieldRef<"Measurement", 'Float'>
    readonly height: FieldRef<"Measurement", 'Float'>
    readonly headCirc: FieldRef<"Measurement", 'Float'>
    readonly notes: FieldRef<"Measurement", 'String'>
    readonly createdAt: FieldRef<"Measurement", 'DateTime'>
    readonly updatedAt: FieldRef<"Measurement", 'DateTime'>
    readonly babyId: FieldRef<"Measurement", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Measurement findUnique
   */
  export type MeasurementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Measurement
     */
    select?: MeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeasurementInclude<ExtArgs> | null
    /**
     * Filter, which Measurement to fetch.
     */
    where: MeasurementWhereUniqueInput
  }


  /**
   * Measurement findUniqueOrThrow
   */
  export type MeasurementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Measurement
     */
    select?: MeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeasurementInclude<ExtArgs> | null
    /**
     * Filter, which Measurement to fetch.
     */
    where: MeasurementWhereUniqueInput
  }


  /**
   * Measurement findFirst
   */
  export type MeasurementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Measurement
     */
    select?: MeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeasurementInclude<ExtArgs> | null
    /**
     * Filter, which Measurement to fetch.
     */
    where?: MeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Measurements to fetch.
     */
    orderBy?: MeasurementOrderByWithRelationInput | MeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Measurements.
     */
    cursor?: MeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Measurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Measurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Measurements.
     */
    distinct?: MeasurementScalarFieldEnum | MeasurementScalarFieldEnum[]
  }


  /**
   * Measurement findFirstOrThrow
   */
  export type MeasurementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Measurement
     */
    select?: MeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeasurementInclude<ExtArgs> | null
    /**
     * Filter, which Measurement to fetch.
     */
    where?: MeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Measurements to fetch.
     */
    orderBy?: MeasurementOrderByWithRelationInput | MeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Measurements.
     */
    cursor?: MeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Measurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Measurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Measurements.
     */
    distinct?: MeasurementScalarFieldEnum | MeasurementScalarFieldEnum[]
  }


  /**
   * Measurement findMany
   */
  export type MeasurementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Measurement
     */
    select?: MeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeasurementInclude<ExtArgs> | null
    /**
     * Filter, which Measurements to fetch.
     */
    where?: MeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Measurements to fetch.
     */
    orderBy?: MeasurementOrderByWithRelationInput | MeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Measurements.
     */
    cursor?: MeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Measurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Measurements.
     */
    skip?: number
    distinct?: MeasurementScalarFieldEnum | MeasurementScalarFieldEnum[]
  }


  /**
   * Measurement create
   */
  export type MeasurementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Measurement
     */
    select?: MeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeasurementInclude<ExtArgs> | null
    /**
     * The data needed to create a Measurement.
     */
    data: XOR<MeasurementCreateInput, MeasurementUncheckedCreateInput>
  }


  /**
   * Measurement createMany
   */
  export type MeasurementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Measurements.
     */
    data: MeasurementCreateManyInput | MeasurementCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Measurement update
   */
  export type MeasurementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Measurement
     */
    select?: MeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeasurementInclude<ExtArgs> | null
    /**
     * The data needed to update a Measurement.
     */
    data: XOR<MeasurementUpdateInput, MeasurementUncheckedUpdateInput>
    /**
     * Choose, which Measurement to update.
     */
    where: MeasurementWhereUniqueInput
  }


  /**
   * Measurement updateMany
   */
  export type MeasurementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Measurements.
     */
    data: XOR<MeasurementUpdateManyMutationInput, MeasurementUncheckedUpdateManyInput>
    /**
     * Filter which Measurements to update
     */
    where?: MeasurementWhereInput
  }


  /**
   * Measurement upsert
   */
  export type MeasurementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Measurement
     */
    select?: MeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeasurementInclude<ExtArgs> | null
    /**
     * The filter to search for the Measurement to update in case it exists.
     */
    where: MeasurementWhereUniqueInput
    /**
     * In case the Measurement found by the `where` argument doesn't exist, create a new Measurement with this data.
     */
    create: XOR<MeasurementCreateInput, MeasurementUncheckedCreateInput>
    /**
     * In case the Measurement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeasurementUpdateInput, MeasurementUncheckedUpdateInput>
  }


  /**
   * Measurement delete
   */
  export type MeasurementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Measurement
     */
    select?: MeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeasurementInclude<ExtArgs> | null
    /**
     * Filter which Measurement to delete.
     */
    where: MeasurementWhereUniqueInput
  }


  /**
   * Measurement deleteMany
   */
  export type MeasurementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Measurements to delete
     */
    where?: MeasurementWhereInput
  }


  /**
   * Measurement without action
   */
  export type MeasurementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Measurement
     */
    select?: MeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeasurementInclude<ExtArgs> | null
  }



  /**
   * Model Album
   */

  export type AggregateAlbum = {
    _count: AlbumCountAggregateOutputType | null
    _avg: AlbumAvgAggregateOutputType | null
    _sum: AlbumSumAggregateOutputType | null
    _min: AlbumMinAggregateOutputType | null
    _max: AlbumMaxAggregateOutputType | null
  }

  export type AlbumAvgAggregateOutputType = {
    id: number | null
    babyId: number | null
  }

  export type AlbumSumAggregateOutputType = {
    id: number | null
    babyId: number | null
  }

  export type AlbumMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    babyId: number | null
  }

  export type AlbumMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    babyId: number | null
  }

  export type AlbumCountAggregateOutputType = {
    id: number
    title: number
    description: number
    createdAt: number
    updatedAt: number
    babyId: number
    _all: number
  }


  export type AlbumAvgAggregateInputType = {
    id?: true
    babyId?: true
  }

  export type AlbumSumAggregateInputType = {
    id?: true
    babyId?: true
  }

  export type AlbumMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
  }

  export type AlbumMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
  }

  export type AlbumCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    babyId?: true
    _all?: true
  }

  export type AlbumAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Album to aggregate.
     */
    where?: AlbumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Albums to fetch.
     */
    orderBy?: AlbumOrderByWithRelationInput | AlbumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlbumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Albums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Albums
    **/
    _count?: true | AlbumCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlbumAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlbumSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlbumMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlbumMaxAggregateInputType
  }

  export type GetAlbumAggregateType<T extends AlbumAggregateArgs> = {
        [P in keyof T & keyof AggregateAlbum]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlbum[P]>
      : GetScalarType<T[P], AggregateAlbum[P]>
  }




  export type AlbumGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlbumWhereInput
    orderBy?: AlbumOrderByWithAggregationInput | AlbumOrderByWithAggregationInput[]
    by: AlbumScalarFieldEnum[] | AlbumScalarFieldEnum
    having?: AlbumScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlbumCountAggregateInputType | true
    _avg?: AlbumAvgAggregateInputType
    _sum?: AlbumSumAggregateInputType
    _min?: AlbumMinAggregateInputType
    _max?: AlbumMaxAggregateInputType
  }

  export type AlbumGroupByOutputType = {
    id: number
    title: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    babyId: number
    _count: AlbumCountAggregateOutputType | null
    _avg: AlbumAvgAggregateOutputType | null
    _sum: AlbumSumAggregateOutputType | null
    _min: AlbumMinAggregateOutputType | null
    _max: AlbumMaxAggregateOutputType | null
  }

  type GetAlbumGroupByPayload<T extends AlbumGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlbumGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlbumGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlbumGroupByOutputType[P]>
            : GetScalarType<T[P], AlbumGroupByOutputType[P]>
        }
      >
    >


  export type AlbumSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    babyId?: boolean
    baby?: boolean | BabyDefaultArgs<ExtArgs>
    photos?: boolean | Album$photosArgs<ExtArgs>
    access?: boolean | Album$accessArgs<ExtArgs>
    _count?: boolean | AlbumCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["album"]>

  export type AlbumSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    babyId?: boolean
  }

  export type AlbumInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    baby?: boolean | BabyDefaultArgs<ExtArgs>
    photos?: boolean | Album$photosArgs<ExtArgs>
    access?: boolean | Album$accessArgs<ExtArgs>
    _count?: boolean | AlbumCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AlbumPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Album"
    objects: {
      baby: Prisma.$BabyPayload<ExtArgs>
      photos: Prisma.$AlbumPhotoPayload<ExtArgs>[]
      access: Prisma.$AlbumAccessPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      babyId: number
    }, ExtArgs["result"]["album"]>
    composites: {}
  }


  type AlbumGetPayload<S extends boolean | null | undefined | AlbumDefaultArgs> = $Result.GetResult<Prisma.$AlbumPayload, S>

  type AlbumCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlbumFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlbumCountAggregateInputType | true
    }

  export interface AlbumDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Album'], meta: { name: 'Album' } }
    /**
     * Find zero or one Album that matches the filter.
     * @param {AlbumFindUniqueArgs} args - Arguments to find a Album
     * @example
     * // Get one Album
     * const album = await prisma.album.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AlbumFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AlbumFindUniqueArgs<ExtArgs>>
    ): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Album that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AlbumFindUniqueOrThrowArgs} args - Arguments to find a Album
     * @example
     * // Get one Album
     * const album = await prisma.album.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AlbumFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AlbumFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Album that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumFindFirstArgs} args - Arguments to find a Album
     * @example
     * // Get one Album
     * const album = await prisma.album.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AlbumFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AlbumFindFirstArgs<ExtArgs>>
    ): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Album that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumFindFirstOrThrowArgs} args - Arguments to find a Album
     * @example
     * // Get one Album
     * const album = await prisma.album.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AlbumFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AlbumFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Albums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Albums
     * const albums = await prisma.album.findMany()
     * 
     * // Get first 10 Albums
     * const albums = await prisma.album.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const albumWithIdOnly = await prisma.album.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AlbumFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AlbumFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Album.
     * @param {AlbumCreateArgs} args - Arguments to create a Album.
     * @example
     * // Create one Album
     * const Album = await prisma.album.create({
     *   data: {
     *     // ... data to create a Album
     *   }
     * })
     * 
    **/
    create<T extends AlbumCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AlbumCreateArgs<ExtArgs>>
    ): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Albums.
     *     @param {AlbumCreateManyArgs} args - Arguments to create many Albums.
     *     @example
     *     // Create many Albums
     *     const album = await prisma.album.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AlbumCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AlbumCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Album.
     * @param {AlbumDeleteArgs} args - Arguments to delete one Album.
     * @example
     * // Delete one Album
     * const Album = await prisma.album.delete({
     *   where: {
     *     // ... filter to delete one Album
     *   }
     * })
     * 
    **/
    delete<T extends AlbumDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AlbumDeleteArgs<ExtArgs>>
    ): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Album.
     * @param {AlbumUpdateArgs} args - Arguments to update one Album.
     * @example
     * // Update one Album
     * const album = await prisma.album.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AlbumUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AlbumUpdateArgs<ExtArgs>>
    ): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Albums.
     * @param {AlbumDeleteManyArgs} args - Arguments to filter Albums to delete.
     * @example
     * // Delete a few Albums
     * const { count } = await prisma.album.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AlbumDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AlbumDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Albums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Albums
     * const album = await prisma.album.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AlbumUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AlbumUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Album.
     * @param {AlbumUpsertArgs} args - Arguments to update or create a Album.
     * @example
     * // Update or create a Album
     * const album = await prisma.album.upsert({
     *   create: {
     *     // ... data to create a Album
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Album we want to update
     *   }
     * })
    **/
    upsert<T extends AlbumUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AlbumUpsertArgs<ExtArgs>>
    ): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Albums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumCountArgs} args - Arguments to filter Albums to count.
     * @example
     * // Count the number of Albums
     * const count = await prisma.album.count({
     *   where: {
     *     // ... the filter for the Albums we want to count
     *   }
     * })
    **/
    count<T extends AlbumCountArgs>(
      args?: Subset<T, AlbumCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlbumCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Album.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlbumAggregateArgs>(args: Subset<T, AlbumAggregateArgs>): Prisma.PrismaPromise<GetAlbumAggregateType<T>>

    /**
     * Group by Album.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlbumGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlbumGroupByArgs['orderBy'] }
        : { orderBy?: AlbumGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlbumGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlbumGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Album model
   */
  readonly fields: AlbumFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Album.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlbumClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    baby<T extends BabyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BabyDefaultArgs<ExtArgs>>): Prisma__BabyClient<$Result.GetResult<Prisma.$BabyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    photos<T extends Album$photosArgs<ExtArgs> = {}>(args?: Subset<T, Album$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlbumPhotoPayload<ExtArgs>, T, 'findMany'> | Null>;

    access<T extends Album$accessArgs<ExtArgs> = {}>(args?: Subset<T, Album$accessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlbumAccessPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Album model
   */ 
  interface AlbumFieldRefs {
    readonly id: FieldRef<"Album", 'Int'>
    readonly title: FieldRef<"Album", 'String'>
    readonly description: FieldRef<"Album", 'String'>
    readonly createdAt: FieldRef<"Album", 'DateTime'>
    readonly updatedAt: FieldRef<"Album", 'DateTime'>
    readonly babyId: FieldRef<"Album", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Album findUnique
   */
  export type AlbumFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * Filter, which Album to fetch.
     */
    where: AlbumWhereUniqueInput
  }


  /**
   * Album findUniqueOrThrow
   */
  export type AlbumFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * Filter, which Album to fetch.
     */
    where: AlbumWhereUniqueInput
  }


  /**
   * Album findFirst
   */
  export type AlbumFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * Filter, which Album to fetch.
     */
    where?: AlbumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Albums to fetch.
     */
    orderBy?: AlbumOrderByWithRelationInput | AlbumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Albums.
     */
    cursor?: AlbumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Albums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Albums.
     */
    distinct?: AlbumScalarFieldEnum | AlbumScalarFieldEnum[]
  }


  /**
   * Album findFirstOrThrow
   */
  export type AlbumFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * Filter, which Album to fetch.
     */
    where?: AlbumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Albums to fetch.
     */
    orderBy?: AlbumOrderByWithRelationInput | AlbumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Albums.
     */
    cursor?: AlbumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Albums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Albums.
     */
    distinct?: AlbumScalarFieldEnum | AlbumScalarFieldEnum[]
  }


  /**
   * Album findMany
   */
  export type AlbumFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * Filter, which Albums to fetch.
     */
    where?: AlbumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Albums to fetch.
     */
    orderBy?: AlbumOrderByWithRelationInput | AlbumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Albums.
     */
    cursor?: AlbumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Albums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Albums.
     */
    skip?: number
    distinct?: AlbumScalarFieldEnum | AlbumScalarFieldEnum[]
  }


  /**
   * Album create
   */
  export type AlbumCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * The data needed to create a Album.
     */
    data: XOR<AlbumCreateInput, AlbumUncheckedCreateInput>
  }


  /**
   * Album createMany
   */
  export type AlbumCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Albums.
     */
    data: AlbumCreateManyInput | AlbumCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Album update
   */
  export type AlbumUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * The data needed to update a Album.
     */
    data: XOR<AlbumUpdateInput, AlbumUncheckedUpdateInput>
    /**
     * Choose, which Album to update.
     */
    where: AlbumWhereUniqueInput
  }


  /**
   * Album updateMany
   */
  export type AlbumUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Albums.
     */
    data: XOR<AlbumUpdateManyMutationInput, AlbumUncheckedUpdateManyInput>
    /**
     * Filter which Albums to update
     */
    where?: AlbumWhereInput
  }


  /**
   * Album upsert
   */
  export type AlbumUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * The filter to search for the Album to update in case it exists.
     */
    where: AlbumWhereUniqueInput
    /**
     * In case the Album found by the `where` argument doesn't exist, create a new Album with this data.
     */
    create: XOR<AlbumCreateInput, AlbumUncheckedCreateInput>
    /**
     * In case the Album was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlbumUpdateInput, AlbumUncheckedUpdateInput>
  }


  /**
   * Album delete
   */
  export type AlbumDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumInclude<ExtArgs> | null
    /**
     * Filter which Album to delete.
     */
    where: AlbumWhereUniqueInput
  }


  /**
   * Album deleteMany
   */
  export type AlbumDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Albums to delete
     */
    where?: AlbumWhereInput
  }


  /**
   * Album.photos
   */
  export type Album$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumPhoto
     */
    select?: AlbumPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumPhotoInclude<ExtArgs> | null
    where?: AlbumPhotoWhereInput
    orderBy?: AlbumPhotoOrderByWithRelationInput | AlbumPhotoOrderByWithRelationInput[]
    cursor?: AlbumPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlbumPhotoScalarFieldEnum | AlbumPhotoScalarFieldEnum[]
  }


  /**
   * Album.access
   */
  export type Album$accessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumAccess
     */
    select?: AlbumAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumAccessInclude<ExtArgs> | null
    where?: AlbumAccessWhereInput
    orderBy?: AlbumAccessOrderByWithRelationInput | AlbumAccessOrderByWithRelationInput[]
    cursor?: AlbumAccessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlbumAccessScalarFieldEnum | AlbumAccessScalarFieldEnum[]
  }


  /**
   * Album without action
   */
  export type AlbumDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Album
     */
    select?: AlbumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumInclude<ExtArgs> | null
  }



  /**
   * Model Photo
   */

  export type AggregatePhoto = {
    _count: PhotoCountAggregateOutputType | null
    _avg: PhotoAvgAggregateOutputType | null
    _sum: PhotoSumAggregateOutputType | null
    _min: PhotoMinAggregateOutputType | null
    _max: PhotoMaxAggregateOutputType | null
  }

  export type PhotoAvgAggregateOutputType = {
    id: number | null
  }

  export type PhotoSumAggregateOutputType = {
    id: number | null
  }

  export type PhotoMinAggregateOutputType = {
    id: number | null
    url: string | null
    caption: string | null
    timestamp: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PhotoMaxAggregateOutputType = {
    id: number | null
    url: string | null
    caption: string | null
    timestamp: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PhotoCountAggregateOutputType = {
    id: number
    url: number
    caption: number
    timestamp: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PhotoAvgAggregateInputType = {
    id?: true
  }

  export type PhotoSumAggregateInputType = {
    id?: true
  }

  export type PhotoMinAggregateInputType = {
    id?: true
    url?: true
    caption?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PhotoMaxAggregateInputType = {
    id?: true
    url?: true
    caption?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PhotoCountAggregateInputType = {
    id?: true
    url?: true
    caption?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Photo to aggregate.
     */
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     */
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Photos
    **/
    _count?: true | PhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PhotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PhotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhotoMaxAggregateInputType
  }

  export type GetPhotoAggregateType<T extends PhotoAggregateArgs> = {
        [P in keyof T & keyof AggregatePhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhoto[P]>
      : GetScalarType<T[P], AggregatePhoto[P]>
  }




  export type PhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhotoWhereInput
    orderBy?: PhotoOrderByWithAggregationInput | PhotoOrderByWithAggregationInput[]
    by: PhotoScalarFieldEnum[] | PhotoScalarFieldEnum
    having?: PhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhotoCountAggregateInputType | true
    _avg?: PhotoAvgAggregateInputType
    _sum?: PhotoSumAggregateInputType
    _min?: PhotoMinAggregateInputType
    _max?: PhotoMaxAggregateInputType
  }

  export type PhotoGroupByOutputType = {
    id: number
    url: string
    caption: string | null
    timestamp: Date
    createdAt: Date
    updatedAt: Date
    _count: PhotoCountAggregateOutputType | null
    _avg: PhotoAvgAggregateOutputType | null
    _sum: PhotoSumAggregateOutputType | null
    _min: PhotoMinAggregateOutputType | null
    _max: PhotoMaxAggregateOutputType | null
  }

  type GetPhotoGroupByPayload<T extends PhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhotoGroupByOutputType[P]>
            : GetScalarType<T[P], PhotoGroupByOutputType[P]>
        }
      >
    >


  export type PhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    caption?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    babyPhotos?: boolean | Photo$babyPhotosArgs<ExtArgs>
    albumPhotos?: boolean | Photo$albumPhotosArgs<ExtArgs>
    activityPhotos?: boolean | Photo$activityPhotosArgs<ExtArgs>
    milestonePhotos?: boolean | Photo$milestonePhotosArgs<ExtArgs>
    _count?: boolean | PhotoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photo"]>

  export type PhotoSelectScalar = {
    id?: boolean
    url?: boolean
    caption?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    babyPhotos?: boolean | Photo$babyPhotosArgs<ExtArgs>
    albumPhotos?: boolean | Photo$albumPhotosArgs<ExtArgs>
    activityPhotos?: boolean | Photo$activityPhotosArgs<ExtArgs>
    milestonePhotos?: boolean | Photo$milestonePhotosArgs<ExtArgs>
    _count?: boolean | PhotoCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Photo"
    objects: {
      babyPhotos: Prisma.$BabyPhotoPayload<ExtArgs>[]
      albumPhotos: Prisma.$AlbumPhotoPayload<ExtArgs>[]
      activityPhotos: Prisma.$ActivityPhotoPayload<ExtArgs>[]
      milestonePhotos: Prisma.$MilestonePhotoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      url: string
      caption: string | null
      timestamp: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["photo"]>
    composites: {}
  }


  type PhotoGetPayload<S extends boolean | null | undefined | PhotoDefaultArgs> = $Result.GetResult<Prisma.$PhotoPayload, S>

  type PhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PhotoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PhotoCountAggregateInputType | true
    }

  export interface PhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Photo'], meta: { name: 'Photo' } }
    /**
     * Find zero or one Photo that matches the filter.
     * @param {PhotoFindUniqueArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PhotoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PhotoFindUniqueArgs<ExtArgs>>
    ): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Photo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PhotoFindUniqueOrThrowArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PhotoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PhotoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Photo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoFindFirstArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PhotoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PhotoFindFirstArgs<ExtArgs>>
    ): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Photo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoFindFirstOrThrowArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PhotoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PhotoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Photos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Photos
     * const photos = await prisma.photo.findMany()
     * 
     * // Get first 10 Photos
     * const photos = await prisma.photo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const photoWithIdOnly = await prisma.photo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PhotoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PhotoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Photo.
     * @param {PhotoCreateArgs} args - Arguments to create a Photo.
     * @example
     * // Create one Photo
     * const Photo = await prisma.photo.create({
     *   data: {
     *     // ... data to create a Photo
     *   }
     * })
     * 
    **/
    create<T extends PhotoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PhotoCreateArgs<ExtArgs>>
    ): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Photos.
     *     @param {PhotoCreateManyArgs} args - Arguments to create many Photos.
     *     @example
     *     // Create many Photos
     *     const photo = await prisma.photo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PhotoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PhotoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Photo.
     * @param {PhotoDeleteArgs} args - Arguments to delete one Photo.
     * @example
     * // Delete one Photo
     * const Photo = await prisma.photo.delete({
     *   where: {
     *     // ... filter to delete one Photo
     *   }
     * })
     * 
    **/
    delete<T extends PhotoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PhotoDeleteArgs<ExtArgs>>
    ): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Photo.
     * @param {PhotoUpdateArgs} args - Arguments to update one Photo.
     * @example
     * // Update one Photo
     * const photo = await prisma.photo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PhotoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PhotoUpdateArgs<ExtArgs>>
    ): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Photos.
     * @param {PhotoDeleteManyArgs} args - Arguments to filter Photos to delete.
     * @example
     * // Delete a few Photos
     * const { count } = await prisma.photo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PhotoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PhotoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Photos
     * const photo = await prisma.photo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PhotoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PhotoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Photo.
     * @param {PhotoUpsertArgs} args - Arguments to update or create a Photo.
     * @example
     * // Update or create a Photo
     * const photo = await prisma.photo.upsert({
     *   create: {
     *     // ... data to create a Photo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Photo we want to update
     *   }
     * })
    **/
    upsert<T extends PhotoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PhotoUpsertArgs<ExtArgs>>
    ): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoCountArgs} args - Arguments to filter Photos to count.
     * @example
     * // Count the number of Photos
     * const count = await prisma.photo.count({
     *   where: {
     *     // ... the filter for the Photos we want to count
     *   }
     * })
    **/
    count<T extends PhotoCountArgs>(
      args?: Subset<T, PhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Photo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhotoAggregateArgs>(args: Subset<T, PhotoAggregateArgs>): Prisma.PrismaPromise<GetPhotoAggregateType<T>>

    /**
     * Group by Photo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhotoGroupByArgs['orderBy'] }
        : { orderBy?: PhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Photo model
   */
  readonly fields: PhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Photo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    babyPhotos<T extends Photo$babyPhotosArgs<ExtArgs> = {}>(args?: Subset<T, Photo$babyPhotosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BabyPhotoPayload<ExtArgs>, T, 'findMany'> | Null>;

    albumPhotos<T extends Photo$albumPhotosArgs<ExtArgs> = {}>(args?: Subset<T, Photo$albumPhotosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlbumPhotoPayload<ExtArgs>, T, 'findMany'> | Null>;

    activityPhotos<T extends Photo$activityPhotosArgs<ExtArgs> = {}>(args?: Subset<T, Photo$activityPhotosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPhotoPayload<ExtArgs>, T, 'findMany'> | Null>;

    milestonePhotos<T extends Photo$milestonePhotosArgs<ExtArgs> = {}>(args?: Subset<T, Photo$milestonePhotosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePhotoPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Photo model
   */ 
  interface PhotoFieldRefs {
    readonly id: FieldRef<"Photo", 'Int'>
    readonly url: FieldRef<"Photo", 'String'>
    readonly caption: FieldRef<"Photo", 'String'>
    readonly timestamp: FieldRef<"Photo", 'DateTime'>
    readonly createdAt: FieldRef<"Photo", 'DateTime'>
    readonly updatedAt: FieldRef<"Photo", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Photo findUnique
   */
  export type PhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photo to fetch.
     */
    where: PhotoWhereUniqueInput
  }


  /**
   * Photo findUniqueOrThrow
   */
  export type PhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photo to fetch.
     */
    where: PhotoWhereUniqueInput
  }


  /**
   * Photo findFirst
   */
  export type PhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photo to fetch.
     */
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     */
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Photos.
     */
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Photos.
     */
    distinct?: PhotoScalarFieldEnum | PhotoScalarFieldEnum[]
  }


  /**
   * Photo findFirstOrThrow
   */
  export type PhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photo to fetch.
     */
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     */
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Photos.
     */
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Photos.
     */
    distinct?: PhotoScalarFieldEnum | PhotoScalarFieldEnum[]
  }


  /**
   * Photo findMany
   */
  export type PhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photos to fetch.
     */
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     */
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Photos.
     */
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     */
    skip?: number
    distinct?: PhotoScalarFieldEnum | PhotoScalarFieldEnum[]
  }


  /**
   * Photo create
   */
  export type PhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a Photo.
     */
    data: XOR<PhotoCreateInput, PhotoUncheckedCreateInput>
  }


  /**
   * Photo createMany
   */
  export type PhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Photos.
     */
    data: PhotoCreateManyInput | PhotoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Photo update
   */
  export type PhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a Photo.
     */
    data: XOR<PhotoUpdateInput, PhotoUncheckedUpdateInput>
    /**
     * Choose, which Photo to update.
     */
    where: PhotoWhereUniqueInput
  }


  /**
   * Photo updateMany
   */
  export type PhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Photos.
     */
    data: XOR<PhotoUpdateManyMutationInput, PhotoUncheckedUpdateManyInput>
    /**
     * Filter which Photos to update
     */
    where?: PhotoWhereInput
  }


  /**
   * Photo upsert
   */
  export type PhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the Photo to update in case it exists.
     */
    where: PhotoWhereUniqueInput
    /**
     * In case the Photo found by the `where` argument doesn't exist, create a new Photo with this data.
     */
    create: XOR<PhotoCreateInput, PhotoUncheckedCreateInput>
    /**
     * In case the Photo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhotoUpdateInput, PhotoUncheckedUpdateInput>
  }


  /**
   * Photo delete
   */
  export type PhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter which Photo to delete.
     */
    where: PhotoWhereUniqueInput
  }


  /**
   * Photo deleteMany
   */
  export type PhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Photos to delete
     */
    where?: PhotoWhereInput
  }


  /**
   * Photo.babyPhotos
   */
  export type Photo$babyPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BabyPhoto
     */
    select?: BabyPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyPhotoInclude<ExtArgs> | null
    where?: BabyPhotoWhereInput
    orderBy?: BabyPhotoOrderByWithRelationInput | BabyPhotoOrderByWithRelationInput[]
    cursor?: BabyPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BabyPhotoScalarFieldEnum | BabyPhotoScalarFieldEnum[]
  }


  /**
   * Photo.albumPhotos
   */
  export type Photo$albumPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumPhoto
     */
    select?: AlbumPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumPhotoInclude<ExtArgs> | null
    where?: AlbumPhotoWhereInput
    orderBy?: AlbumPhotoOrderByWithRelationInput | AlbumPhotoOrderByWithRelationInput[]
    cursor?: AlbumPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlbumPhotoScalarFieldEnum | AlbumPhotoScalarFieldEnum[]
  }


  /**
   * Photo.activityPhotos
   */
  export type Photo$activityPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityPhoto
     */
    select?: ActivityPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityPhotoInclude<ExtArgs> | null
    where?: ActivityPhotoWhereInput
    orderBy?: ActivityPhotoOrderByWithRelationInput | ActivityPhotoOrderByWithRelationInput[]
    cursor?: ActivityPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityPhotoScalarFieldEnum | ActivityPhotoScalarFieldEnum[]
  }


  /**
   * Photo.milestonePhotos
   */
  export type Photo$milestonePhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilestonePhoto
     */
    select?: MilestonePhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestonePhotoInclude<ExtArgs> | null
    where?: MilestonePhotoWhereInput
    orderBy?: MilestonePhotoOrderByWithRelationInput | MilestonePhotoOrderByWithRelationInput[]
    cursor?: MilestonePhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MilestonePhotoScalarFieldEnum | MilestonePhotoScalarFieldEnum[]
  }


  /**
   * Photo without action
   */
  export type PhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoInclude<ExtArgs> | null
  }



  /**
   * Model BabyPhoto
   */

  export type AggregateBabyPhoto = {
    _count: BabyPhotoCountAggregateOutputType | null
    _avg: BabyPhotoAvgAggregateOutputType | null
    _sum: BabyPhotoSumAggregateOutputType | null
    _min: BabyPhotoMinAggregateOutputType | null
    _max: BabyPhotoMaxAggregateOutputType | null
  }

  export type BabyPhotoAvgAggregateOutputType = {
    babyId: number | null
    photoId: number | null
  }

  export type BabyPhotoSumAggregateOutputType = {
    babyId: number | null
    photoId: number | null
  }

  export type BabyPhotoMinAggregateOutputType = {
    babyId: number | null
    photoId: number | null
    createdAt: Date | null
  }

  export type BabyPhotoMaxAggregateOutputType = {
    babyId: number | null
    photoId: number | null
    createdAt: Date | null
  }

  export type BabyPhotoCountAggregateOutputType = {
    babyId: number
    photoId: number
    createdAt: number
    _all: number
  }


  export type BabyPhotoAvgAggregateInputType = {
    babyId?: true
    photoId?: true
  }

  export type BabyPhotoSumAggregateInputType = {
    babyId?: true
    photoId?: true
  }

  export type BabyPhotoMinAggregateInputType = {
    babyId?: true
    photoId?: true
    createdAt?: true
  }

  export type BabyPhotoMaxAggregateInputType = {
    babyId?: true
    photoId?: true
    createdAt?: true
  }

  export type BabyPhotoCountAggregateInputType = {
    babyId?: true
    photoId?: true
    createdAt?: true
    _all?: true
  }

  export type BabyPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BabyPhoto to aggregate.
     */
    where?: BabyPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BabyPhotos to fetch.
     */
    orderBy?: BabyPhotoOrderByWithRelationInput | BabyPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BabyPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BabyPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BabyPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BabyPhotos
    **/
    _count?: true | BabyPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BabyPhotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BabyPhotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BabyPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BabyPhotoMaxAggregateInputType
  }

  export type GetBabyPhotoAggregateType<T extends BabyPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateBabyPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBabyPhoto[P]>
      : GetScalarType<T[P], AggregateBabyPhoto[P]>
  }




  export type BabyPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BabyPhotoWhereInput
    orderBy?: BabyPhotoOrderByWithAggregationInput | BabyPhotoOrderByWithAggregationInput[]
    by: BabyPhotoScalarFieldEnum[] | BabyPhotoScalarFieldEnum
    having?: BabyPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BabyPhotoCountAggregateInputType | true
    _avg?: BabyPhotoAvgAggregateInputType
    _sum?: BabyPhotoSumAggregateInputType
    _min?: BabyPhotoMinAggregateInputType
    _max?: BabyPhotoMaxAggregateInputType
  }

  export type BabyPhotoGroupByOutputType = {
    babyId: number
    photoId: number
    createdAt: Date
    _count: BabyPhotoCountAggregateOutputType | null
    _avg: BabyPhotoAvgAggregateOutputType | null
    _sum: BabyPhotoSumAggregateOutputType | null
    _min: BabyPhotoMinAggregateOutputType | null
    _max: BabyPhotoMaxAggregateOutputType | null
  }

  type GetBabyPhotoGroupByPayload<T extends BabyPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BabyPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BabyPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BabyPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], BabyPhotoGroupByOutputType[P]>
        }
      >
    >


  export type BabyPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    babyId?: boolean
    photoId?: boolean
    createdAt?: boolean
    baby?: boolean | BabyDefaultArgs<ExtArgs>
    photo?: boolean | PhotoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["babyPhoto"]>

  export type BabyPhotoSelectScalar = {
    babyId?: boolean
    photoId?: boolean
    createdAt?: boolean
  }

  export type BabyPhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    baby?: boolean | BabyDefaultArgs<ExtArgs>
    photo?: boolean | PhotoDefaultArgs<ExtArgs>
  }


  export type $BabyPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BabyPhoto"
    objects: {
      baby: Prisma.$BabyPayload<ExtArgs>
      photo: Prisma.$PhotoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      babyId: number
      photoId: number
      createdAt: Date
    }, ExtArgs["result"]["babyPhoto"]>
    composites: {}
  }


  type BabyPhotoGetPayload<S extends boolean | null | undefined | BabyPhotoDefaultArgs> = $Result.GetResult<Prisma.$BabyPhotoPayload, S>

  type BabyPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BabyPhotoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BabyPhotoCountAggregateInputType | true
    }

  export interface BabyPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BabyPhoto'], meta: { name: 'BabyPhoto' } }
    /**
     * Find zero or one BabyPhoto that matches the filter.
     * @param {BabyPhotoFindUniqueArgs} args - Arguments to find a BabyPhoto
     * @example
     * // Get one BabyPhoto
     * const babyPhoto = await prisma.babyPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BabyPhotoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BabyPhotoFindUniqueArgs<ExtArgs>>
    ): Prisma__BabyPhotoClient<$Result.GetResult<Prisma.$BabyPhotoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BabyPhoto that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BabyPhotoFindUniqueOrThrowArgs} args - Arguments to find a BabyPhoto
     * @example
     * // Get one BabyPhoto
     * const babyPhoto = await prisma.babyPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BabyPhotoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BabyPhotoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BabyPhotoClient<$Result.GetResult<Prisma.$BabyPhotoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BabyPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BabyPhotoFindFirstArgs} args - Arguments to find a BabyPhoto
     * @example
     * // Get one BabyPhoto
     * const babyPhoto = await prisma.babyPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BabyPhotoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BabyPhotoFindFirstArgs<ExtArgs>>
    ): Prisma__BabyPhotoClient<$Result.GetResult<Prisma.$BabyPhotoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BabyPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BabyPhotoFindFirstOrThrowArgs} args - Arguments to find a BabyPhoto
     * @example
     * // Get one BabyPhoto
     * const babyPhoto = await prisma.babyPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BabyPhotoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BabyPhotoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BabyPhotoClient<$Result.GetResult<Prisma.$BabyPhotoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BabyPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BabyPhotoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BabyPhotos
     * const babyPhotos = await prisma.babyPhoto.findMany()
     * 
     * // Get first 10 BabyPhotos
     * const babyPhotos = await prisma.babyPhoto.findMany({ take: 10 })
     * 
     * // Only select the `babyId`
     * const babyPhotoWithBabyIdOnly = await prisma.babyPhoto.findMany({ select: { babyId: true } })
     * 
    **/
    findMany<T extends BabyPhotoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BabyPhotoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BabyPhotoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BabyPhoto.
     * @param {BabyPhotoCreateArgs} args - Arguments to create a BabyPhoto.
     * @example
     * // Create one BabyPhoto
     * const BabyPhoto = await prisma.babyPhoto.create({
     *   data: {
     *     // ... data to create a BabyPhoto
     *   }
     * })
     * 
    **/
    create<T extends BabyPhotoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BabyPhotoCreateArgs<ExtArgs>>
    ): Prisma__BabyPhotoClient<$Result.GetResult<Prisma.$BabyPhotoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BabyPhotos.
     *     @param {BabyPhotoCreateManyArgs} args - Arguments to create many BabyPhotos.
     *     @example
     *     // Create many BabyPhotos
     *     const babyPhoto = await prisma.babyPhoto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BabyPhotoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BabyPhotoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BabyPhoto.
     * @param {BabyPhotoDeleteArgs} args - Arguments to delete one BabyPhoto.
     * @example
     * // Delete one BabyPhoto
     * const BabyPhoto = await prisma.babyPhoto.delete({
     *   where: {
     *     // ... filter to delete one BabyPhoto
     *   }
     * })
     * 
    **/
    delete<T extends BabyPhotoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BabyPhotoDeleteArgs<ExtArgs>>
    ): Prisma__BabyPhotoClient<$Result.GetResult<Prisma.$BabyPhotoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BabyPhoto.
     * @param {BabyPhotoUpdateArgs} args - Arguments to update one BabyPhoto.
     * @example
     * // Update one BabyPhoto
     * const babyPhoto = await prisma.babyPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BabyPhotoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BabyPhotoUpdateArgs<ExtArgs>>
    ): Prisma__BabyPhotoClient<$Result.GetResult<Prisma.$BabyPhotoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BabyPhotos.
     * @param {BabyPhotoDeleteManyArgs} args - Arguments to filter BabyPhotos to delete.
     * @example
     * // Delete a few BabyPhotos
     * const { count } = await prisma.babyPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BabyPhotoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BabyPhotoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BabyPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BabyPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BabyPhotos
     * const babyPhoto = await prisma.babyPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BabyPhotoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BabyPhotoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BabyPhoto.
     * @param {BabyPhotoUpsertArgs} args - Arguments to update or create a BabyPhoto.
     * @example
     * // Update or create a BabyPhoto
     * const babyPhoto = await prisma.babyPhoto.upsert({
     *   create: {
     *     // ... data to create a BabyPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BabyPhoto we want to update
     *   }
     * })
    **/
    upsert<T extends BabyPhotoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BabyPhotoUpsertArgs<ExtArgs>>
    ): Prisma__BabyPhotoClient<$Result.GetResult<Prisma.$BabyPhotoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BabyPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BabyPhotoCountArgs} args - Arguments to filter BabyPhotos to count.
     * @example
     * // Count the number of BabyPhotos
     * const count = await prisma.babyPhoto.count({
     *   where: {
     *     // ... the filter for the BabyPhotos we want to count
     *   }
     * })
    **/
    count<T extends BabyPhotoCountArgs>(
      args?: Subset<T, BabyPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BabyPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BabyPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BabyPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BabyPhotoAggregateArgs>(args: Subset<T, BabyPhotoAggregateArgs>): Prisma.PrismaPromise<GetBabyPhotoAggregateType<T>>

    /**
     * Group by BabyPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BabyPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BabyPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BabyPhotoGroupByArgs['orderBy'] }
        : { orderBy?: BabyPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BabyPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBabyPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BabyPhoto model
   */
  readonly fields: BabyPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BabyPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BabyPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    baby<T extends BabyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BabyDefaultArgs<ExtArgs>>): Prisma__BabyClient<$Result.GetResult<Prisma.$BabyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    photo<T extends PhotoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PhotoDefaultArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BabyPhoto model
   */ 
  interface BabyPhotoFieldRefs {
    readonly babyId: FieldRef<"BabyPhoto", 'Int'>
    readonly photoId: FieldRef<"BabyPhoto", 'Int'>
    readonly createdAt: FieldRef<"BabyPhoto", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * BabyPhoto findUnique
   */
  export type BabyPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BabyPhoto
     */
    select?: BabyPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyPhotoInclude<ExtArgs> | null
    /**
     * Filter, which BabyPhoto to fetch.
     */
    where: BabyPhotoWhereUniqueInput
  }


  /**
   * BabyPhoto findUniqueOrThrow
   */
  export type BabyPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BabyPhoto
     */
    select?: BabyPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyPhotoInclude<ExtArgs> | null
    /**
     * Filter, which BabyPhoto to fetch.
     */
    where: BabyPhotoWhereUniqueInput
  }


  /**
   * BabyPhoto findFirst
   */
  export type BabyPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BabyPhoto
     */
    select?: BabyPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyPhotoInclude<ExtArgs> | null
    /**
     * Filter, which BabyPhoto to fetch.
     */
    where?: BabyPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BabyPhotos to fetch.
     */
    orderBy?: BabyPhotoOrderByWithRelationInput | BabyPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BabyPhotos.
     */
    cursor?: BabyPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BabyPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BabyPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BabyPhotos.
     */
    distinct?: BabyPhotoScalarFieldEnum | BabyPhotoScalarFieldEnum[]
  }


  /**
   * BabyPhoto findFirstOrThrow
   */
  export type BabyPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BabyPhoto
     */
    select?: BabyPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyPhotoInclude<ExtArgs> | null
    /**
     * Filter, which BabyPhoto to fetch.
     */
    where?: BabyPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BabyPhotos to fetch.
     */
    orderBy?: BabyPhotoOrderByWithRelationInput | BabyPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BabyPhotos.
     */
    cursor?: BabyPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BabyPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BabyPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BabyPhotos.
     */
    distinct?: BabyPhotoScalarFieldEnum | BabyPhotoScalarFieldEnum[]
  }


  /**
   * BabyPhoto findMany
   */
  export type BabyPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BabyPhoto
     */
    select?: BabyPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyPhotoInclude<ExtArgs> | null
    /**
     * Filter, which BabyPhotos to fetch.
     */
    where?: BabyPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BabyPhotos to fetch.
     */
    orderBy?: BabyPhotoOrderByWithRelationInput | BabyPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BabyPhotos.
     */
    cursor?: BabyPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BabyPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BabyPhotos.
     */
    skip?: number
    distinct?: BabyPhotoScalarFieldEnum | BabyPhotoScalarFieldEnum[]
  }


  /**
   * BabyPhoto create
   */
  export type BabyPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BabyPhoto
     */
    select?: BabyPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyPhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a BabyPhoto.
     */
    data: XOR<BabyPhotoCreateInput, BabyPhotoUncheckedCreateInput>
  }


  /**
   * BabyPhoto createMany
   */
  export type BabyPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BabyPhotos.
     */
    data: BabyPhotoCreateManyInput | BabyPhotoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BabyPhoto update
   */
  export type BabyPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BabyPhoto
     */
    select?: BabyPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyPhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a BabyPhoto.
     */
    data: XOR<BabyPhotoUpdateInput, BabyPhotoUncheckedUpdateInput>
    /**
     * Choose, which BabyPhoto to update.
     */
    where: BabyPhotoWhereUniqueInput
  }


  /**
   * BabyPhoto updateMany
   */
  export type BabyPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BabyPhotos.
     */
    data: XOR<BabyPhotoUpdateManyMutationInput, BabyPhotoUncheckedUpdateManyInput>
    /**
     * Filter which BabyPhotos to update
     */
    where?: BabyPhotoWhereInput
  }


  /**
   * BabyPhoto upsert
   */
  export type BabyPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BabyPhoto
     */
    select?: BabyPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyPhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the BabyPhoto to update in case it exists.
     */
    where: BabyPhotoWhereUniqueInput
    /**
     * In case the BabyPhoto found by the `where` argument doesn't exist, create a new BabyPhoto with this data.
     */
    create: XOR<BabyPhotoCreateInput, BabyPhotoUncheckedCreateInput>
    /**
     * In case the BabyPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BabyPhotoUpdateInput, BabyPhotoUncheckedUpdateInput>
  }


  /**
   * BabyPhoto delete
   */
  export type BabyPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BabyPhoto
     */
    select?: BabyPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyPhotoInclude<ExtArgs> | null
    /**
     * Filter which BabyPhoto to delete.
     */
    where: BabyPhotoWhereUniqueInput
  }


  /**
   * BabyPhoto deleteMany
   */
  export type BabyPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BabyPhotos to delete
     */
    where?: BabyPhotoWhereInput
  }


  /**
   * BabyPhoto without action
   */
  export type BabyPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BabyPhoto
     */
    select?: BabyPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BabyPhotoInclude<ExtArgs> | null
  }



  /**
   * Model AlbumPhoto
   */

  export type AggregateAlbumPhoto = {
    _count: AlbumPhotoCountAggregateOutputType | null
    _avg: AlbumPhotoAvgAggregateOutputType | null
    _sum: AlbumPhotoSumAggregateOutputType | null
    _min: AlbumPhotoMinAggregateOutputType | null
    _max: AlbumPhotoMaxAggregateOutputType | null
  }

  export type AlbumPhotoAvgAggregateOutputType = {
    albumId: number | null
    photoId: number | null
  }

  export type AlbumPhotoSumAggregateOutputType = {
    albumId: number | null
    photoId: number | null
  }

  export type AlbumPhotoMinAggregateOutputType = {
    albumId: number | null
    photoId: number | null
    createdAt: Date | null
  }

  export type AlbumPhotoMaxAggregateOutputType = {
    albumId: number | null
    photoId: number | null
    createdAt: Date | null
  }

  export type AlbumPhotoCountAggregateOutputType = {
    albumId: number
    photoId: number
    createdAt: number
    _all: number
  }


  export type AlbumPhotoAvgAggregateInputType = {
    albumId?: true
    photoId?: true
  }

  export type AlbumPhotoSumAggregateInputType = {
    albumId?: true
    photoId?: true
  }

  export type AlbumPhotoMinAggregateInputType = {
    albumId?: true
    photoId?: true
    createdAt?: true
  }

  export type AlbumPhotoMaxAggregateInputType = {
    albumId?: true
    photoId?: true
    createdAt?: true
  }

  export type AlbumPhotoCountAggregateInputType = {
    albumId?: true
    photoId?: true
    createdAt?: true
    _all?: true
  }

  export type AlbumPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlbumPhoto to aggregate.
     */
    where?: AlbumPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlbumPhotos to fetch.
     */
    orderBy?: AlbumPhotoOrderByWithRelationInput | AlbumPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlbumPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlbumPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlbumPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AlbumPhotos
    **/
    _count?: true | AlbumPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlbumPhotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlbumPhotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlbumPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlbumPhotoMaxAggregateInputType
  }

  export type GetAlbumPhotoAggregateType<T extends AlbumPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateAlbumPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlbumPhoto[P]>
      : GetScalarType<T[P], AggregateAlbumPhoto[P]>
  }




  export type AlbumPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlbumPhotoWhereInput
    orderBy?: AlbumPhotoOrderByWithAggregationInput | AlbumPhotoOrderByWithAggregationInput[]
    by: AlbumPhotoScalarFieldEnum[] | AlbumPhotoScalarFieldEnum
    having?: AlbumPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlbumPhotoCountAggregateInputType | true
    _avg?: AlbumPhotoAvgAggregateInputType
    _sum?: AlbumPhotoSumAggregateInputType
    _min?: AlbumPhotoMinAggregateInputType
    _max?: AlbumPhotoMaxAggregateInputType
  }

  export type AlbumPhotoGroupByOutputType = {
    albumId: number
    photoId: number
    createdAt: Date
    _count: AlbumPhotoCountAggregateOutputType | null
    _avg: AlbumPhotoAvgAggregateOutputType | null
    _sum: AlbumPhotoSumAggregateOutputType | null
    _min: AlbumPhotoMinAggregateOutputType | null
    _max: AlbumPhotoMaxAggregateOutputType | null
  }

  type GetAlbumPhotoGroupByPayload<T extends AlbumPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlbumPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlbumPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlbumPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], AlbumPhotoGroupByOutputType[P]>
        }
      >
    >


  export type AlbumPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    albumId?: boolean
    photoId?: boolean
    createdAt?: boolean
    album?: boolean | AlbumDefaultArgs<ExtArgs>
    photo?: boolean | PhotoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["albumPhoto"]>

  export type AlbumPhotoSelectScalar = {
    albumId?: boolean
    photoId?: boolean
    createdAt?: boolean
  }

  export type AlbumPhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    album?: boolean | AlbumDefaultArgs<ExtArgs>
    photo?: boolean | PhotoDefaultArgs<ExtArgs>
  }


  export type $AlbumPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AlbumPhoto"
    objects: {
      album: Prisma.$AlbumPayload<ExtArgs>
      photo: Prisma.$PhotoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      albumId: number
      photoId: number
      createdAt: Date
    }, ExtArgs["result"]["albumPhoto"]>
    composites: {}
  }


  type AlbumPhotoGetPayload<S extends boolean | null | undefined | AlbumPhotoDefaultArgs> = $Result.GetResult<Prisma.$AlbumPhotoPayload, S>

  type AlbumPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlbumPhotoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlbumPhotoCountAggregateInputType | true
    }

  export interface AlbumPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AlbumPhoto'], meta: { name: 'AlbumPhoto' } }
    /**
     * Find zero or one AlbumPhoto that matches the filter.
     * @param {AlbumPhotoFindUniqueArgs} args - Arguments to find a AlbumPhoto
     * @example
     * // Get one AlbumPhoto
     * const albumPhoto = await prisma.albumPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AlbumPhotoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AlbumPhotoFindUniqueArgs<ExtArgs>>
    ): Prisma__AlbumPhotoClient<$Result.GetResult<Prisma.$AlbumPhotoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AlbumPhoto that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AlbumPhotoFindUniqueOrThrowArgs} args - Arguments to find a AlbumPhoto
     * @example
     * // Get one AlbumPhoto
     * const albumPhoto = await prisma.albumPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AlbumPhotoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AlbumPhotoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AlbumPhotoClient<$Result.GetResult<Prisma.$AlbumPhotoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AlbumPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumPhotoFindFirstArgs} args - Arguments to find a AlbumPhoto
     * @example
     * // Get one AlbumPhoto
     * const albumPhoto = await prisma.albumPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AlbumPhotoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AlbumPhotoFindFirstArgs<ExtArgs>>
    ): Prisma__AlbumPhotoClient<$Result.GetResult<Prisma.$AlbumPhotoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AlbumPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumPhotoFindFirstOrThrowArgs} args - Arguments to find a AlbumPhoto
     * @example
     * // Get one AlbumPhoto
     * const albumPhoto = await prisma.albumPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AlbumPhotoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AlbumPhotoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AlbumPhotoClient<$Result.GetResult<Prisma.$AlbumPhotoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AlbumPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumPhotoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlbumPhotos
     * const albumPhotos = await prisma.albumPhoto.findMany()
     * 
     * // Get first 10 AlbumPhotos
     * const albumPhotos = await prisma.albumPhoto.findMany({ take: 10 })
     * 
     * // Only select the `albumId`
     * const albumPhotoWithAlbumIdOnly = await prisma.albumPhoto.findMany({ select: { albumId: true } })
     * 
    **/
    findMany<T extends AlbumPhotoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AlbumPhotoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlbumPhotoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AlbumPhoto.
     * @param {AlbumPhotoCreateArgs} args - Arguments to create a AlbumPhoto.
     * @example
     * // Create one AlbumPhoto
     * const AlbumPhoto = await prisma.albumPhoto.create({
     *   data: {
     *     // ... data to create a AlbumPhoto
     *   }
     * })
     * 
    **/
    create<T extends AlbumPhotoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AlbumPhotoCreateArgs<ExtArgs>>
    ): Prisma__AlbumPhotoClient<$Result.GetResult<Prisma.$AlbumPhotoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AlbumPhotos.
     *     @param {AlbumPhotoCreateManyArgs} args - Arguments to create many AlbumPhotos.
     *     @example
     *     // Create many AlbumPhotos
     *     const albumPhoto = await prisma.albumPhoto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AlbumPhotoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AlbumPhotoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AlbumPhoto.
     * @param {AlbumPhotoDeleteArgs} args - Arguments to delete one AlbumPhoto.
     * @example
     * // Delete one AlbumPhoto
     * const AlbumPhoto = await prisma.albumPhoto.delete({
     *   where: {
     *     // ... filter to delete one AlbumPhoto
     *   }
     * })
     * 
    **/
    delete<T extends AlbumPhotoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AlbumPhotoDeleteArgs<ExtArgs>>
    ): Prisma__AlbumPhotoClient<$Result.GetResult<Prisma.$AlbumPhotoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AlbumPhoto.
     * @param {AlbumPhotoUpdateArgs} args - Arguments to update one AlbumPhoto.
     * @example
     * // Update one AlbumPhoto
     * const albumPhoto = await prisma.albumPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AlbumPhotoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AlbumPhotoUpdateArgs<ExtArgs>>
    ): Prisma__AlbumPhotoClient<$Result.GetResult<Prisma.$AlbumPhotoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AlbumPhotos.
     * @param {AlbumPhotoDeleteManyArgs} args - Arguments to filter AlbumPhotos to delete.
     * @example
     * // Delete a few AlbumPhotos
     * const { count } = await prisma.albumPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AlbumPhotoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AlbumPhotoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlbumPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlbumPhotos
     * const albumPhoto = await prisma.albumPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AlbumPhotoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AlbumPhotoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AlbumPhoto.
     * @param {AlbumPhotoUpsertArgs} args - Arguments to update or create a AlbumPhoto.
     * @example
     * // Update or create a AlbumPhoto
     * const albumPhoto = await prisma.albumPhoto.upsert({
     *   create: {
     *     // ... data to create a AlbumPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlbumPhoto we want to update
     *   }
     * })
    **/
    upsert<T extends AlbumPhotoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AlbumPhotoUpsertArgs<ExtArgs>>
    ): Prisma__AlbumPhotoClient<$Result.GetResult<Prisma.$AlbumPhotoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AlbumPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumPhotoCountArgs} args - Arguments to filter AlbumPhotos to count.
     * @example
     * // Count the number of AlbumPhotos
     * const count = await prisma.albumPhoto.count({
     *   where: {
     *     // ... the filter for the AlbumPhotos we want to count
     *   }
     * })
    **/
    count<T extends AlbumPhotoCountArgs>(
      args?: Subset<T, AlbumPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlbumPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlbumPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlbumPhotoAggregateArgs>(args: Subset<T, AlbumPhotoAggregateArgs>): Prisma.PrismaPromise<GetAlbumPhotoAggregateType<T>>

    /**
     * Group by AlbumPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlbumPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlbumPhotoGroupByArgs['orderBy'] }
        : { orderBy?: AlbumPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlbumPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlbumPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AlbumPhoto model
   */
  readonly fields: AlbumPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AlbumPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlbumPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    album<T extends AlbumDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlbumDefaultArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    photo<T extends PhotoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PhotoDefaultArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AlbumPhoto model
   */ 
  interface AlbumPhotoFieldRefs {
    readonly albumId: FieldRef<"AlbumPhoto", 'Int'>
    readonly photoId: FieldRef<"AlbumPhoto", 'Int'>
    readonly createdAt: FieldRef<"AlbumPhoto", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * AlbumPhoto findUnique
   */
  export type AlbumPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumPhoto
     */
    select?: AlbumPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumPhotoInclude<ExtArgs> | null
    /**
     * Filter, which AlbumPhoto to fetch.
     */
    where: AlbumPhotoWhereUniqueInput
  }


  /**
   * AlbumPhoto findUniqueOrThrow
   */
  export type AlbumPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumPhoto
     */
    select?: AlbumPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumPhotoInclude<ExtArgs> | null
    /**
     * Filter, which AlbumPhoto to fetch.
     */
    where: AlbumPhotoWhereUniqueInput
  }


  /**
   * AlbumPhoto findFirst
   */
  export type AlbumPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumPhoto
     */
    select?: AlbumPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumPhotoInclude<ExtArgs> | null
    /**
     * Filter, which AlbumPhoto to fetch.
     */
    where?: AlbumPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlbumPhotos to fetch.
     */
    orderBy?: AlbumPhotoOrderByWithRelationInput | AlbumPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlbumPhotos.
     */
    cursor?: AlbumPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlbumPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlbumPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlbumPhotos.
     */
    distinct?: AlbumPhotoScalarFieldEnum | AlbumPhotoScalarFieldEnum[]
  }


  /**
   * AlbumPhoto findFirstOrThrow
   */
  export type AlbumPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumPhoto
     */
    select?: AlbumPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumPhotoInclude<ExtArgs> | null
    /**
     * Filter, which AlbumPhoto to fetch.
     */
    where?: AlbumPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlbumPhotos to fetch.
     */
    orderBy?: AlbumPhotoOrderByWithRelationInput | AlbumPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlbumPhotos.
     */
    cursor?: AlbumPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlbumPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlbumPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlbumPhotos.
     */
    distinct?: AlbumPhotoScalarFieldEnum | AlbumPhotoScalarFieldEnum[]
  }


  /**
   * AlbumPhoto findMany
   */
  export type AlbumPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumPhoto
     */
    select?: AlbumPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumPhotoInclude<ExtArgs> | null
    /**
     * Filter, which AlbumPhotos to fetch.
     */
    where?: AlbumPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlbumPhotos to fetch.
     */
    orderBy?: AlbumPhotoOrderByWithRelationInput | AlbumPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AlbumPhotos.
     */
    cursor?: AlbumPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlbumPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlbumPhotos.
     */
    skip?: number
    distinct?: AlbumPhotoScalarFieldEnum | AlbumPhotoScalarFieldEnum[]
  }


  /**
   * AlbumPhoto create
   */
  export type AlbumPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumPhoto
     */
    select?: AlbumPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumPhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a AlbumPhoto.
     */
    data: XOR<AlbumPhotoCreateInput, AlbumPhotoUncheckedCreateInput>
  }


  /**
   * AlbumPhoto createMany
   */
  export type AlbumPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AlbumPhotos.
     */
    data: AlbumPhotoCreateManyInput | AlbumPhotoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AlbumPhoto update
   */
  export type AlbumPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumPhoto
     */
    select?: AlbumPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumPhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a AlbumPhoto.
     */
    data: XOR<AlbumPhotoUpdateInput, AlbumPhotoUncheckedUpdateInput>
    /**
     * Choose, which AlbumPhoto to update.
     */
    where: AlbumPhotoWhereUniqueInput
  }


  /**
   * AlbumPhoto updateMany
   */
  export type AlbumPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AlbumPhotos.
     */
    data: XOR<AlbumPhotoUpdateManyMutationInput, AlbumPhotoUncheckedUpdateManyInput>
    /**
     * Filter which AlbumPhotos to update
     */
    where?: AlbumPhotoWhereInput
  }


  /**
   * AlbumPhoto upsert
   */
  export type AlbumPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumPhoto
     */
    select?: AlbumPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumPhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the AlbumPhoto to update in case it exists.
     */
    where: AlbumPhotoWhereUniqueInput
    /**
     * In case the AlbumPhoto found by the `where` argument doesn't exist, create a new AlbumPhoto with this data.
     */
    create: XOR<AlbumPhotoCreateInput, AlbumPhotoUncheckedCreateInput>
    /**
     * In case the AlbumPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlbumPhotoUpdateInput, AlbumPhotoUncheckedUpdateInput>
  }


  /**
   * AlbumPhoto delete
   */
  export type AlbumPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumPhoto
     */
    select?: AlbumPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumPhotoInclude<ExtArgs> | null
    /**
     * Filter which AlbumPhoto to delete.
     */
    where: AlbumPhotoWhereUniqueInput
  }


  /**
   * AlbumPhoto deleteMany
   */
  export type AlbumPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlbumPhotos to delete
     */
    where?: AlbumPhotoWhereInput
  }


  /**
   * AlbumPhoto without action
   */
  export type AlbumPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumPhoto
     */
    select?: AlbumPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumPhotoInclude<ExtArgs> | null
  }



  /**
   * Model ActivityPhoto
   */

  export type AggregateActivityPhoto = {
    _count: ActivityPhotoCountAggregateOutputType | null
    _avg: ActivityPhotoAvgAggregateOutputType | null
    _sum: ActivityPhotoSumAggregateOutputType | null
    _min: ActivityPhotoMinAggregateOutputType | null
    _max: ActivityPhotoMaxAggregateOutputType | null
  }

  export type ActivityPhotoAvgAggregateOutputType = {
    activityId: number | null
    photoId: number | null
  }

  export type ActivityPhotoSumAggregateOutputType = {
    activityId: number | null
    photoId: number | null
  }

  export type ActivityPhotoMinAggregateOutputType = {
    activityId: number | null
    photoId: number | null
    createdAt: Date | null
  }

  export type ActivityPhotoMaxAggregateOutputType = {
    activityId: number | null
    photoId: number | null
    createdAt: Date | null
  }

  export type ActivityPhotoCountAggregateOutputType = {
    activityId: number
    photoId: number
    createdAt: number
    _all: number
  }


  export type ActivityPhotoAvgAggregateInputType = {
    activityId?: true
    photoId?: true
  }

  export type ActivityPhotoSumAggregateInputType = {
    activityId?: true
    photoId?: true
  }

  export type ActivityPhotoMinAggregateInputType = {
    activityId?: true
    photoId?: true
    createdAt?: true
  }

  export type ActivityPhotoMaxAggregateInputType = {
    activityId?: true
    photoId?: true
    createdAt?: true
  }

  export type ActivityPhotoCountAggregateInputType = {
    activityId?: true
    photoId?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityPhoto to aggregate.
     */
    where?: ActivityPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityPhotos to fetch.
     */
    orderBy?: ActivityPhotoOrderByWithRelationInput | ActivityPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityPhotos
    **/
    _count?: true | ActivityPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityPhotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityPhotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityPhotoMaxAggregateInputType
  }

  export type GetActivityPhotoAggregateType<T extends ActivityPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityPhoto[P]>
      : GetScalarType<T[P], AggregateActivityPhoto[P]>
  }




  export type ActivityPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityPhotoWhereInput
    orderBy?: ActivityPhotoOrderByWithAggregationInput | ActivityPhotoOrderByWithAggregationInput[]
    by: ActivityPhotoScalarFieldEnum[] | ActivityPhotoScalarFieldEnum
    having?: ActivityPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityPhotoCountAggregateInputType | true
    _avg?: ActivityPhotoAvgAggregateInputType
    _sum?: ActivityPhotoSumAggregateInputType
    _min?: ActivityPhotoMinAggregateInputType
    _max?: ActivityPhotoMaxAggregateInputType
  }

  export type ActivityPhotoGroupByOutputType = {
    activityId: number
    photoId: number
    createdAt: Date
    _count: ActivityPhotoCountAggregateOutputType | null
    _avg: ActivityPhotoAvgAggregateOutputType | null
    _sum: ActivityPhotoSumAggregateOutputType | null
    _min: ActivityPhotoMinAggregateOutputType | null
    _max: ActivityPhotoMaxAggregateOutputType | null
  }

  type GetActivityPhotoGroupByPayload<T extends ActivityPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityPhotoGroupByOutputType[P]>
        }
      >
    >


  export type ActivityPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    activityId?: boolean
    photoId?: boolean
    createdAt?: boolean
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    photo?: boolean | PhotoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityPhoto"]>

  export type ActivityPhotoSelectScalar = {
    activityId?: boolean
    photoId?: boolean
    createdAt?: boolean
  }

  export type ActivityPhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    photo?: boolean | PhotoDefaultArgs<ExtArgs>
  }


  export type $ActivityPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityPhoto"
    objects: {
      activity: Prisma.$ActivityPayload<ExtArgs>
      photo: Prisma.$PhotoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      activityId: number
      photoId: number
      createdAt: Date
    }, ExtArgs["result"]["activityPhoto"]>
    composites: {}
  }


  type ActivityPhotoGetPayload<S extends boolean | null | undefined | ActivityPhotoDefaultArgs> = $Result.GetResult<Prisma.$ActivityPhotoPayload, S>

  type ActivityPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActivityPhotoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivityPhotoCountAggregateInputType | true
    }

  export interface ActivityPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityPhoto'], meta: { name: 'ActivityPhoto' } }
    /**
     * Find zero or one ActivityPhoto that matches the filter.
     * @param {ActivityPhotoFindUniqueArgs} args - Arguments to find a ActivityPhoto
     * @example
     * // Get one ActivityPhoto
     * const activityPhoto = await prisma.activityPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ActivityPhotoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ActivityPhotoFindUniqueArgs<ExtArgs>>
    ): Prisma__ActivityPhotoClient<$Result.GetResult<Prisma.$ActivityPhotoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ActivityPhoto that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ActivityPhotoFindUniqueOrThrowArgs} args - Arguments to find a ActivityPhoto
     * @example
     * // Get one ActivityPhoto
     * const activityPhoto = await prisma.activityPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ActivityPhotoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ActivityPhotoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ActivityPhotoClient<$Result.GetResult<Prisma.$ActivityPhotoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ActivityPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityPhotoFindFirstArgs} args - Arguments to find a ActivityPhoto
     * @example
     * // Get one ActivityPhoto
     * const activityPhoto = await prisma.activityPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ActivityPhotoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ActivityPhotoFindFirstArgs<ExtArgs>>
    ): Prisma__ActivityPhotoClient<$Result.GetResult<Prisma.$ActivityPhotoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ActivityPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityPhotoFindFirstOrThrowArgs} args - Arguments to find a ActivityPhoto
     * @example
     * // Get one ActivityPhoto
     * const activityPhoto = await prisma.activityPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ActivityPhotoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ActivityPhotoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ActivityPhotoClient<$Result.GetResult<Prisma.$ActivityPhotoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ActivityPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityPhotoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityPhotos
     * const activityPhotos = await prisma.activityPhoto.findMany()
     * 
     * // Get first 10 ActivityPhotos
     * const activityPhotos = await prisma.activityPhoto.findMany({ take: 10 })
     * 
     * // Only select the `activityId`
     * const activityPhotoWithActivityIdOnly = await prisma.activityPhoto.findMany({ select: { activityId: true } })
     * 
    **/
    findMany<T extends ActivityPhotoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ActivityPhotoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPhotoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ActivityPhoto.
     * @param {ActivityPhotoCreateArgs} args - Arguments to create a ActivityPhoto.
     * @example
     * // Create one ActivityPhoto
     * const ActivityPhoto = await prisma.activityPhoto.create({
     *   data: {
     *     // ... data to create a ActivityPhoto
     *   }
     * })
     * 
    **/
    create<T extends ActivityPhotoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ActivityPhotoCreateArgs<ExtArgs>>
    ): Prisma__ActivityPhotoClient<$Result.GetResult<Prisma.$ActivityPhotoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ActivityPhotos.
     *     @param {ActivityPhotoCreateManyArgs} args - Arguments to create many ActivityPhotos.
     *     @example
     *     // Create many ActivityPhotos
     *     const activityPhoto = await prisma.activityPhoto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ActivityPhotoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ActivityPhotoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ActivityPhoto.
     * @param {ActivityPhotoDeleteArgs} args - Arguments to delete one ActivityPhoto.
     * @example
     * // Delete one ActivityPhoto
     * const ActivityPhoto = await prisma.activityPhoto.delete({
     *   where: {
     *     // ... filter to delete one ActivityPhoto
     *   }
     * })
     * 
    **/
    delete<T extends ActivityPhotoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ActivityPhotoDeleteArgs<ExtArgs>>
    ): Prisma__ActivityPhotoClient<$Result.GetResult<Prisma.$ActivityPhotoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ActivityPhoto.
     * @param {ActivityPhotoUpdateArgs} args - Arguments to update one ActivityPhoto.
     * @example
     * // Update one ActivityPhoto
     * const activityPhoto = await prisma.activityPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ActivityPhotoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ActivityPhotoUpdateArgs<ExtArgs>>
    ): Prisma__ActivityPhotoClient<$Result.GetResult<Prisma.$ActivityPhotoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ActivityPhotos.
     * @param {ActivityPhotoDeleteManyArgs} args - Arguments to filter ActivityPhotos to delete.
     * @example
     * // Delete a few ActivityPhotos
     * const { count } = await prisma.activityPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ActivityPhotoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ActivityPhotoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityPhotos
     * const activityPhoto = await prisma.activityPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ActivityPhotoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ActivityPhotoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActivityPhoto.
     * @param {ActivityPhotoUpsertArgs} args - Arguments to update or create a ActivityPhoto.
     * @example
     * // Update or create a ActivityPhoto
     * const activityPhoto = await prisma.activityPhoto.upsert({
     *   create: {
     *     // ... data to create a ActivityPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityPhoto we want to update
     *   }
     * })
    **/
    upsert<T extends ActivityPhotoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ActivityPhotoUpsertArgs<ExtArgs>>
    ): Prisma__ActivityPhotoClient<$Result.GetResult<Prisma.$ActivityPhotoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ActivityPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityPhotoCountArgs} args - Arguments to filter ActivityPhotos to count.
     * @example
     * // Count the number of ActivityPhotos
     * const count = await prisma.activityPhoto.count({
     *   where: {
     *     // ... the filter for the ActivityPhotos we want to count
     *   }
     * })
    **/
    count<T extends ActivityPhotoCountArgs>(
      args?: Subset<T, ActivityPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityPhotoAggregateArgs>(args: Subset<T, ActivityPhotoAggregateArgs>): Prisma.PrismaPromise<GetActivityPhotoAggregateType<T>>

    /**
     * Group by ActivityPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityPhotoGroupByArgs['orderBy'] }
        : { orderBy?: ActivityPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityPhoto model
   */
  readonly fields: ActivityPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    activity<T extends ActivityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivityDefaultArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    photo<T extends PhotoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PhotoDefaultArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ActivityPhoto model
   */ 
  interface ActivityPhotoFieldRefs {
    readonly activityId: FieldRef<"ActivityPhoto", 'Int'>
    readonly photoId: FieldRef<"ActivityPhoto", 'Int'>
    readonly createdAt: FieldRef<"ActivityPhoto", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ActivityPhoto findUnique
   */
  export type ActivityPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityPhoto
     */
    select?: ActivityPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ActivityPhoto to fetch.
     */
    where: ActivityPhotoWhereUniqueInput
  }


  /**
   * ActivityPhoto findUniqueOrThrow
   */
  export type ActivityPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityPhoto
     */
    select?: ActivityPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ActivityPhoto to fetch.
     */
    where: ActivityPhotoWhereUniqueInput
  }


  /**
   * ActivityPhoto findFirst
   */
  export type ActivityPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityPhoto
     */
    select?: ActivityPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ActivityPhoto to fetch.
     */
    where?: ActivityPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityPhotos to fetch.
     */
    orderBy?: ActivityPhotoOrderByWithRelationInput | ActivityPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityPhotos.
     */
    cursor?: ActivityPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityPhotos.
     */
    distinct?: ActivityPhotoScalarFieldEnum | ActivityPhotoScalarFieldEnum[]
  }


  /**
   * ActivityPhoto findFirstOrThrow
   */
  export type ActivityPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityPhoto
     */
    select?: ActivityPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ActivityPhoto to fetch.
     */
    where?: ActivityPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityPhotos to fetch.
     */
    orderBy?: ActivityPhotoOrderByWithRelationInput | ActivityPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityPhotos.
     */
    cursor?: ActivityPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityPhotos.
     */
    distinct?: ActivityPhotoScalarFieldEnum | ActivityPhotoScalarFieldEnum[]
  }


  /**
   * ActivityPhoto findMany
   */
  export type ActivityPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityPhoto
     */
    select?: ActivityPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ActivityPhotos to fetch.
     */
    where?: ActivityPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityPhotos to fetch.
     */
    orderBy?: ActivityPhotoOrderByWithRelationInput | ActivityPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityPhotos.
     */
    cursor?: ActivityPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityPhotos.
     */
    skip?: number
    distinct?: ActivityPhotoScalarFieldEnum | ActivityPhotoScalarFieldEnum[]
  }


  /**
   * ActivityPhoto create
   */
  export type ActivityPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityPhoto
     */
    select?: ActivityPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityPhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityPhoto.
     */
    data: XOR<ActivityPhotoCreateInput, ActivityPhotoUncheckedCreateInput>
  }


  /**
   * ActivityPhoto createMany
   */
  export type ActivityPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityPhotos.
     */
    data: ActivityPhotoCreateManyInput | ActivityPhotoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ActivityPhoto update
   */
  export type ActivityPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityPhoto
     */
    select?: ActivityPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityPhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityPhoto.
     */
    data: XOR<ActivityPhotoUpdateInput, ActivityPhotoUncheckedUpdateInput>
    /**
     * Choose, which ActivityPhoto to update.
     */
    where: ActivityPhotoWhereUniqueInput
  }


  /**
   * ActivityPhoto updateMany
   */
  export type ActivityPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityPhotos.
     */
    data: XOR<ActivityPhotoUpdateManyMutationInput, ActivityPhotoUncheckedUpdateManyInput>
    /**
     * Filter which ActivityPhotos to update
     */
    where?: ActivityPhotoWhereInput
  }


  /**
   * ActivityPhoto upsert
   */
  export type ActivityPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityPhoto
     */
    select?: ActivityPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityPhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityPhoto to update in case it exists.
     */
    where: ActivityPhotoWhereUniqueInput
    /**
     * In case the ActivityPhoto found by the `where` argument doesn't exist, create a new ActivityPhoto with this data.
     */
    create: XOR<ActivityPhotoCreateInput, ActivityPhotoUncheckedCreateInput>
    /**
     * In case the ActivityPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityPhotoUpdateInput, ActivityPhotoUncheckedUpdateInput>
  }


  /**
   * ActivityPhoto delete
   */
  export type ActivityPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityPhoto
     */
    select?: ActivityPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityPhotoInclude<ExtArgs> | null
    /**
     * Filter which ActivityPhoto to delete.
     */
    where: ActivityPhotoWhereUniqueInput
  }


  /**
   * ActivityPhoto deleteMany
   */
  export type ActivityPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityPhotos to delete
     */
    where?: ActivityPhotoWhereInput
  }


  /**
   * ActivityPhoto without action
   */
  export type ActivityPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityPhoto
     */
    select?: ActivityPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityPhotoInclude<ExtArgs> | null
  }



  /**
   * Model MilestonePhoto
   */

  export type AggregateMilestonePhoto = {
    _count: MilestonePhotoCountAggregateOutputType | null
    _avg: MilestonePhotoAvgAggregateOutputType | null
    _sum: MilestonePhotoSumAggregateOutputType | null
    _min: MilestonePhotoMinAggregateOutputType | null
    _max: MilestonePhotoMaxAggregateOutputType | null
  }

  export type MilestonePhotoAvgAggregateOutputType = {
    milestoneId: number | null
    photoId: number | null
  }

  export type MilestonePhotoSumAggregateOutputType = {
    milestoneId: number | null
    photoId: number | null
  }

  export type MilestonePhotoMinAggregateOutputType = {
    milestoneId: number | null
    photoId: number | null
    createdAt: Date | null
  }

  export type MilestonePhotoMaxAggregateOutputType = {
    milestoneId: number | null
    photoId: number | null
    createdAt: Date | null
  }

  export type MilestonePhotoCountAggregateOutputType = {
    milestoneId: number
    photoId: number
    createdAt: number
    _all: number
  }


  export type MilestonePhotoAvgAggregateInputType = {
    milestoneId?: true
    photoId?: true
  }

  export type MilestonePhotoSumAggregateInputType = {
    milestoneId?: true
    photoId?: true
  }

  export type MilestonePhotoMinAggregateInputType = {
    milestoneId?: true
    photoId?: true
    createdAt?: true
  }

  export type MilestonePhotoMaxAggregateInputType = {
    milestoneId?: true
    photoId?: true
    createdAt?: true
  }

  export type MilestonePhotoCountAggregateInputType = {
    milestoneId?: true
    photoId?: true
    createdAt?: true
    _all?: true
  }

  export type MilestonePhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MilestonePhoto to aggregate.
     */
    where?: MilestonePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MilestonePhotos to fetch.
     */
    orderBy?: MilestonePhotoOrderByWithRelationInput | MilestonePhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MilestonePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MilestonePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MilestonePhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MilestonePhotos
    **/
    _count?: true | MilestonePhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MilestonePhotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MilestonePhotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MilestonePhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MilestonePhotoMaxAggregateInputType
  }

  export type GetMilestonePhotoAggregateType<T extends MilestonePhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateMilestonePhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMilestonePhoto[P]>
      : GetScalarType<T[P], AggregateMilestonePhoto[P]>
  }




  export type MilestonePhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestonePhotoWhereInput
    orderBy?: MilestonePhotoOrderByWithAggregationInput | MilestonePhotoOrderByWithAggregationInput[]
    by: MilestonePhotoScalarFieldEnum[] | MilestonePhotoScalarFieldEnum
    having?: MilestonePhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MilestonePhotoCountAggregateInputType | true
    _avg?: MilestonePhotoAvgAggregateInputType
    _sum?: MilestonePhotoSumAggregateInputType
    _min?: MilestonePhotoMinAggregateInputType
    _max?: MilestonePhotoMaxAggregateInputType
  }

  export type MilestonePhotoGroupByOutputType = {
    milestoneId: number
    photoId: number
    createdAt: Date
    _count: MilestonePhotoCountAggregateOutputType | null
    _avg: MilestonePhotoAvgAggregateOutputType | null
    _sum: MilestonePhotoSumAggregateOutputType | null
    _min: MilestonePhotoMinAggregateOutputType | null
    _max: MilestonePhotoMaxAggregateOutputType | null
  }

  type GetMilestonePhotoGroupByPayload<T extends MilestonePhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MilestonePhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MilestonePhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MilestonePhotoGroupByOutputType[P]>
            : GetScalarType<T[P], MilestonePhotoGroupByOutputType[P]>
        }
      >
    >


  export type MilestonePhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    milestoneId?: boolean
    photoId?: boolean
    createdAt?: boolean
    milestone?: boolean | MilestoneDefaultArgs<ExtArgs>
    photo?: boolean | PhotoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestonePhoto"]>

  export type MilestonePhotoSelectScalar = {
    milestoneId?: boolean
    photoId?: boolean
    createdAt?: boolean
  }

  export type MilestonePhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    milestone?: boolean | MilestoneDefaultArgs<ExtArgs>
    photo?: boolean | PhotoDefaultArgs<ExtArgs>
  }


  export type $MilestonePhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MilestonePhoto"
    objects: {
      milestone: Prisma.$MilestonePayload<ExtArgs>
      photo: Prisma.$PhotoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      milestoneId: number
      photoId: number
      createdAt: Date
    }, ExtArgs["result"]["milestonePhoto"]>
    composites: {}
  }


  type MilestonePhotoGetPayload<S extends boolean | null | undefined | MilestonePhotoDefaultArgs> = $Result.GetResult<Prisma.$MilestonePhotoPayload, S>

  type MilestonePhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MilestonePhotoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MilestonePhotoCountAggregateInputType | true
    }

  export interface MilestonePhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MilestonePhoto'], meta: { name: 'MilestonePhoto' } }
    /**
     * Find zero or one MilestonePhoto that matches the filter.
     * @param {MilestonePhotoFindUniqueArgs} args - Arguments to find a MilestonePhoto
     * @example
     * // Get one MilestonePhoto
     * const milestonePhoto = await prisma.milestonePhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MilestonePhotoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MilestonePhotoFindUniqueArgs<ExtArgs>>
    ): Prisma__MilestonePhotoClient<$Result.GetResult<Prisma.$MilestonePhotoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MilestonePhoto that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MilestonePhotoFindUniqueOrThrowArgs} args - Arguments to find a MilestonePhoto
     * @example
     * // Get one MilestonePhoto
     * const milestonePhoto = await prisma.milestonePhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MilestonePhotoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MilestonePhotoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MilestonePhotoClient<$Result.GetResult<Prisma.$MilestonePhotoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MilestonePhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestonePhotoFindFirstArgs} args - Arguments to find a MilestonePhoto
     * @example
     * // Get one MilestonePhoto
     * const milestonePhoto = await prisma.milestonePhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MilestonePhotoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MilestonePhotoFindFirstArgs<ExtArgs>>
    ): Prisma__MilestonePhotoClient<$Result.GetResult<Prisma.$MilestonePhotoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MilestonePhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestonePhotoFindFirstOrThrowArgs} args - Arguments to find a MilestonePhoto
     * @example
     * // Get one MilestonePhoto
     * const milestonePhoto = await prisma.milestonePhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MilestonePhotoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MilestonePhotoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MilestonePhotoClient<$Result.GetResult<Prisma.$MilestonePhotoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MilestonePhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestonePhotoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MilestonePhotos
     * const milestonePhotos = await prisma.milestonePhoto.findMany()
     * 
     * // Get first 10 MilestonePhotos
     * const milestonePhotos = await prisma.milestonePhoto.findMany({ take: 10 })
     * 
     * // Only select the `milestoneId`
     * const milestonePhotoWithMilestoneIdOnly = await prisma.milestonePhoto.findMany({ select: { milestoneId: true } })
     * 
    **/
    findMany<T extends MilestonePhotoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MilestonePhotoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePhotoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MilestonePhoto.
     * @param {MilestonePhotoCreateArgs} args - Arguments to create a MilestonePhoto.
     * @example
     * // Create one MilestonePhoto
     * const MilestonePhoto = await prisma.milestonePhoto.create({
     *   data: {
     *     // ... data to create a MilestonePhoto
     *   }
     * })
     * 
    **/
    create<T extends MilestonePhotoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MilestonePhotoCreateArgs<ExtArgs>>
    ): Prisma__MilestonePhotoClient<$Result.GetResult<Prisma.$MilestonePhotoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MilestonePhotos.
     *     @param {MilestonePhotoCreateManyArgs} args - Arguments to create many MilestonePhotos.
     *     @example
     *     // Create many MilestonePhotos
     *     const milestonePhoto = await prisma.milestonePhoto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MilestonePhotoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MilestonePhotoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MilestonePhoto.
     * @param {MilestonePhotoDeleteArgs} args - Arguments to delete one MilestonePhoto.
     * @example
     * // Delete one MilestonePhoto
     * const MilestonePhoto = await prisma.milestonePhoto.delete({
     *   where: {
     *     // ... filter to delete one MilestonePhoto
     *   }
     * })
     * 
    **/
    delete<T extends MilestonePhotoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MilestonePhotoDeleteArgs<ExtArgs>>
    ): Prisma__MilestonePhotoClient<$Result.GetResult<Prisma.$MilestonePhotoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MilestonePhoto.
     * @param {MilestonePhotoUpdateArgs} args - Arguments to update one MilestonePhoto.
     * @example
     * // Update one MilestonePhoto
     * const milestonePhoto = await prisma.milestonePhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MilestonePhotoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MilestonePhotoUpdateArgs<ExtArgs>>
    ): Prisma__MilestonePhotoClient<$Result.GetResult<Prisma.$MilestonePhotoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MilestonePhotos.
     * @param {MilestonePhotoDeleteManyArgs} args - Arguments to filter MilestonePhotos to delete.
     * @example
     * // Delete a few MilestonePhotos
     * const { count } = await prisma.milestonePhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MilestonePhotoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MilestonePhotoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MilestonePhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestonePhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MilestonePhotos
     * const milestonePhoto = await prisma.milestonePhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MilestonePhotoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MilestonePhotoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MilestonePhoto.
     * @param {MilestonePhotoUpsertArgs} args - Arguments to update or create a MilestonePhoto.
     * @example
     * // Update or create a MilestonePhoto
     * const milestonePhoto = await prisma.milestonePhoto.upsert({
     *   create: {
     *     // ... data to create a MilestonePhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MilestonePhoto we want to update
     *   }
     * })
    **/
    upsert<T extends MilestonePhotoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MilestonePhotoUpsertArgs<ExtArgs>>
    ): Prisma__MilestonePhotoClient<$Result.GetResult<Prisma.$MilestonePhotoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MilestonePhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestonePhotoCountArgs} args - Arguments to filter MilestonePhotos to count.
     * @example
     * // Count the number of MilestonePhotos
     * const count = await prisma.milestonePhoto.count({
     *   where: {
     *     // ... the filter for the MilestonePhotos we want to count
     *   }
     * })
    **/
    count<T extends MilestonePhotoCountArgs>(
      args?: Subset<T, MilestonePhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MilestonePhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MilestonePhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestonePhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MilestonePhotoAggregateArgs>(args: Subset<T, MilestonePhotoAggregateArgs>): Prisma.PrismaPromise<GetMilestonePhotoAggregateType<T>>

    /**
     * Group by MilestonePhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestonePhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MilestonePhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MilestonePhotoGroupByArgs['orderBy'] }
        : { orderBy?: MilestonePhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MilestonePhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMilestonePhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MilestonePhoto model
   */
  readonly fields: MilestonePhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MilestonePhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MilestonePhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    milestone<T extends MilestoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MilestoneDefaultArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    photo<T extends PhotoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PhotoDefaultArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MilestonePhoto model
   */ 
  interface MilestonePhotoFieldRefs {
    readonly milestoneId: FieldRef<"MilestonePhoto", 'Int'>
    readonly photoId: FieldRef<"MilestonePhoto", 'Int'>
    readonly createdAt: FieldRef<"MilestonePhoto", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * MilestonePhoto findUnique
   */
  export type MilestonePhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilestonePhoto
     */
    select?: MilestonePhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestonePhotoInclude<ExtArgs> | null
    /**
     * Filter, which MilestonePhoto to fetch.
     */
    where: MilestonePhotoWhereUniqueInput
  }


  /**
   * MilestonePhoto findUniqueOrThrow
   */
  export type MilestonePhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilestonePhoto
     */
    select?: MilestonePhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestonePhotoInclude<ExtArgs> | null
    /**
     * Filter, which MilestonePhoto to fetch.
     */
    where: MilestonePhotoWhereUniqueInput
  }


  /**
   * MilestonePhoto findFirst
   */
  export type MilestonePhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilestonePhoto
     */
    select?: MilestonePhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestonePhotoInclude<ExtArgs> | null
    /**
     * Filter, which MilestonePhoto to fetch.
     */
    where?: MilestonePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MilestonePhotos to fetch.
     */
    orderBy?: MilestonePhotoOrderByWithRelationInput | MilestonePhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MilestonePhotos.
     */
    cursor?: MilestonePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MilestonePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MilestonePhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MilestonePhotos.
     */
    distinct?: MilestonePhotoScalarFieldEnum | MilestonePhotoScalarFieldEnum[]
  }


  /**
   * MilestonePhoto findFirstOrThrow
   */
  export type MilestonePhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilestonePhoto
     */
    select?: MilestonePhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestonePhotoInclude<ExtArgs> | null
    /**
     * Filter, which MilestonePhoto to fetch.
     */
    where?: MilestonePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MilestonePhotos to fetch.
     */
    orderBy?: MilestonePhotoOrderByWithRelationInput | MilestonePhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MilestonePhotos.
     */
    cursor?: MilestonePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MilestonePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MilestonePhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MilestonePhotos.
     */
    distinct?: MilestonePhotoScalarFieldEnum | MilestonePhotoScalarFieldEnum[]
  }


  /**
   * MilestonePhoto findMany
   */
  export type MilestonePhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilestonePhoto
     */
    select?: MilestonePhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestonePhotoInclude<ExtArgs> | null
    /**
     * Filter, which MilestonePhotos to fetch.
     */
    where?: MilestonePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MilestonePhotos to fetch.
     */
    orderBy?: MilestonePhotoOrderByWithRelationInput | MilestonePhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MilestonePhotos.
     */
    cursor?: MilestonePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MilestonePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MilestonePhotos.
     */
    skip?: number
    distinct?: MilestonePhotoScalarFieldEnum | MilestonePhotoScalarFieldEnum[]
  }


  /**
   * MilestonePhoto create
   */
  export type MilestonePhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilestonePhoto
     */
    select?: MilestonePhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestonePhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a MilestonePhoto.
     */
    data: XOR<MilestonePhotoCreateInput, MilestonePhotoUncheckedCreateInput>
  }


  /**
   * MilestonePhoto createMany
   */
  export type MilestonePhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MilestonePhotos.
     */
    data: MilestonePhotoCreateManyInput | MilestonePhotoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MilestonePhoto update
   */
  export type MilestonePhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilestonePhoto
     */
    select?: MilestonePhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestonePhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a MilestonePhoto.
     */
    data: XOR<MilestonePhotoUpdateInput, MilestonePhotoUncheckedUpdateInput>
    /**
     * Choose, which MilestonePhoto to update.
     */
    where: MilestonePhotoWhereUniqueInput
  }


  /**
   * MilestonePhoto updateMany
   */
  export type MilestonePhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MilestonePhotos.
     */
    data: XOR<MilestonePhotoUpdateManyMutationInput, MilestonePhotoUncheckedUpdateManyInput>
    /**
     * Filter which MilestonePhotos to update
     */
    where?: MilestonePhotoWhereInput
  }


  /**
   * MilestonePhoto upsert
   */
  export type MilestonePhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilestonePhoto
     */
    select?: MilestonePhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestonePhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the MilestonePhoto to update in case it exists.
     */
    where: MilestonePhotoWhereUniqueInput
    /**
     * In case the MilestonePhoto found by the `where` argument doesn't exist, create a new MilestonePhoto with this data.
     */
    create: XOR<MilestonePhotoCreateInput, MilestonePhotoUncheckedCreateInput>
    /**
     * In case the MilestonePhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MilestonePhotoUpdateInput, MilestonePhotoUncheckedUpdateInput>
  }


  /**
   * MilestonePhoto delete
   */
  export type MilestonePhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilestonePhoto
     */
    select?: MilestonePhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestonePhotoInclude<ExtArgs> | null
    /**
     * Filter which MilestonePhoto to delete.
     */
    where: MilestonePhotoWhereUniqueInput
  }


  /**
   * MilestonePhoto deleteMany
   */
  export type MilestonePhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MilestonePhotos to delete
     */
    where?: MilestonePhotoWhereInput
  }


  /**
   * MilestonePhoto without action
   */
  export type MilestonePhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilestonePhoto
     */
    select?: MilestonePhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MilestonePhotoInclude<ExtArgs> | null
  }



  /**
   * Model AlbumAccess
   */

  export type AggregateAlbumAccess = {
    _count: AlbumAccessCountAggregateOutputType | null
    _avg: AlbumAccessAvgAggregateOutputType | null
    _sum: AlbumAccessSumAggregateOutputType | null
    _min: AlbumAccessMinAggregateOutputType | null
    _max: AlbumAccessMaxAggregateOutputType | null
  }

  export type AlbumAccessAvgAggregateOutputType = {
    id: number | null
    albumId: number | null
    userId: number | null
  }

  export type AlbumAccessSumAggregateOutputType = {
    id: number | null
    albumId: number | null
    userId: number | null
  }

  export type AlbumAccessMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    albumId: number | null
    userId: number | null
  }

  export type AlbumAccessMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    albumId: number | null
    userId: number | null
  }

  export type AlbumAccessCountAggregateOutputType = {
    id: number
    permissions: number
    createdAt: number
    updatedAt: number
    albumId: number
    userId: number
    _all: number
  }


  export type AlbumAccessAvgAggregateInputType = {
    id?: true
    albumId?: true
    userId?: true
  }

  export type AlbumAccessSumAggregateInputType = {
    id?: true
    albumId?: true
    userId?: true
  }

  export type AlbumAccessMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    albumId?: true
    userId?: true
  }

  export type AlbumAccessMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    albumId?: true
    userId?: true
  }

  export type AlbumAccessCountAggregateInputType = {
    id?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    albumId?: true
    userId?: true
    _all?: true
  }

  export type AlbumAccessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlbumAccess to aggregate.
     */
    where?: AlbumAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlbumAccesses to fetch.
     */
    orderBy?: AlbumAccessOrderByWithRelationInput | AlbumAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlbumAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlbumAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlbumAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AlbumAccesses
    **/
    _count?: true | AlbumAccessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlbumAccessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlbumAccessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlbumAccessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlbumAccessMaxAggregateInputType
  }

  export type GetAlbumAccessAggregateType<T extends AlbumAccessAggregateArgs> = {
        [P in keyof T & keyof AggregateAlbumAccess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlbumAccess[P]>
      : GetScalarType<T[P], AggregateAlbumAccess[P]>
  }




  export type AlbumAccessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlbumAccessWhereInput
    orderBy?: AlbumAccessOrderByWithAggregationInput | AlbumAccessOrderByWithAggregationInput[]
    by: AlbumAccessScalarFieldEnum[] | AlbumAccessScalarFieldEnum
    having?: AlbumAccessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlbumAccessCountAggregateInputType | true
    _avg?: AlbumAccessAvgAggregateInputType
    _sum?: AlbumAccessSumAggregateInputType
    _min?: AlbumAccessMinAggregateInputType
    _max?: AlbumAccessMaxAggregateInputType
  }

  export type AlbumAccessGroupByOutputType = {
    id: number
    permissions: string[]
    createdAt: Date
    updatedAt: Date
    albumId: number
    userId: number
    _count: AlbumAccessCountAggregateOutputType | null
    _avg: AlbumAccessAvgAggregateOutputType | null
    _sum: AlbumAccessSumAggregateOutputType | null
    _min: AlbumAccessMinAggregateOutputType | null
    _max: AlbumAccessMaxAggregateOutputType | null
  }

  type GetAlbumAccessGroupByPayload<T extends AlbumAccessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlbumAccessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlbumAccessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlbumAccessGroupByOutputType[P]>
            : GetScalarType<T[P], AlbumAccessGroupByOutputType[P]>
        }
      >
    >


  export type AlbumAccessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    albumId?: boolean
    userId?: boolean
    album?: boolean | AlbumDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["albumAccess"]>

  export type AlbumAccessSelectScalar = {
    id?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    albumId?: boolean
    userId?: boolean
  }

  export type AlbumAccessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    album?: boolean | AlbumDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $AlbumAccessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AlbumAccess"
    objects: {
      album: Prisma.$AlbumPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      permissions: string[]
      createdAt: Date
      updatedAt: Date
      albumId: number
      userId: number
    }, ExtArgs["result"]["albumAccess"]>
    composites: {}
  }


  type AlbumAccessGetPayload<S extends boolean | null | undefined | AlbumAccessDefaultArgs> = $Result.GetResult<Prisma.$AlbumAccessPayload, S>

  type AlbumAccessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlbumAccessFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlbumAccessCountAggregateInputType | true
    }

  export interface AlbumAccessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AlbumAccess'], meta: { name: 'AlbumAccess' } }
    /**
     * Find zero or one AlbumAccess that matches the filter.
     * @param {AlbumAccessFindUniqueArgs} args - Arguments to find a AlbumAccess
     * @example
     * // Get one AlbumAccess
     * const albumAccess = await prisma.albumAccess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AlbumAccessFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AlbumAccessFindUniqueArgs<ExtArgs>>
    ): Prisma__AlbumAccessClient<$Result.GetResult<Prisma.$AlbumAccessPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AlbumAccess that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AlbumAccessFindUniqueOrThrowArgs} args - Arguments to find a AlbumAccess
     * @example
     * // Get one AlbumAccess
     * const albumAccess = await prisma.albumAccess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AlbumAccessFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AlbumAccessFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AlbumAccessClient<$Result.GetResult<Prisma.$AlbumAccessPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AlbumAccess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumAccessFindFirstArgs} args - Arguments to find a AlbumAccess
     * @example
     * // Get one AlbumAccess
     * const albumAccess = await prisma.albumAccess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AlbumAccessFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AlbumAccessFindFirstArgs<ExtArgs>>
    ): Prisma__AlbumAccessClient<$Result.GetResult<Prisma.$AlbumAccessPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AlbumAccess that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumAccessFindFirstOrThrowArgs} args - Arguments to find a AlbumAccess
     * @example
     * // Get one AlbumAccess
     * const albumAccess = await prisma.albumAccess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AlbumAccessFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AlbumAccessFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AlbumAccessClient<$Result.GetResult<Prisma.$AlbumAccessPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AlbumAccesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumAccessFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlbumAccesses
     * const albumAccesses = await prisma.albumAccess.findMany()
     * 
     * // Get first 10 AlbumAccesses
     * const albumAccesses = await prisma.albumAccess.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const albumAccessWithIdOnly = await prisma.albumAccess.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AlbumAccessFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AlbumAccessFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlbumAccessPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AlbumAccess.
     * @param {AlbumAccessCreateArgs} args - Arguments to create a AlbumAccess.
     * @example
     * // Create one AlbumAccess
     * const AlbumAccess = await prisma.albumAccess.create({
     *   data: {
     *     // ... data to create a AlbumAccess
     *   }
     * })
     * 
    **/
    create<T extends AlbumAccessCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AlbumAccessCreateArgs<ExtArgs>>
    ): Prisma__AlbumAccessClient<$Result.GetResult<Prisma.$AlbumAccessPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AlbumAccesses.
     *     @param {AlbumAccessCreateManyArgs} args - Arguments to create many AlbumAccesses.
     *     @example
     *     // Create many AlbumAccesses
     *     const albumAccess = await prisma.albumAccess.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AlbumAccessCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AlbumAccessCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AlbumAccess.
     * @param {AlbumAccessDeleteArgs} args - Arguments to delete one AlbumAccess.
     * @example
     * // Delete one AlbumAccess
     * const AlbumAccess = await prisma.albumAccess.delete({
     *   where: {
     *     // ... filter to delete one AlbumAccess
     *   }
     * })
     * 
    **/
    delete<T extends AlbumAccessDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AlbumAccessDeleteArgs<ExtArgs>>
    ): Prisma__AlbumAccessClient<$Result.GetResult<Prisma.$AlbumAccessPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AlbumAccess.
     * @param {AlbumAccessUpdateArgs} args - Arguments to update one AlbumAccess.
     * @example
     * // Update one AlbumAccess
     * const albumAccess = await prisma.albumAccess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AlbumAccessUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AlbumAccessUpdateArgs<ExtArgs>>
    ): Prisma__AlbumAccessClient<$Result.GetResult<Prisma.$AlbumAccessPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AlbumAccesses.
     * @param {AlbumAccessDeleteManyArgs} args - Arguments to filter AlbumAccesses to delete.
     * @example
     * // Delete a few AlbumAccesses
     * const { count } = await prisma.albumAccess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AlbumAccessDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AlbumAccessDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlbumAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumAccessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlbumAccesses
     * const albumAccess = await prisma.albumAccess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AlbumAccessUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AlbumAccessUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AlbumAccess.
     * @param {AlbumAccessUpsertArgs} args - Arguments to update or create a AlbumAccess.
     * @example
     * // Update or create a AlbumAccess
     * const albumAccess = await prisma.albumAccess.upsert({
     *   create: {
     *     // ... data to create a AlbumAccess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlbumAccess we want to update
     *   }
     * })
    **/
    upsert<T extends AlbumAccessUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AlbumAccessUpsertArgs<ExtArgs>>
    ): Prisma__AlbumAccessClient<$Result.GetResult<Prisma.$AlbumAccessPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AlbumAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumAccessCountArgs} args - Arguments to filter AlbumAccesses to count.
     * @example
     * // Count the number of AlbumAccesses
     * const count = await prisma.albumAccess.count({
     *   where: {
     *     // ... the filter for the AlbumAccesses we want to count
     *   }
     * })
    **/
    count<T extends AlbumAccessCountArgs>(
      args?: Subset<T, AlbumAccessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlbumAccessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlbumAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumAccessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlbumAccessAggregateArgs>(args: Subset<T, AlbumAccessAggregateArgs>): Prisma.PrismaPromise<GetAlbumAccessAggregateType<T>>

    /**
     * Group by AlbumAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlbumAccessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlbumAccessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlbumAccessGroupByArgs['orderBy'] }
        : { orderBy?: AlbumAccessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlbumAccessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlbumAccessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AlbumAccess model
   */
  readonly fields: AlbumAccessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AlbumAccess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlbumAccessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    album<T extends AlbumDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlbumDefaultArgs<ExtArgs>>): Prisma__AlbumClient<$Result.GetResult<Prisma.$AlbumPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AlbumAccess model
   */ 
  interface AlbumAccessFieldRefs {
    readonly id: FieldRef<"AlbumAccess", 'Int'>
    readonly permissions: FieldRef<"AlbumAccess", 'String[]'>
    readonly createdAt: FieldRef<"AlbumAccess", 'DateTime'>
    readonly updatedAt: FieldRef<"AlbumAccess", 'DateTime'>
    readonly albumId: FieldRef<"AlbumAccess", 'Int'>
    readonly userId: FieldRef<"AlbumAccess", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * AlbumAccess findUnique
   */
  export type AlbumAccessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumAccess
     */
    select?: AlbumAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumAccessInclude<ExtArgs> | null
    /**
     * Filter, which AlbumAccess to fetch.
     */
    where: AlbumAccessWhereUniqueInput
  }


  /**
   * AlbumAccess findUniqueOrThrow
   */
  export type AlbumAccessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumAccess
     */
    select?: AlbumAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumAccessInclude<ExtArgs> | null
    /**
     * Filter, which AlbumAccess to fetch.
     */
    where: AlbumAccessWhereUniqueInput
  }


  /**
   * AlbumAccess findFirst
   */
  export type AlbumAccessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumAccess
     */
    select?: AlbumAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumAccessInclude<ExtArgs> | null
    /**
     * Filter, which AlbumAccess to fetch.
     */
    where?: AlbumAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlbumAccesses to fetch.
     */
    orderBy?: AlbumAccessOrderByWithRelationInput | AlbumAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlbumAccesses.
     */
    cursor?: AlbumAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlbumAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlbumAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlbumAccesses.
     */
    distinct?: AlbumAccessScalarFieldEnum | AlbumAccessScalarFieldEnum[]
  }


  /**
   * AlbumAccess findFirstOrThrow
   */
  export type AlbumAccessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumAccess
     */
    select?: AlbumAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumAccessInclude<ExtArgs> | null
    /**
     * Filter, which AlbumAccess to fetch.
     */
    where?: AlbumAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlbumAccesses to fetch.
     */
    orderBy?: AlbumAccessOrderByWithRelationInput | AlbumAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlbumAccesses.
     */
    cursor?: AlbumAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlbumAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlbumAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlbumAccesses.
     */
    distinct?: AlbumAccessScalarFieldEnum | AlbumAccessScalarFieldEnum[]
  }


  /**
   * AlbumAccess findMany
   */
  export type AlbumAccessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumAccess
     */
    select?: AlbumAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumAccessInclude<ExtArgs> | null
    /**
     * Filter, which AlbumAccesses to fetch.
     */
    where?: AlbumAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlbumAccesses to fetch.
     */
    orderBy?: AlbumAccessOrderByWithRelationInput | AlbumAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AlbumAccesses.
     */
    cursor?: AlbumAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlbumAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlbumAccesses.
     */
    skip?: number
    distinct?: AlbumAccessScalarFieldEnum | AlbumAccessScalarFieldEnum[]
  }


  /**
   * AlbumAccess create
   */
  export type AlbumAccessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumAccess
     */
    select?: AlbumAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumAccessInclude<ExtArgs> | null
    /**
     * The data needed to create a AlbumAccess.
     */
    data: XOR<AlbumAccessCreateInput, AlbumAccessUncheckedCreateInput>
  }


  /**
   * AlbumAccess createMany
   */
  export type AlbumAccessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AlbumAccesses.
     */
    data: AlbumAccessCreateManyInput | AlbumAccessCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AlbumAccess update
   */
  export type AlbumAccessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumAccess
     */
    select?: AlbumAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumAccessInclude<ExtArgs> | null
    /**
     * The data needed to update a AlbumAccess.
     */
    data: XOR<AlbumAccessUpdateInput, AlbumAccessUncheckedUpdateInput>
    /**
     * Choose, which AlbumAccess to update.
     */
    where: AlbumAccessWhereUniqueInput
  }


  /**
   * AlbumAccess updateMany
   */
  export type AlbumAccessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AlbumAccesses.
     */
    data: XOR<AlbumAccessUpdateManyMutationInput, AlbumAccessUncheckedUpdateManyInput>
    /**
     * Filter which AlbumAccesses to update
     */
    where?: AlbumAccessWhereInput
  }


  /**
   * AlbumAccess upsert
   */
  export type AlbumAccessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumAccess
     */
    select?: AlbumAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumAccessInclude<ExtArgs> | null
    /**
     * The filter to search for the AlbumAccess to update in case it exists.
     */
    where: AlbumAccessWhereUniqueInput
    /**
     * In case the AlbumAccess found by the `where` argument doesn't exist, create a new AlbumAccess with this data.
     */
    create: XOR<AlbumAccessCreateInput, AlbumAccessUncheckedCreateInput>
    /**
     * In case the AlbumAccess was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlbumAccessUpdateInput, AlbumAccessUncheckedUpdateInput>
  }


  /**
   * AlbumAccess delete
   */
  export type AlbumAccessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumAccess
     */
    select?: AlbumAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumAccessInclude<ExtArgs> | null
    /**
     * Filter which AlbumAccess to delete.
     */
    where: AlbumAccessWhereUniqueInput
  }


  /**
   * AlbumAccess deleteMany
   */
  export type AlbumAccessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlbumAccesses to delete
     */
    where?: AlbumAccessWhereInput
  }


  /**
   * AlbumAccess without action
   */
  export type AlbumAccessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlbumAccess
     */
    select?: AlbumAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlbumAccessInclude<ExtArgs> | null
  }



  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    id: number | null
    authorId: number | null
  }

  export type PostSumAggregateOutputType = {
    id: number | null
    authorId: number | null
  }

  export type PostMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: number | null
  }

  export type PostMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: number | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    title: number
    content: number
    createdAt: number
    updatedAt: number
    authorId: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    id?: true
    authorId?: true
  }

  export type PostSumAggregateInputType = {
    id?: true
    authorId?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: number
    title: string
    content: string
    createdAt: Date
    updatedAt: Date
    authorId: number
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
  }

  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string
      createdAt: Date
      updatedAt: Date
      authorId: number
    }, ExtArgs["result"]["post"]>
    composites: {}
  }


  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PostFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Post that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PostFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PostFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
    **/
    create<T extends PostCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PostCreateArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Posts.
     *     @param {PostCreateManyArgs} args - Arguments to create many Posts.
     *     @example
     *     // Create many Posts
     *     const post = await prisma.post.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PostCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
    **/
    delete<T extends PostDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PostDeleteArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PostUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PostUpdateArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PostDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PostUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
    **/
    upsert<T extends PostUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PostUpsertArgs<ExtArgs>>
    ): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    comments<T extends Post$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Post$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Post model
   */ 
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'Int'>
    readonly title: FieldRef<"Post", 'String'>
    readonly content: FieldRef<"Post", 'String'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
    readonly authorId: FieldRef<"Post", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }


  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }


  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }


  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }


  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
  }


  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }


  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
  }


  /**
   * Post.comments
   */
  export type Post$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
  }



  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    id: number | null
    postId: number | null
    authorId: number | null
  }

  export type CommentSumAggregateOutputType = {
    id: number | null
    postId: number | null
    authorId: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: number | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    postId: number | null
    authorId: number | null
  }

  export type CommentMaxAggregateOutputType = {
    id: number | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    postId: number | null
    authorId: number | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    updatedAt: number
    postId: number
    authorId: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
  }

  export type CommentSumAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    postId?: true
    authorId?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    postId?: true
    authorId?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    postId?: true
    authorId?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: number
    content: string
    createdAt: Date
    updatedAt: Date
    postId: number
    authorId: number
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postId?: boolean
    authorId?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postId?: boolean
    authorId?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      content: string
      createdAt: Date
      updatedAt: Date
      postId: number
      authorId: number
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }


  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
    **/
    create<T extends CommentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentCreateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Comments.
     *     @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     *     @example
     *     // Create many Comments
     *     const comment = await prisma.comment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
    **/
    delete<T extends CommentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
    **/
    upsert<T extends CommentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'Int'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
    readonly postId: FieldRef<"Comment", 'Int'>
    readonly authorId: FieldRef<"Comment", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }


  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }


  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }


  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }


  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
  }



  /**
   * Model ParentInvite
   */

  export type AggregateParentInvite = {
    _count: ParentInviteCountAggregateOutputType | null
    _avg: ParentInviteAvgAggregateOutputType | null
    _sum: ParentInviteSumAggregateOutputType | null
    _min: ParentInviteMinAggregateOutputType | null
    _max: ParentInviteMaxAggregateOutputType | null
  }

  export type ParentInviteAvgAggregateOutputType = {
    id: number | null
    babyId: number | null
    senderId: number | null
  }

  export type ParentInviteSumAggregateOutputType = {
    id: number | null
    babyId: number | null
    senderId: number | null
  }

  export type ParentInviteMinAggregateOutputType = {
    id: number | null
    email: string | null
    babyId: number | null
    senderId: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParentInviteMaxAggregateOutputType = {
    id: number | null
    email: string | null
    babyId: number | null
    senderId: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParentInviteCountAggregateOutputType = {
    id: number
    email: number
    babyId: number
    senderId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParentInviteAvgAggregateInputType = {
    id?: true
    babyId?: true
    senderId?: true
  }

  export type ParentInviteSumAggregateInputType = {
    id?: true
    babyId?: true
    senderId?: true
  }

  export type ParentInviteMinAggregateInputType = {
    id?: true
    email?: true
    babyId?: true
    senderId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParentInviteMaxAggregateInputType = {
    id?: true
    email?: true
    babyId?: true
    senderId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParentInviteCountAggregateInputType = {
    id?: true
    email?: true
    babyId?: true
    senderId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParentInviteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParentInvite to aggregate.
     */
    where?: ParentInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentInvites to fetch.
     */
    orderBy?: ParentInviteOrderByWithRelationInput | ParentInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParentInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParentInvites
    **/
    _count?: true | ParentInviteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParentInviteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParentInviteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentInviteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentInviteMaxAggregateInputType
  }

  export type GetParentInviteAggregateType<T extends ParentInviteAggregateArgs> = {
        [P in keyof T & keyof AggregateParentInvite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParentInvite[P]>
      : GetScalarType<T[P], AggregateParentInvite[P]>
  }




  export type ParentInviteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentInviteWhereInput
    orderBy?: ParentInviteOrderByWithAggregationInput | ParentInviteOrderByWithAggregationInput[]
    by: ParentInviteScalarFieldEnum[] | ParentInviteScalarFieldEnum
    having?: ParentInviteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentInviteCountAggregateInputType | true
    _avg?: ParentInviteAvgAggregateInputType
    _sum?: ParentInviteSumAggregateInputType
    _min?: ParentInviteMinAggregateInputType
    _max?: ParentInviteMaxAggregateInputType
  }

  export type ParentInviteGroupByOutputType = {
    id: number
    email: string
    babyId: number
    senderId: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: ParentInviteCountAggregateOutputType | null
    _avg: ParentInviteAvgAggregateOutputType | null
    _sum: ParentInviteSumAggregateOutputType | null
    _min: ParentInviteMinAggregateOutputType | null
    _max: ParentInviteMaxAggregateOutputType | null
  }

  type GetParentInviteGroupByPayload<T extends ParentInviteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParentInviteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParentInviteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParentInviteGroupByOutputType[P]>
            : GetScalarType<T[P], ParentInviteGroupByOutputType[P]>
        }
      >
    >


  export type ParentInviteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    babyId?: boolean
    senderId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    baby?: boolean | BabyDefaultArgs<ExtArgs>
    sentBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parentInvite"]>

  export type ParentInviteSelectScalar = {
    id?: boolean
    email?: boolean
    babyId?: boolean
    senderId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ParentInviteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    baby?: boolean | BabyDefaultArgs<ExtArgs>
    sentBy?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $ParentInvitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParentInvite"
    objects: {
      baby: Prisma.$BabyPayload<ExtArgs>
      sentBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      babyId: number
      senderId: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["parentInvite"]>
    composites: {}
  }


  type ParentInviteGetPayload<S extends boolean | null | undefined | ParentInviteDefaultArgs> = $Result.GetResult<Prisma.$ParentInvitePayload, S>

  type ParentInviteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ParentInviteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ParentInviteCountAggregateInputType | true
    }

  export interface ParentInviteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParentInvite'], meta: { name: 'ParentInvite' } }
    /**
     * Find zero or one ParentInvite that matches the filter.
     * @param {ParentInviteFindUniqueArgs} args - Arguments to find a ParentInvite
     * @example
     * // Get one ParentInvite
     * const parentInvite = await prisma.parentInvite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ParentInviteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ParentInviteFindUniqueArgs<ExtArgs>>
    ): Prisma__ParentInviteClient<$Result.GetResult<Prisma.$ParentInvitePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ParentInvite that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ParentInviteFindUniqueOrThrowArgs} args - Arguments to find a ParentInvite
     * @example
     * // Get one ParentInvite
     * const parentInvite = await prisma.parentInvite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ParentInviteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ParentInviteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ParentInviteClient<$Result.GetResult<Prisma.$ParentInvitePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ParentInvite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentInviteFindFirstArgs} args - Arguments to find a ParentInvite
     * @example
     * // Get one ParentInvite
     * const parentInvite = await prisma.parentInvite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ParentInviteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ParentInviteFindFirstArgs<ExtArgs>>
    ): Prisma__ParentInviteClient<$Result.GetResult<Prisma.$ParentInvitePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ParentInvite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentInviteFindFirstOrThrowArgs} args - Arguments to find a ParentInvite
     * @example
     * // Get one ParentInvite
     * const parentInvite = await prisma.parentInvite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ParentInviteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ParentInviteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ParentInviteClient<$Result.GetResult<Prisma.$ParentInvitePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ParentInvites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentInviteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParentInvites
     * const parentInvites = await prisma.parentInvite.findMany()
     * 
     * // Get first 10 ParentInvites
     * const parentInvites = await prisma.parentInvite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parentInviteWithIdOnly = await prisma.parentInvite.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ParentInviteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ParentInviteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentInvitePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ParentInvite.
     * @param {ParentInviteCreateArgs} args - Arguments to create a ParentInvite.
     * @example
     * // Create one ParentInvite
     * const ParentInvite = await prisma.parentInvite.create({
     *   data: {
     *     // ... data to create a ParentInvite
     *   }
     * })
     * 
    **/
    create<T extends ParentInviteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ParentInviteCreateArgs<ExtArgs>>
    ): Prisma__ParentInviteClient<$Result.GetResult<Prisma.$ParentInvitePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ParentInvites.
     *     @param {ParentInviteCreateManyArgs} args - Arguments to create many ParentInvites.
     *     @example
     *     // Create many ParentInvites
     *     const parentInvite = await prisma.parentInvite.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ParentInviteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ParentInviteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ParentInvite.
     * @param {ParentInviteDeleteArgs} args - Arguments to delete one ParentInvite.
     * @example
     * // Delete one ParentInvite
     * const ParentInvite = await prisma.parentInvite.delete({
     *   where: {
     *     // ... filter to delete one ParentInvite
     *   }
     * })
     * 
    **/
    delete<T extends ParentInviteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ParentInviteDeleteArgs<ExtArgs>>
    ): Prisma__ParentInviteClient<$Result.GetResult<Prisma.$ParentInvitePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ParentInvite.
     * @param {ParentInviteUpdateArgs} args - Arguments to update one ParentInvite.
     * @example
     * // Update one ParentInvite
     * const parentInvite = await prisma.parentInvite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ParentInviteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ParentInviteUpdateArgs<ExtArgs>>
    ): Prisma__ParentInviteClient<$Result.GetResult<Prisma.$ParentInvitePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ParentInvites.
     * @param {ParentInviteDeleteManyArgs} args - Arguments to filter ParentInvites to delete.
     * @example
     * // Delete a few ParentInvites
     * const { count } = await prisma.parentInvite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ParentInviteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ParentInviteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParentInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentInviteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParentInvites
     * const parentInvite = await prisma.parentInvite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ParentInviteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ParentInviteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ParentInvite.
     * @param {ParentInviteUpsertArgs} args - Arguments to update or create a ParentInvite.
     * @example
     * // Update or create a ParentInvite
     * const parentInvite = await prisma.parentInvite.upsert({
     *   create: {
     *     // ... data to create a ParentInvite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParentInvite we want to update
     *   }
     * })
    **/
    upsert<T extends ParentInviteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ParentInviteUpsertArgs<ExtArgs>>
    ): Prisma__ParentInviteClient<$Result.GetResult<Prisma.$ParentInvitePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ParentInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentInviteCountArgs} args - Arguments to filter ParentInvites to count.
     * @example
     * // Count the number of ParentInvites
     * const count = await prisma.parentInvite.count({
     *   where: {
     *     // ... the filter for the ParentInvites we want to count
     *   }
     * })
    **/
    count<T extends ParentInviteCountArgs>(
      args?: Subset<T, ParentInviteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentInviteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParentInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentInviteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentInviteAggregateArgs>(args: Subset<T, ParentInviteAggregateArgs>): Prisma.PrismaPromise<GetParentInviteAggregateType<T>>

    /**
     * Group by ParentInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentInviteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParentInviteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParentInviteGroupByArgs['orderBy'] }
        : { orderBy?: ParentInviteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParentInviteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentInviteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParentInvite model
   */
  readonly fields: ParentInviteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParentInvite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParentInviteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    baby<T extends BabyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BabyDefaultArgs<ExtArgs>>): Prisma__BabyClient<$Result.GetResult<Prisma.$BabyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    sentBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ParentInvite model
   */ 
  interface ParentInviteFieldRefs {
    readonly id: FieldRef<"ParentInvite", 'Int'>
    readonly email: FieldRef<"ParentInvite", 'String'>
    readonly babyId: FieldRef<"ParentInvite", 'Int'>
    readonly senderId: FieldRef<"ParentInvite", 'Int'>
    readonly status: FieldRef<"ParentInvite", 'String'>
    readonly createdAt: FieldRef<"ParentInvite", 'DateTime'>
    readonly updatedAt: FieldRef<"ParentInvite", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ParentInvite findUnique
   */
  export type ParentInviteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvite
     */
    select?: ParentInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParentInviteInclude<ExtArgs> | null
    /**
     * Filter, which ParentInvite to fetch.
     */
    where: ParentInviteWhereUniqueInput
  }


  /**
   * ParentInvite findUniqueOrThrow
   */
  export type ParentInviteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvite
     */
    select?: ParentInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParentInviteInclude<ExtArgs> | null
    /**
     * Filter, which ParentInvite to fetch.
     */
    where: ParentInviteWhereUniqueInput
  }


  /**
   * ParentInvite findFirst
   */
  export type ParentInviteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvite
     */
    select?: ParentInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParentInviteInclude<ExtArgs> | null
    /**
     * Filter, which ParentInvite to fetch.
     */
    where?: ParentInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentInvites to fetch.
     */
    orderBy?: ParentInviteOrderByWithRelationInput | ParentInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParentInvites.
     */
    cursor?: ParentInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParentInvites.
     */
    distinct?: ParentInviteScalarFieldEnum | ParentInviteScalarFieldEnum[]
  }


  /**
   * ParentInvite findFirstOrThrow
   */
  export type ParentInviteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvite
     */
    select?: ParentInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParentInviteInclude<ExtArgs> | null
    /**
     * Filter, which ParentInvite to fetch.
     */
    where?: ParentInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentInvites to fetch.
     */
    orderBy?: ParentInviteOrderByWithRelationInput | ParentInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParentInvites.
     */
    cursor?: ParentInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParentInvites.
     */
    distinct?: ParentInviteScalarFieldEnum | ParentInviteScalarFieldEnum[]
  }


  /**
   * ParentInvite findMany
   */
  export type ParentInviteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvite
     */
    select?: ParentInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParentInviteInclude<ExtArgs> | null
    /**
     * Filter, which ParentInvites to fetch.
     */
    where?: ParentInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentInvites to fetch.
     */
    orderBy?: ParentInviteOrderByWithRelationInput | ParentInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParentInvites.
     */
    cursor?: ParentInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentInvites.
     */
    skip?: number
    distinct?: ParentInviteScalarFieldEnum | ParentInviteScalarFieldEnum[]
  }


  /**
   * ParentInvite create
   */
  export type ParentInviteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvite
     */
    select?: ParentInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParentInviteInclude<ExtArgs> | null
    /**
     * The data needed to create a ParentInvite.
     */
    data: XOR<ParentInviteCreateInput, ParentInviteUncheckedCreateInput>
  }


  /**
   * ParentInvite createMany
   */
  export type ParentInviteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParentInvites.
     */
    data: ParentInviteCreateManyInput | ParentInviteCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ParentInvite update
   */
  export type ParentInviteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvite
     */
    select?: ParentInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParentInviteInclude<ExtArgs> | null
    /**
     * The data needed to update a ParentInvite.
     */
    data: XOR<ParentInviteUpdateInput, ParentInviteUncheckedUpdateInput>
    /**
     * Choose, which ParentInvite to update.
     */
    where: ParentInviteWhereUniqueInput
  }


  /**
   * ParentInvite updateMany
   */
  export type ParentInviteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParentInvites.
     */
    data: XOR<ParentInviteUpdateManyMutationInput, ParentInviteUncheckedUpdateManyInput>
    /**
     * Filter which ParentInvites to update
     */
    where?: ParentInviteWhereInput
  }


  /**
   * ParentInvite upsert
   */
  export type ParentInviteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvite
     */
    select?: ParentInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParentInviteInclude<ExtArgs> | null
    /**
     * The filter to search for the ParentInvite to update in case it exists.
     */
    where: ParentInviteWhereUniqueInput
    /**
     * In case the ParentInvite found by the `where` argument doesn't exist, create a new ParentInvite with this data.
     */
    create: XOR<ParentInviteCreateInput, ParentInviteUncheckedCreateInput>
    /**
     * In case the ParentInvite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParentInviteUpdateInput, ParentInviteUncheckedUpdateInput>
  }


  /**
   * ParentInvite delete
   */
  export type ParentInviteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvite
     */
    select?: ParentInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParentInviteInclude<ExtArgs> | null
    /**
     * Filter which ParentInvite to delete.
     */
    where: ParentInviteWhereUniqueInput
  }


  /**
   * ParentInvite deleteMany
   */
  export type ParentInviteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParentInvites to delete
     */
    where?: ParentInviteWhereInput
  }


  /**
   * ParentInvite without action
   */
  export type ParentInviteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentInvite
     */
    select?: ParentInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParentInviteInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const BabyScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    dateOfBirth: 'dateOfBirth',
    gender: 'gender',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ownerId: 'ownerId'
  };

  export type BabyScalarFieldEnum = (typeof BabyScalarFieldEnum)[keyof typeof BabyScalarFieldEnum]


  export const BabyCaregiverScalarFieldEnum: {
    id: 'id',
    relationship: 'relationship',
    permissions: 'permissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    babyId: 'babyId',
    userId: 'userId'
  };

  export type BabyCaregiverScalarFieldEnum = (typeof BabyCaregiverScalarFieldEnum)[keyof typeof BabyCaregiverScalarFieldEnum]


  export const EliminationScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    type: 'type',
    weight: 'weight',
    success: 'success',
    location: 'location',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    babyId: 'babyId'
  };

  export type EliminationScalarFieldEnum = (typeof EliminationScalarFieldEnum)[keyof typeof EliminationScalarFieldEnum]


  export const FeedingScalarFieldEnum: {
    id: 'id',
    startTime: 'startTime',
    endTime: 'endTime',
    type: 'type',
    side: 'side',
    amount: 'amount',
    food: 'food',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    babyId: 'babyId'
  };

  export type FeedingScalarFieldEnum = (typeof FeedingScalarFieldEnum)[keyof typeof FeedingScalarFieldEnum]


  export const SleepScalarFieldEnum: {
    id: 'id',
    startTime: 'startTime',
    endTime: 'endTime',
    how: 'how',
    whereFellAsleep: 'whereFellAsleep',
    whereSlept: 'whereSlept',
    type: 'type',
    quality: 'quality',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    babyId: 'babyId'
  };

  export type SleepScalarFieldEnum = (typeof SleepScalarFieldEnum)[keyof typeof SleepScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    startTime: 'startTime',
    endTime: 'endTime',
    type: 'type',
    description: 'description',
    milestone: 'milestone',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    babyId: 'babyId'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const MilestoneScalarFieldEnum: {
    id: 'id',
    date: 'date',
    category: 'category',
    title: 'title',
    description: 'description',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    babyId: 'babyId'
  };

  export type MilestoneScalarFieldEnum = (typeof MilestoneScalarFieldEnum)[keyof typeof MilestoneScalarFieldEnum]


  export const HealthRecordScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    type: 'type',
    value: 'value',
    description: 'description',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    babyId: 'babyId'
  };

  export type HealthRecordScalarFieldEnum = (typeof HealthRecordScalarFieldEnum)[keyof typeof HealthRecordScalarFieldEnum]


  export const MeasurementScalarFieldEnum: {
    id: 'id',
    date: 'date',
    weight: 'weight',
    height: 'height',
    headCirc: 'headCirc',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    babyId: 'babyId'
  };

  export type MeasurementScalarFieldEnum = (typeof MeasurementScalarFieldEnum)[keyof typeof MeasurementScalarFieldEnum]


  export const AlbumScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    babyId: 'babyId'
  };

  export type AlbumScalarFieldEnum = (typeof AlbumScalarFieldEnum)[keyof typeof AlbumScalarFieldEnum]


  export const PhotoScalarFieldEnum: {
    id: 'id',
    url: 'url',
    caption: 'caption',
    timestamp: 'timestamp',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PhotoScalarFieldEnum = (typeof PhotoScalarFieldEnum)[keyof typeof PhotoScalarFieldEnum]


  export const BabyPhotoScalarFieldEnum: {
    babyId: 'babyId',
    photoId: 'photoId',
    createdAt: 'createdAt'
  };

  export type BabyPhotoScalarFieldEnum = (typeof BabyPhotoScalarFieldEnum)[keyof typeof BabyPhotoScalarFieldEnum]


  export const AlbumPhotoScalarFieldEnum: {
    albumId: 'albumId',
    photoId: 'photoId',
    createdAt: 'createdAt'
  };

  export type AlbumPhotoScalarFieldEnum = (typeof AlbumPhotoScalarFieldEnum)[keyof typeof AlbumPhotoScalarFieldEnum]


  export const ActivityPhotoScalarFieldEnum: {
    activityId: 'activityId',
    photoId: 'photoId',
    createdAt: 'createdAt'
  };

  export type ActivityPhotoScalarFieldEnum = (typeof ActivityPhotoScalarFieldEnum)[keyof typeof ActivityPhotoScalarFieldEnum]


  export const MilestonePhotoScalarFieldEnum: {
    milestoneId: 'milestoneId',
    photoId: 'photoId',
    createdAt: 'createdAt'
  };

  export type MilestonePhotoScalarFieldEnum = (typeof MilestonePhotoScalarFieldEnum)[keyof typeof MilestonePhotoScalarFieldEnum]


  export const AlbumAccessScalarFieldEnum: {
    id: 'id',
    permissions: 'permissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    albumId: 'albumId',
    userId: 'userId'
  };

  export type AlbumAccessScalarFieldEnum = (typeof AlbumAccessScalarFieldEnum)[keyof typeof AlbumAccessScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    authorId: 'authorId'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    postId: 'postId',
    authorId: 'authorId'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const ParentInviteScalarFieldEnum: {
    id: 'id',
    email: 'email',
    babyId: 'babyId',
    senderId: 'senderId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParentInviteScalarFieldEnum = (typeof ParentInviteScalarFieldEnum)[keyof typeof ParentInviteScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    babies?: BabyCaregiverListRelationFilter
    ownedBabies?: BabyListRelationFilter
    posts?: PostListRelationFilter
    comments?: CommentListRelationFilter
    ParentInvite?: ParentInviteListRelationFilter
    AlbumAccess?: AlbumAccessListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babies?: BabyCaregiverOrderByRelationAggregateInput
    ownedBabies?: BabyOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    ParentInvite?: ParentInviteOrderByRelationAggregateInput
    AlbumAccess?: AlbumAccessOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    babies?: BabyCaregiverListRelationFilter
    ownedBabies?: BabyListRelationFilter
    posts?: PostListRelationFilter
    comments?: CommentListRelationFilter
    ParentInvite?: ParentInviteListRelationFilter
    AlbumAccess?: AlbumAccessListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type BabyWhereInput = {
    AND?: BabyWhereInput | BabyWhereInput[]
    OR?: BabyWhereInput[]
    NOT?: BabyWhereInput | BabyWhereInput[]
    id?: IntFilter<"Baby"> | number
    firstName?: StringFilter<"Baby"> | string
    lastName?: StringFilter<"Baby"> | string
    dateOfBirth?: DateTimeFilter<"Baby"> | Date | string
    gender?: StringNullableFilter<"Baby"> | string | null
    createdAt?: DateTimeFilter<"Baby"> | Date | string
    updatedAt?: DateTimeFilter<"Baby"> | Date | string
    ownerId?: IntFilter<"Baby"> | number
    owner?: XOR<UserRelationFilter, UserWhereInput>
    caregivers?: BabyCaregiverListRelationFilter
    eliminations?: EliminationListRelationFilter
    feedings?: FeedingListRelationFilter
    sleepsleepSessions?: SleepListRelationFilter
    activities?: ActivityListRelationFilter
    photos?: BabyPhotoListRelationFilter
    milestones?: MilestoneListRelationFilter
    healthRecords?: HealthRecordListRelationFilter
    measurements?: MeasurementListRelationFilter
    albums?: AlbumListRelationFilter
    parentInvites?: ParentInviteListRelationFilter
  }

  export type BabyOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    owner?: UserOrderByWithRelationInput
    caregivers?: BabyCaregiverOrderByRelationAggregateInput
    eliminations?: EliminationOrderByRelationAggregateInput
    feedings?: FeedingOrderByRelationAggregateInput
    sleepsleepSessions?: SleepOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
    photos?: BabyPhotoOrderByRelationAggregateInput
    milestones?: MilestoneOrderByRelationAggregateInput
    healthRecords?: HealthRecordOrderByRelationAggregateInput
    measurements?: MeasurementOrderByRelationAggregateInput
    albums?: AlbumOrderByRelationAggregateInput
    parentInvites?: ParentInviteOrderByRelationAggregateInput
  }

  export type BabyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BabyWhereInput | BabyWhereInput[]
    OR?: BabyWhereInput[]
    NOT?: BabyWhereInput | BabyWhereInput[]
    firstName?: StringFilter<"Baby"> | string
    lastName?: StringFilter<"Baby"> | string
    dateOfBirth?: DateTimeFilter<"Baby"> | Date | string
    gender?: StringNullableFilter<"Baby"> | string | null
    createdAt?: DateTimeFilter<"Baby"> | Date | string
    updatedAt?: DateTimeFilter<"Baby"> | Date | string
    ownerId?: IntFilter<"Baby"> | number
    owner?: XOR<UserRelationFilter, UserWhereInput>
    caregivers?: BabyCaregiverListRelationFilter
    eliminations?: EliminationListRelationFilter
    feedings?: FeedingListRelationFilter
    sleepsleepSessions?: SleepListRelationFilter
    activities?: ActivityListRelationFilter
    photos?: BabyPhotoListRelationFilter
    milestones?: MilestoneListRelationFilter
    healthRecords?: HealthRecordListRelationFilter
    measurements?: MeasurementListRelationFilter
    albums?: AlbumListRelationFilter
    parentInvites?: ParentInviteListRelationFilter
  }, "id">

  export type BabyOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    _count?: BabyCountOrderByAggregateInput
    _avg?: BabyAvgOrderByAggregateInput
    _max?: BabyMaxOrderByAggregateInput
    _min?: BabyMinOrderByAggregateInput
    _sum?: BabySumOrderByAggregateInput
  }

  export type BabyScalarWhereWithAggregatesInput = {
    AND?: BabyScalarWhereWithAggregatesInput | BabyScalarWhereWithAggregatesInput[]
    OR?: BabyScalarWhereWithAggregatesInput[]
    NOT?: BabyScalarWhereWithAggregatesInput | BabyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Baby"> | number
    firstName?: StringWithAggregatesFilter<"Baby"> | string
    lastName?: StringWithAggregatesFilter<"Baby"> | string
    dateOfBirth?: DateTimeWithAggregatesFilter<"Baby"> | Date | string
    gender?: StringNullableWithAggregatesFilter<"Baby"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Baby"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Baby"> | Date | string
    ownerId?: IntWithAggregatesFilter<"Baby"> | number
  }

  export type BabyCaregiverWhereInput = {
    AND?: BabyCaregiverWhereInput | BabyCaregiverWhereInput[]
    OR?: BabyCaregiverWhereInput[]
    NOT?: BabyCaregiverWhereInput | BabyCaregiverWhereInput[]
    id?: IntFilter<"BabyCaregiver"> | number
    relationship?: StringFilter<"BabyCaregiver"> | string
    permissions?: StringNullableListFilter<"BabyCaregiver">
    createdAt?: DateTimeFilter<"BabyCaregiver"> | Date | string
    updatedAt?: DateTimeFilter<"BabyCaregiver"> | Date | string
    babyId?: IntFilter<"BabyCaregiver"> | number
    userId?: IntFilter<"BabyCaregiver"> | number
    baby?: XOR<BabyRelationFilter, BabyWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type BabyCaregiverOrderByWithRelationInput = {
    id?: SortOrder
    relationship?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
    userId?: SortOrder
    baby?: BabyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type BabyCaregiverWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    babyId_userId?: BabyCaregiverBabyIdUserIdCompoundUniqueInput
    AND?: BabyCaregiverWhereInput | BabyCaregiverWhereInput[]
    OR?: BabyCaregiverWhereInput[]
    NOT?: BabyCaregiverWhereInput | BabyCaregiverWhereInput[]
    relationship?: StringFilter<"BabyCaregiver"> | string
    permissions?: StringNullableListFilter<"BabyCaregiver">
    createdAt?: DateTimeFilter<"BabyCaregiver"> | Date | string
    updatedAt?: DateTimeFilter<"BabyCaregiver"> | Date | string
    babyId?: IntFilter<"BabyCaregiver"> | number
    userId?: IntFilter<"BabyCaregiver"> | number
    baby?: XOR<BabyRelationFilter, BabyWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "babyId_userId">

  export type BabyCaregiverOrderByWithAggregationInput = {
    id?: SortOrder
    relationship?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
    userId?: SortOrder
    _count?: BabyCaregiverCountOrderByAggregateInput
    _avg?: BabyCaregiverAvgOrderByAggregateInput
    _max?: BabyCaregiverMaxOrderByAggregateInput
    _min?: BabyCaregiverMinOrderByAggregateInput
    _sum?: BabyCaregiverSumOrderByAggregateInput
  }

  export type BabyCaregiverScalarWhereWithAggregatesInput = {
    AND?: BabyCaregiverScalarWhereWithAggregatesInput | BabyCaregiverScalarWhereWithAggregatesInput[]
    OR?: BabyCaregiverScalarWhereWithAggregatesInput[]
    NOT?: BabyCaregiverScalarWhereWithAggregatesInput | BabyCaregiverScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BabyCaregiver"> | number
    relationship?: StringWithAggregatesFilter<"BabyCaregiver"> | string
    permissions?: StringNullableListFilter<"BabyCaregiver">
    createdAt?: DateTimeWithAggregatesFilter<"BabyCaregiver"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BabyCaregiver"> | Date | string
    babyId?: IntWithAggregatesFilter<"BabyCaregiver"> | number
    userId?: IntWithAggregatesFilter<"BabyCaregiver"> | number
  }

  export type EliminationWhereInput = {
    AND?: EliminationWhereInput | EliminationWhereInput[]
    OR?: EliminationWhereInput[]
    NOT?: EliminationWhereInput | EliminationWhereInput[]
    id?: IntFilter<"Elimination"> | number
    timestamp?: DateTimeFilter<"Elimination"> | Date | string
    type?: StringFilter<"Elimination"> | string
    weight?: FloatNullableFilter<"Elimination"> | number | null
    success?: BoolFilter<"Elimination"> | boolean
    location?: StringNullableFilter<"Elimination"> | string | null
    notes?: StringNullableFilter<"Elimination"> | string | null
    createdAt?: DateTimeFilter<"Elimination"> | Date | string
    updatedAt?: DateTimeFilter<"Elimination"> | Date | string
    babyId?: IntFilter<"Elimination"> | number
    baby?: XOR<BabyRelationFilter, BabyWhereInput>
  }

  export type EliminationOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    weight?: SortOrderInput | SortOrder
    success?: SortOrder
    location?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
    baby?: BabyOrderByWithRelationInput
  }

  export type EliminationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EliminationWhereInput | EliminationWhereInput[]
    OR?: EliminationWhereInput[]
    NOT?: EliminationWhereInput | EliminationWhereInput[]
    timestamp?: DateTimeFilter<"Elimination"> | Date | string
    type?: StringFilter<"Elimination"> | string
    weight?: FloatNullableFilter<"Elimination"> | number | null
    success?: BoolFilter<"Elimination"> | boolean
    location?: StringNullableFilter<"Elimination"> | string | null
    notes?: StringNullableFilter<"Elimination"> | string | null
    createdAt?: DateTimeFilter<"Elimination"> | Date | string
    updatedAt?: DateTimeFilter<"Elimination"> | Date | string
    babyId?: IntFilter<"Elimination"> | number
    baby?: XOR<BabyRelationFilter, BabyWhereInput>
  }, "id">

  export type EliminationOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    weight?: SortOrderInput | SortOrder
    success?: SortOrder
    location?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
    _count?: EliminationCountOrderByAggregateInput
    _avg?: EliminationAvgOrderByAggregateInput
    _max?: EliminationMaxOrderByAggregateInput
    _min?: EliminationMinOrderByAggregateInput
    _sum?: EliminationSumOrderByAggregateInput
  }

  export type EliminationScalarWhereWithAggregatesInput = {
    AND?: EliminationScalarWhereWithAggregatesInput | EliminationScalarWhereWithAggregatesInput[]
    OR?: EliminationScalarWhereWithAggregatesInput[]
    NOT?: EliminationScalarWhereWithAggregatesInput | EliminationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Elimination"> | number
    timestamp?: DateTimeWithAggregatesFilter<"Elimination"> | Date | string
    type?: StringWithAggregatesFilter<"Elimination"> | string
    weight?: FloatNullableWithAggregatesFilter<"Elimination"> | number | null
    success?: BoolWithAggregatesFilter<"Elimination"> | boolean
    location?: StringNullableWithAggregatesFilter<"Elimination"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Elimination"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Elimination"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Elimination"> | Date | string
    babyId?: IntWithAggregatesFilter<"Elimination"> | number
  }

  export type FeedingWhereInput = {
    AND?: FeedingWhereInput | FeedingWhereInput[]
    OR?: FeedingWhereInput[]
    NOT?: FeedingWhereInput | FeedingWhereInput[]
    id?: IntFilter<"Feeding"> | number
    startTime?: DateTimeFilter<"Feeding"> | Date | string
    endTime?: DateTimeNullableFilter<"Feeding"> | Date | string | null
    type?: StringFilter<"Feeding"> | string
    side?: StringNullableFilter<"Feeding"> | string | null
    amount?: FloatNullableFilter<"Feeding"> | number | null
    food?: StringNullableFilter<"Feeding"> | string | null
    notes?: StringNullableFilter<"Feeding"> | string | null
    createdAt?: DateTimeFilter<"Feeding"> | Date | string
    updatedAt?: DateTimeFilter<"Feeding"> | Date | string
    babyId?: IntFilter<"Feeding"> | number
    baby?: XOR<BabyRelationFilter, BabyWhereInput>
  }

  export type FeedingOrderByWithRelationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    type?: SortOrder
    side?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    food?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
    baby?: BabyOrderByWithRelationInput
  }

  export type FeedingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FeedingWhereInput | FeedingWhereInput[]
    OR?: FeedingWhereInput[]
    NOT?: FeedingWhereInput | FeedingWhereInput[]
    startTime?: DateTimeFilter<"Feeding"> | Date | string
    endTime?: DateTimeNullableFilter<"Feeding"> | Date | string | null
    type?: StringFilter<"Feeding"> | string
    side?: StringNullableFilter<"Feeding"> | string | null
    amount?: FloatNullableFilter<"Feeding"> | number | null
    food?: StringNullableFilter<"Feeding"> | string | null
    notes?: StringNullableFilter<"Feeding"> | string | null
    createdAt?: DateTimeFilter<"Feeding"> | Date | string
    updatedAt?: DateTimeFilter<"Feeding"> | Date | string
    babyId?: IntFilter<"Feeding"> | number
    baby?: XOR<BabyRelationFilter, BabyWhereInput>
  }, "id">

  export type FeedingOrderByWithAggregationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    type?: SortOrder
    side?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    food?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
    _count?: FeedingCountOrderByAggregateInput
    _avg?: FeedingAvgOrderByAggregateInput
    _max?: FeedingMaxOrderByAggregateInput
    _min?: FeedingMinOrderByAggregateInput
    _sum?: FeedingSumOrderByAggregateInput
  }

  export type FeedingScalarWhereWithAggregatesInput = {
    AND?: FeedingScalarWhereWithAggregatesInput | FeedingScalarWhereWithAggregatesInput[]
    OR?: FeedingScalarWhereWithAggregatesInput[]
    NOT?: FeedingScalarWhereWithAggregatesInput | FeedingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Feeding"> | number
    startTime?: DateTimeWithAggregatesFilter<"Feeding"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"Feeding"> | Date | string | null
    type?: StringWithAggregatesFilter<"Feeding"> | string
    side?: StringNullableWithAggregatesFilter<"Feeding"> | string | null
    amount?: FloatNullableWithAggregatesFilter<"Feeding"> | number | null
    food?: StringNullableWithAggregatesFilter<"Feeding"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Feeding"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Feeding"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Feeding"> | Date | string
    babyId?: IntWithAggregatesFilter<"Feeding"> | number
  }

  export type SleepWhereInput = {
    AND?: SleepWhereInput | SleepWhereInput[]
    OR?: SleepWhereInput[]
    NOT?: SleepWhereInput | SleepWhereInput[]
    id?: IntFilter<"Sleep"> | number
    startTime?: DateTimeFilter<"Sleep"> | Date | string
    endTime?: DateTimeNullableFilter<"Sleep"> | Date | string | null
    how?: StringNullableFilter<"Sleep"> | string | null
    whereFellAsleep?: StringNullableFilter<"Sleep"> | string | null
    whereSlept?: StringNullableFilter<"Sleep"> | string | null
    type?: StringFilter<"Sleep"> | string
    quality?: IntNullableFilter<"Sleep"> | number | null
    notes?: StringNullableFilter<"Sleep"> | string | null
    createdAt?: DateTimeFilter<"Sleep"> | Date | string
    updatedAt?: DateTimeFilter<"Sleep"> | Date | string
    babyId?: IntFilter<"Sleep"> | number
    baby?: XOR<BabyRelationFilter, BabyWhereInput>
  }

  export type SleepOrderByWithRelationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    how?: SortOrderInput | SortOrder
    whereFellAsleep?: SortOrderInput | SortOrder
    whereSlept?: SortOrderInput | SortOrder
    type?: SortOrder
    quality?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
    baby?: BabyOrderByWithRelationInput
  }

  export type SleepWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SleepWhereInput | SleepWhereInput[]
    OR?: SleepWhereInput[]
    NOT?: SleepWhereInput | SleepWhereInput[]
    startTime?: DateTimeFilter<"Sleep"> | Date | string
    endTime?: DateTimeNullableFilter<"Sleep"> | Date | string | null
    how?: StringNullableFilter<"Sleep"> | string | null
    whereFellAsleep?: StringNullableFilter<"Sleep"> | string | null
    whereSlept?: StringNullableFilter<"Sleep"> | string | null
    type?: StringFilter<"Sleep"> | string
    quality?: IntNullableFilter<"Sleep"> | number | null
    notes?: StringNullableFilter<"Sleep"> | string | null
    createdAt?: DateTimeFilter<"Sleep"> | Date | string
    updatedAt?: DateTimeFilter<"Sleep"> | Date | string
    babyId?: IntFilter<"Sleep"> | number
    baby?: XOR<BabyRelationFilter, BabyWhereInput>
  }, "id">

  export type SleepOrderByWithAggregationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    how?: SortOrderInput | SortOrder
    whereFellAsleep?: SortOrderInput | SortOrder
    whereSlept?: SortOrderInput | SortOrder
    type?: SortOrder
    quality?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
    _count?: SleepCountOrderByAggregateInput
    _avg?: SleepAvgOrderByAggregateInput
    _max?: SleepMaxOrderByAggregateInput
    _min?: SleepMinOrderByAggregateInput
    _sum?: SleepSumOrderByAggregateInput
  }

  export type SleepScalarWhereWithAggregatesInput = {
    AND?: SleepScalarWhereWithAggregatesInput | SleepScalarWhereWithAggregatesInput[]
    OR?: SleepScalarWhereWithAggregatesInput[]
    NOT?: SleepScalarWhereWithAggregatesInput | SleepScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Sleep"> | number
    startTime?: DateTimeWithAggregatesFilter<"Sleep"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"Sleep"> | Date | string | null
    how?: StringNullableWithAggregatesFilter<"Sleep"> | string | null
    whereFellAsleep?: StringNullableWithAggregatesFilter<"Sleep"> | string | null
    whereSlept?: StringNullableWithAggregatesFilter<"Sleep"> | string | null
    type?: StringWithAggregatesFilter<"Sleep"> | string
    quality?: IntNullableWithAggregatesFilter<"Sleep"> | number | null
    notes?: StringNullableWithAggregatesFilter<"Sleep"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Sleep"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sleep"> | Date | string
    babyId?: IntWithAggregatesFilter<"Sleep"> | number
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: IntFilter<"Activity"> | number
    startTime?: DateTimeFilter<"Activity"> | Date | string
    endTime?: DateTimeNullableFilter<"Activity"> | Date | string | null
    type?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    milestone?: BoolFilter<"Activity"> | boolean
    notes?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    babyId?: IntFilter<"Activity"> | number
    baby?: XOR<BabyRelationFilter, BabyWhereInput>
    photos?: ActivityPhotoListRelationFilter
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    milestone?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
    baby?: BabyOrderByWithRelationInput
    photos?: ActivityPhotoOrderByRelationAggregateInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    startTime?: DateTimeFilter<"Activity"> | Date | string
    endTime?: DateTimeNullableFilter<"Activity"> | Date | string | null
    type?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    milestone?: BoolFilter<"Activity"> | boolean
    notes?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    babyId?: IntFilter<"Activity"> | number
    baby?: XOR<BabyRelationFilter, BabyWhereInput>
    photos?: ActivityPhotoListRelationFilter
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    milestone?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _avg?: ActivityAvgOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
    _sum?: ActivitySumOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Activity"> | number
    startTime?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"Activity"> | Date | string | null
    type?: StringWithAggregatesFilter<"Activity"> | string
    description?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    milestone?: BoolWithAggregatesFilter<"Activity"> | boolean
    notes?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    babyId?: IntWithAggregatesFilter<"Activity"> | number
  }

  export type MilestoneWhereInput = {
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    id?: IntFilter<"Milestone"> | number
    date?: DateTimeFilter<"Milestone"> | Date | string
    category?: StringFilter<"Milestone"> | string
    title?: StringFilter<"Milestone"> | string
    description?: StringNullableFilter<"Milestone"> | string | null
    notes?: StringNullableFilter<"Milestone"> | string | null
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
    updatedAt?: DateTimeFilter<"Milestone"> | Date | string
    babyId?: IntFilter<"Milestone"> | number
    baby?: XOR<BabyRelationFilter, BabyWhereInput>
    photos?: MilestonePhotoListRelationFilter
  }

  export type MilestoneOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
    baby?: BabyOrderByWithRelationInput
    photos?: MilestonePhotoOrderByRelationAggregateInput
  }

  export type MilestoneWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    date?: DateTimeFilter<"Milestone"> | Date | string
    category?: StringFilter<"Milestone"> | string
    title?: StringFilter<"Milestone"> | string
    description?: StringNullableFilter<"Milestone"> | string | null
    notes?: StringNullableFilter<"Milestone"> | string | null
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
    updatedAt?: DateTimeFilter<"Milestone"> | Date | string
    babyId?: IntFilter<"Milestone"> | number
    baby?: XOR<BabyRelationFilter, BabyWhereInput>
    photos?: MilestonePhotoListRelationFilter
  }, "id">

  export type MilestoneOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
    _count?: MilestoneCountOrderByAggregateInput
    _avg?: MilestoneAvgOrderByAggregateInput
    _max?: MilestoneMaxOrderByAggregateInput
    _min?: MilestoneMinOrderByAggregateInput
    _sum?: MilestoneSumOrderByAggregateInput
  }

  export type MilestoneScalarWhereWithAggregatesInput = {
    AND?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    OR?: MilestoneScalarWhereWithAggregatesInput[]
    NOT?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Milestone"> | number
    date?: DateTimeWithAggregatesFilter<"Milestone"> | Date | string
    category?: StringWithAggregatesFilter<"Milestone"> | string
    title?: StringWithAggregatesFilter<"Milestone"> | string
    description?: StringNullableWithAggregatesFilter<"Milestone"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Milestone"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Milestone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Milestone"> | Date | string
    babyId?: IntWithAggregatesFilter<"Milestone"> | number
  }

  export type HealthRecordWhereInput = {
    AND?: HealthRecordWhereInput | HealthRecordWhereInput[]
    OR?: HealthRecordWhereInput[]
    NOT?: HealthRecordWhereInput | HealthRecordWhereInput[]
    id?: IntFilter<"HealthRecord"> | number
    timestamp?: DateTimeFilter<"HealthRecord"> | Date | string
    type?: StringFilter<"HealthRecord"> | string
    value?: FloatNullableFilter<"HealthRecord"> | number | null
    description?: StringNullableFilter<"HealthRecord"> | string | null
    notes?: StringNullableFilter<"HealthRecord"> | string | null
    createdAt?: DateTimeFilter<"HealthRecord"> | Date | string
    updatedAt?: DateTimeFilter<"HealthRecord"> | Date | string
    babyId?: IntFilter<"HealthRecord"> | number
    baby?: XOR<BabyRelationFilter, BabyWhereInput>
  }

  export type HealthRecordOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    value?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
    baby?: BabyOrderByWithRelationInput
  }

  export type HealthRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HealthRecordWhereInput | HealthRecordWhereInput[]
    OR?: HealthRecordWhereInput[]
    NOT?: HealthRecordWhereInput | HealthRecordWhereInput[]
    timestamp?: DateTimeFilter<"HealthRecord"> | Date | string
    type?: StringFilter<"HealthRecord"> | string
    value?: FloatNullableFilter<"HealthRecord"> | number | null
    description?: StringNullableFilter<"HealthRecord"> | string | null
    notes?: StringNullableFilter<"HealthRecord"> | string | null
    createdAt?: DateTimeFilter<"HealthRecord"> | Date | string
    updatedAt?: DateTimeFilter<"HealthRecord"> | Date | string
    babyId?: IntFilter<"HealthRecord"> | number
    baby?: XOR<BabyRelationFilter, BabyWhereInput>
  }, "id">

  export type HealthRecordOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    value?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
    _count?: HealthRecordCountOrderByAggregateInput
    _avg?: HealthRecordAvgOrderByAggregateInput
    _max?: HealthRecordMaxOrderByAggregateInput
    _min?: HealthRecordMinOrderByAggregateInput
    _sum?: HealthRecordSumOrderByAggregateInput
  }

  export type HealthRecordScalarWhereWithAggregatesInput = {
    AND?: HealthRecordScalarWhereWithAggregatesInput | HealthRecordScalarWhereWithAggregatesInput[]
    OR?: HealthRecordScalarWhereWithAggregatesInput[]
    NOT?: HealthRecordScalarWhereWithAggregatesInput | HealthRecordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HealthRecord"> | number
    timestamp?: DateTimeWithAggregatesFilter<"HealthRecord"> | Date | string
    type?: StringWithAggregatesFilter<"HealthRecord"> | string
    value?: FloatNullableWithAggregatesFilter<"HealthRecord"> | number | null
    description?: StringNullableWithAggregatesFilter<"HealthRecord"> | string | null
    notes?: StringNullableWithAggregatesFilter<"HealthRecord"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"HealthRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HealthRecord"> | Date | string
    babyId?: IntWithAggregatesFilter<"HealthRecord"> | number
  }

  export type MeasurementWhereInput = {
    AND?: MeasurementWhereInput | MeasurementWhereInput[]
    OR?: MeasurementWhereInput[]
    NOT?: MeasurementWhereInput | MeasurementWhereInput[]
    id?: IntFilter<"Measurement"> | number
    date?: DateTimeFilter<"Measurement"> | Date | string
    weight?: FloatNullableFilter<"Measurement"> | number | null
    height?: FloatNullableFilter<"Measurement"> | number | null
    headCirc?: FloatNullableFilter<"Measurement"> | number | null
    notes?: StringNullableFilter<"Measurement"> | string | null
    createdAt?: DateTimeFilter<"Measurement"> | Date | string
    updatedAt?: DateTimeFilter<"Measurement"> | Date | string
    babyId?: IntFilter<"Measurement"> | number
    baby?: XOR<BabyRelationFilter, BabyWhereInput>
  }

  export type MeasurementOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    weight?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    headCirc?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
    baby?: BabyOrderByWithRelationInput
  }

  export type MeasurementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MeasurementWhereInput | MeasurementWhereInput[]
    OR?: MeasurementWhereInput[]
    NOT?: MeasurementWhereInput | MeasurementWhereInput[]
    date?: DateTimeFilter<"Measurement"> | Date | string
    weight?: FloatNullableFilter<"Measurement"> | number | null
    height?: FloatNullableFilter<"Measurement"> | number | null
    headCirc?: FloatNullableFilter<"Measurement"> | number | null
    notes?: StringNullableFilter<"Measurement"> | string | null
    createdAt?: DateTimeFilter<"Measurement"> | Date | string
    updatedAt?: DateTimeFilter<"Measurement"> | Date | string
    babyId?: IntFilter<"Measurement"> | number
    baby?: XOR<BabyRelationFilter, BabyWhereInput>
  }, "id">

  export type MeasurementOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    weight?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    headCirc?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
    _count?: MeasurementCountOrderByAggregateInput
    _avg?: MeasurementAvgOrderByAggregateInput
    _max?: MeasurementMaxOrderByAggregateInput
    _min?: MeasurementMinOrderByAggregateInput
    _sum?: MeasurementSumOrderByAggregateInput
  }

  export type MeasurementScalarWhereWithAggregatesInput = {
    AND?: MeasurementScalarWhereWithAggregatesInput | MeasurementScalarWhereWithAggregatesInput[]
    OR?: MeasurementScalarWhereWithAggregatesInput[]
    NOT?: MeasurementScalarWhereWithAggregatesInput | MeasurementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Measurement"> | number
    date?: DateTimeWithAggregatesFilter<"Measurement"> | Date | string
    weight?: FloatNullableWithAggregatesFilter<"Measurement"> | number | null
    height?: FloatNullableWithAggregatesFilter<"Measurement"> | number | null
    headCirc?: FloatNullableWithAggregatesFilter<"Measurement"> | number | null
    notes?: StringNullableWithAggregatesFilter<"Measurement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Measurement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Measurement"> | Date | string
    babyId?: IntWithAggregatesFilter<"Measurement"> | number
  }

  export type AlbumWhereInput = {
    AND?: AlbumWhereInput | AlbumWhereInput[]
    OR?: AlbumWhereInput[]
    NOT?: AlbumWhereInput | AlbumWhereInput[]
    id?: IntFilter<"Album"> | number
    title?: StringFilter<"Album"> | string
    description?: StringNullableFilter<"Album"> | string | null
    createdAt?: DateTimeFilter<"Album"> | Date | string
    updatedAt?: DateTimeFilter<"Album"> | Date | string
    babyId?: IntFilter<"Album"> | number
    baby?: XOR<BabyRelationFilter, BabyWhereInput>
    photos?: AlbumPhotoListRelationFilter
    access?: AlbumAccessListRelationFilter
  }

  export type AlbumOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
    baby?: BabyOrderByWithRelationInput
    photos?: AlbumPhotoOrderByRelationAggregateInput
    access?: AlbumAccessOrderByRelationAggregateInput
  }

  export type AlbumWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AlbumWhereInput | AlbumWhereInput[]
    OR?: AlbumWhereInput[]
    NOT?: AlbumWhereInput | AlbumWhereInput[]
    title?: StringFilter<"Album"> | string
    description?: StringNullableFilter<"Album"> | string | null
    createdAt?: DateTimeFilter<"Album"> | Date | string
    updatedAt?: DateTimeFilter<"Album"> | Date | string
    babyId?: IntFilter<"Album"> | number
    baby?: XOR<BabyRelationFilter, BabyWhereInput>
    photos?: AlbumPhotoListRelationFilter
    access?: AlbumAccessListRelationFilter
  }, "id">

  export type AlbumOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
    _count?: AlbumCountOrderByAggregateInput
    _avg?: AlbumAvgOrderByAggregateInput
    _max?: AlbumMaxOrderByAggregateInput
    _min?: AlbumMinOrderByAggregateInput
    _sum?: AlbumSumOrderByAggregateInput
  }

  export type AlbumScalarWhereWithAggregatesInput = {
    AND?: AlbumScalarWhereWithAggregatesInput | AlbumScalarWhereWithAggregatesInput[]
    OR?: AlbumScalarWhereWithAggregatesInput[]
    NOT?: AlbumScalarWhereWithAggregatesInput | AlbumScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Album"> | number
    title?: StringWithAggregatesFilter<"Album"> | string
    description?: StringNullableWithAggregatesFilter<"Album"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Album"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Album"> | Date | string
    babyId?: IntWithAggregatesFilter<"Album"> | number
  }

  export type PhotoWhereInput = {
    AND?: PhotoWhereInput | PhotoWhereInput[]
    OR?: PhotoWhereInput[]
    NOT?: PhotoWhereInput | PhotoWhereInput[]
    id?: IntFilter<"Photo"> | number
    url?: StringFilter<"Photo"> | string
    caption?: StringNullableFilter<"Photo"> | string | null
    timestamp?: DateTimeFilter<"Photo"> | Date | string
    createdAt?: DateTimeFilter<"Photo"> | Date | string
    updatedAt?: DateTimeFilter<"Photo"> | Date | string
    babyPhotos?: BabyPhotoListRelationFilter
    albumPhotos?: AlbumPhotoListRelationFilter
    activityPhotos?: ActivityPhotoListRelationFilter
    milestonePhotos?: MilestonePhotoListRelationFilter
  }

  export type PhotoOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    caption?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyPhotos?: BabyPhotoOrderByRelationAggregateInput
    albumPhotos?: AlbumPhotoOrderByRelationAggregateInput
    activityPhotos?: ActivityPhotoOrderByRelationAggregateInput
    milestonePhotos?: MilestonePhotoOrderByRelationAggregateInput
  }

  export type PhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PhotoWhereInput | PhotoWhereInput[]
    OR?: PhotoWhereInput[]
    NOT?: PhotoWhereInput | PhotoWhereInput[]
    url?: StringFilter<"Photo"> | string
    caption?: StringNullableFilter<"Photo"> | string | null
    timestamp?: DateTimeFilter<"Photo"> | Date | string
    createdAt?: DateTimeFilter<"Photo"> | Date | string
    updatedAt?: DateTimeFilter<"Photo"> | Date | string
    babyPhotos?: BabyPhotoListRelationFilter
    albumPhotos?: AlbumPhotoListRelationFilter
    activityPhotos?: ActivityPhotoListRelationFilter
    milestonePhotos?: MilestonePhotoListRelationFilter
  }, "id">

  export type PhotoOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    caption?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PhotoCountOrderByAggregateInput
    _avg?: PhotoAvgOrderByAggregateInput
    _max?: PhotoMaxOrderByAggregateInput
    _min?: PhotoMinOrderByAggregateInput
    _sum?: PhotoSumOrderByAggregateInput
  }

  export type PhotoScalarWhereWithAggregatesInput = {
    AND?: PhotoScalarWhereWithAggregatesInput | PhotoScalarWhereWithAggregatesInput[]
    OR?: PhotoScalarWhereWithAggregatesInput[]
    NOT?: PhotoScalarWhereWithAggregatesInput | PhotoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Photo"> | number
    url?: StringWithAggregatesFilter<"Photo"> | string
    caption?: StringNullableWithAggregatesFilter<"Photo"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"Photo"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Photo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Photo"> | Date | string
  }

  export type BabyPhotoWhereInput = {
    AND?: BabyPhotoWhereInput | BabyPhotoWhereInput[]
    OR?: BabyPhotoWhereInput[]
    NOT?: BabyPhotoWhereInput | BabyPhotoWhereInput[]
    babyId?: IntFilter<"BabyPhoto"> | number
    photoId?: IntFilter<"BabyPhoto"> | number
    createdAt?: DateTimeFilter<"BabyPhoto"> | Date | string
    baby?: XOR<BabyRelationFilter, BabyWhereInput>
    photo?: XOR<PhotoRelationFilter, PhotoWhereInput>
  }

  export type BabyPhotoOrderByWithRelationInput = {
    babyId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
    baby?: BabyOrderByWithRelationInput
    photo?: PhotoOrderByWithRelationInput
  }

  export type BabyPhotoWhereUniqueInput = Prisma.AtLeast<{
    babyId_photoId?: BabyPhotoBabyIdPhotoIdCompoundUniqueInput
    AND?: BabyPhotoWhereInput | BabyPhotoWhereInput[]
    OR?: BabyPhotoWhereInput[]
    NOT?: BabyPhotoWhereInput | BabyPhotoWhereInput[]
    babyId?: IntFilter<"BabyPhoto"> | number
    photoId?: IntFilter<"BabyPhoto"> | number
    createdAt?: DateTimeFilter<"BabyPhoto"> | Date | string
    baby?: XOR<BabyRelationFilter, BabyWhereInput>
    photo?: XOR<PhotoRelationFilter, PhotoWhereInput>
  }, "babyId_photoId">

  export type BabyPhotoOrderByWithAggregationInput = {
    babyId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
    _count?: BabyPhotoCountOrderByAggregateInput
    _avg?: BabyPhotoAvgOrderByAggregateInput
    _max?: BabyPhotoMaxOrderByAggregateInput
    _min?: BabyPhotoMinOrderByAggregateInput
    _sum?: BabyPhotoSumOrderByAggregateInput
  }

  export type BabyPhotoScalarWhereWithAggregatesInput = {
    AND?: BabyPhotoScalarWhereWithAggregatesInput | BabyPhotoScalarWhereWithAggregatesInput[]
    OR?: BabyPhotoScalarWhereWithAggregatesInput[]
    NOT?: BabyPhotoScalarWhereWithAggregatesInput | BabyPhotoScalarWhereWithAggregatesInput[]
    babyId?: IntWithAggregatesFilter<"BabyPhoto"> | number
    photoId?: IntWithAggregatesFilter<"BabyPhoto"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BabyPhoto"> | Date | string
  }

  export type AlbumPhotoWhereInput = {
    AND?: AlbumPhotoWhereInput | AlbumPhotoWhereInput[]
    OR?: AlbumPhotoWhereInput[]
    NOT?: AlbumPhotoWhereInput | AlbumPhotoWhereInput[]
    albumId?: IntFilter<"AlbumPhoto"> | number
    photoId?: IntFilter<"AlbumPhoto"> | number
    createdAt?: DateTimeFilter<"AlbumPhoto"> | Date | string
    album?: XOR<AlbumRelationFilter, AlbumWhereInput>
    photo?: XOR<PhotoRelationFilter, PhotoWhereInput>
  }

  export type AlbumPhotoOrderByWithRelationInput = {
    albumId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
    album?: AlbumOrderByWithRelationInput
    photo?: PhotoOrderByWithRelationInput
  }

  export type AlbumPhotoWhereUniqueInput = Prisma.AtLeast<{
    albumId_photoId?: AlbumPhotoAlbumIdPhotoIdCompoundUniqueInput
    AND?: AlbumPhotoWhereInput | AlbumPhotoWhereInput[]
    OR?: AlbumPhotoWhereInput[]
    NOT?: AlbumPhotoWhereInput | AlbumPhotoWhereInput[]
    albumId?: IntFilter<"AlbumPhoto"> | number
    photoId?: IntFilter<"AlbumPhoto"> | number
    createdAt?: DateTimeFilter<"AlbumPhoto"> | Date | string
    album?: XOR<AlbumRelationFilter, AlbumWhereInput>
    photo?: XOR<PhotoRelationFilter, PhotoWhereInput>
  }, "albumId_photoId">

  export type AlbumPhotoOrderByWithAggregationInput = {
    albumId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
    _count?: AlbumPhotoCountOrderByAggregateInput
    _avg?: AlbumPhotoAvgOrderByAggregateInput
    _max?: AlbumPhotoMaxOrderByAggregateInput
    _min?: AlbumPhotoMinOrderByAggregateInput
    _sum?: AlbumPhotoSumOrderByAggregateInput
  }

  export type AlbumPhotoScalarWhereWithAggregatesInput = {
    AND?: AlbumPhotoScalarWhereWithAggregatesInput | AlbumPhotoScalarWhereWithAggregatesInput[]
    OR?: AlbumPhotoScalarWhereWithAggregatesInput[]
    NOT?: AlbumPhotoScalarWhereWithAggregatesInput | AlbumPhotoScalarWhereWithAggregatesInput[]
    albumId?: IntWithAggregatesFilter<"AlbumPhoto"> | number
    photoId?: IntWithAggregatesFilter<"AlbumPhoto"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AlbumPhoto"> | Date | string
  }

  export type ActivityPhotoWhereInput = {
    AND?: ActivityPhotoWhereInput | ActivityPhotoWhereInput[]
    OR?: ActivityPhotoWhereInput[]
    NOT?: ActivityPhotoWhereInput | ActivityPhotoWhereInput[]
    activityId?: IntFilter<"ActivityPhoto"> | number
    photoId?: IntFilter<"ActivityPhoto"> | number
    createdAt?: DateTimeFilter<"ActivityPhoto"> | Date | string
    activity?: XOR<ActivityRelationFilter, ActivityWhereInput>
    photo?: XOR<PhotoRelationFilter, PhotoWhereInput>
  }

  export type ActivityPhotoOrderByWithRelationInput = {
    activityId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
    activity?: ActivityOrderByWithRelationInput
    photo?: PhotoOrderByWithRelationInput
  }

  export type ActivityPhotoWhereUniqueInput = Prisma.AtLeast<{
    activityId_photoId?: ActivityPhotoActivityIdPhotoIdCompoundUniqueInput
    AND?: ActivityPhotoWhereInput | ActivityPhotoWhereInput[]
    OR?: ActivityPhotoWhereInput[]
    NOT?: ActivityPhotoWhereInput | ActivityPhotoWhereInput[]
    activityId?: IntFilter<"ActivityPhoto"> | number
    photoId?: IntFilter<"ActivityPhoto"> | number
    createdAt?: DateTimeFilter<"ActivityPhoto"> | Date | string
    activity?: XOR<ActivityRelationFilter, ActivityWhereInput>
    photo?: XOR<PhotoRelationFilter, PhotoWhereInput>
  }, "activityId_photoId">

  export type ActivityPhotoOrderByWithAggregationInput = {
    activityId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
    _count?: ActivityPhotoCountOrderByAggregateInput
    _avg?: ActivityPhotoAvgOrderByAggregateInput
    _max?: ActivityPhotoMaxOrderByAggregateInput
    _min?: ActivityPhotoMinOrderByAggregateInput
    _sum?: ActivityPhotoSumOrderByAggregateInput
  }

  export type ActivityPhotoScalarWhereWithAggregatesInput = {
    AND?: ActivityPhotoScalarWhereWithAggregatesInput | ActivityPhotoScalarWhereWithAggregatesInput[]
    OR?: ActivityPhotoScalarWhereWithAggregatesInput[]
    NOT?: ActivityPhotoScalarWhereWithAggregatesInput | ActivityPhotoScalarWhereWithAggregatesInput[]
    activityId?: IntWithAggregatesFilter<"ActivityPhoto"> | number
    photoId?: IntWithAggregatesFilter<"ActivityPhoto"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ActivityPhoto"> | Date | string
  }

  export type MilestonePhotoWhereInput = {
    AND?: MilestonePhotoWhereInput | MilestonePhotoWhereInput[]
    OR?: MilestonePhotoWhereInput[]
    NOT?: MilestonePhotoWhereInput | MilestonePhotoWhereInput[]
    milestoneId?: IntFilter<"MilestonePhoto"> | number
    photoId?: IntFilter<"MilestonePhoto"> | number
    createdAt?: DateTimeFilter<"MilestonePhoto"> | Date | string
    milestone?: XOR<MilestoneRelationFilter, MilestoneWhereInput>
    photo?: XOR<PhotoRelationFilter, PhotoWhereInput>
  }

  export type MilestonePhotoOrderByWithRelationInput = {
    milestoneId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
    milestone?: MilestoneOrderByWithRelationInput
    photo?: PhotoOrderByWithRelationInput
  }

  export type MilestonePhotoWhereUniqueInput = Prisma.AtLeast<{
    milestoneId_photoId?: MilestonePhotoMilestoneIdPhotoIdCompoundUniqueInput
    AND?: MilestonePhotoWhereInput | MilestonePhotoWhereInput[]
    OR?: MilestonePhotoWhereInput[]
    NOT?: MilestonePhotoWhereInput | MilestonePhotoWhereInput[]
    milestoneId?: IntFilter<"MilestonePhoto"> | number
    photoId?: IntFilter<"MilestonePhoto"> | number
    createdAt?: DateTimeFilter<"MilestonePhoto"> | Date | string
    milestone?: XOR<MilestoneRelationFilter, MilestoneWhereInput>
    photo?: XOR<PhotoRelationFilter, PhotoWhereInput>
  }, "milestoneId_photoId">

  export type MilestonePhotoOrderByWithAggregationInput = {
    milestoneId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
    _count?: MilestonePhotoCountOrderByAggregateInput
    _avg?: MilestonePhotoAvgOrderByAggregateInput
    _max?: MilestonePhotoMaxOrderByAggregateInput
    _min?: MilestonePhotoMinOrderByAggregateInput
    _sum?: MilestonePhotoSumOrderByAggregateInput
  }

  export type MilestonePhotoScalarWhereWithAggregatesInput = {
    AND?: MilestonePhotoScalarWhereWithAggregatesInput | MilestonePhotoScalarWhereWithAggregatesInput[]
    OR?: MilestonePhotoScalarWhereWithAggregatesInput[]
    NOT?: MilestonePhotoScalarWhereWithAggregatesInput | MilestonePhotoScalarWhereWithAggregatesInput[]
    milestoneId?: IntWithAggregatesFilter<"MilestonePhoto"> | number
    photoId?: IntWithAggregatesFilter<"MilestonePhoto"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MilestonePhoto"> | Date | string
  }

  export type AlbumAccessWhereInput = {
    AND?: AlbumAccessWhereInput | AlbumAccessWhereInput[]
    OR?: AlbumAccessWhereInput[]
    NOT?: AlbumAccessWhereInput | AlbumAccessWhereInput[]
    id?: IntFilter<"AlbumAccess"> | number
    permissions?: StringNullableListFilter<"AlbumAccess">
    createdAt?: DateTimeFilter<"AlbumAccess"> | Date | string
    updatedAt?: DateTimeFilter<"AlbumAccess"> | Date | string
    albumId?: IntFilter<"AlbumAccess"> | number
    userId?: IntFilter<"AlbumAccess"> | number
    album?: XOR<AlbumRelationFilter, AlbumWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AlbumAccessOrderByWithRelationInput = {
    id?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    albumId?: SortOrder
    userId?: SortOrder
    album?: AlbumOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AlbumAccessWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    albumId_userId?: AlbumAccessAlbumIdUserIdCompoundUniqueInput
    AND?: AlbumAccessWhereInput | AlbumAccessWhereInput[]
    OR?: AlbumAccessWhereInput[]
    NOT?: AlbumAccessWhereInput | AlbumAccessWhereInput[]
    permissions?: StringNullableListFilter<"AlbumAccess">
    createdAt?: DateTimeFilter<"AlbumAccess"> | Date | string
    updatedAt?: DateTimeFilter<"AlbumAccess"> | Date | string
    albumId?: IntFilter<"AlbumAccess"> | number
    userId?: IntFilter<"AlbumAccess"> | number
    album?: XOR<AlbumRelationFilter, AlbumWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "albumId_userId">

  export type AlbumAccessOrderByWithAggregationInput = {
    id?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    albumId?: SortOrder
    userId?: SortOrder
    _count?: AlbumAccessCountOrderByAggregateInput
    _avg?: AlbumAccessAvgOrderByAggregateInput
    _max?: AlbumAccessMaxOrderByAggregateInput
    _min?: AlbumAccessMinOrderByAggregateInput
    _sum?: AlbumAccessSumOrderByAggregateInput
  }

  export type AlbumAccessScalarWhereWithAggregatesInput = {
    AND?: AlbumAccessScalarWhereWithAggregatesInput | AlbumAccessScalarWhereWithAggregatesInput[]
    OR?: AlbumAccessScalarWhereWithAggregatesInput[]
    NOT?: AlbumAccessScalarWhereWithAggregatesInput | AlbumAccessScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AlbumAccess"> | number
    permissions?: StringNullableListFilter<"AlbumAccess">
    createdAt?: DateTimeWithAggregatesFilter<"AlbumAccess"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AlbumAccess"> | Date | string
    albumId?: IntWithAggregatesFilter<"AlbumAccess"> | number
    userId?: IntWithAggregatesFilter<"AlbumAccess"> | number
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: IntFilter<"Post"> | number
    title?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    authorId?: IntFilter<"Post"> | number
    author?: XOR<UserRelationFilter, UserWhereInput>
    comments?: CommentListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    author?: UserOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    title?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    authorId?: IntFilter<"Post"> | number
    author?: XOR<UserRelationFilter, UserWhereInput>
    comments?: CommentListRelationFilter
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Post"> | number
    title?: StringWithAggregatesFilter<"Post"> | string
    content?: StringWithAggregatesFilter<"Post"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    authorId?: IntWithAggregatesFilter<"Post"> | number
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: IntFilter<"Comment"> | number
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    postId?: IntFilter<"Comment"> | number
    authorId?: IntFilter<"Comment"> | number
    post?: XOR<PostRelationFilter, PostWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    post?: PostOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    postId?: IntFilter<"Comment"> | number
    authorId?: IntFilter<"Comment"> | number
    post?: XOR<PostRelationFilter, PostWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comment"> | number
    content?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    postId?: IntWithAggregatesFilter<"Comment"> | number
    authorId?: IntWithAggregatesFilter<"Comment"> | number
  }

  export type ParentInviteWhereInput = {
    AND?: ParentInviteWhereInput | ParentInviteWhereInput[]
    OR?: ParentInviteWhereInput[]
    NOT?: ParentInviteWhereInput | ParentInviteWhereInput[]
    id?: IntFilter<"ParentInvite"> | number
    email?: StringFilter<"ParentInvite"> | string
    babyId?: IntFilter<"ParentInvite"> | number
    senderId?: IntFilter<"ParentInvite"> | number
    status?: StringFilter<"ParentInvite"> | string
    createdAt?: DateTimeFilter<"ParentInvite"> | Date | string
    updatedAt?: DateTimeFilter<"ParentInvite"> | Date | string
    baby?: XOR<BabyRelationFilter, BabyWhereInput>
    sentBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ParentInviteOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    babyId?: SortOrder
    senderId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    baby?: BabyOrderByWithRelationInput
    sentBy?: UserOrderByWithRelationInput
  }

  export type ParentInviteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email_babyId?: ParentInviteEmailBabyIdCompoundUniqueInput
    AND?: ParentInviteWhereInput | ParentInviteWhereInput[]
    OR?: ParentInviteWhereInput[]
    NOT?: ParentInviteWhereInput | ParentInviteWhereInput[]
    email?: StringFilter<"ParentInvite"> | string
    babyId?: IntFilter<"ParentInvite"> | number
    senderId?: IntFilter<"ParentInvite"> | number
    status?: StringFilter<"ParentInvite"> | string
    createdAt?: DateTimeFilter<"ParentInvite"> | Date | string
    updatedAt?: DateTimeFilter<"ParentInvite"> | Date | string
    baby?: XOR<BabyRelationFilter, BabyWhereInput>
    sentBy?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "email_babyId">

  export type ParentInviteOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    babyId?: SortOrder
    senderId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ParentInviteCountOrderByAggregateInput
    _avg?: ParentInviteAvgOrderByAggregateInput
    _max?: ParentInviteMaxOrderByAggregateInput
    _min?: ParentInviteMinOrderByAggregateInput
    _sum?: ParentInviteSumOrderByAggregateInput
  }

  export type ParentInviteScalarWhereWithAggregatesInput = {
    AND?: ParentInviteScalarWhereWithAggregatesInput | ParentInviteScalarWhereWithAggregatesInput[]
    OR?: ParentInviteScalarWhereWithAggregatesInput[]
    NOT?: ParentInviteScalarWhereWithAggregatesInput | ParentInviteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ParentInvite"> | number
    email?: StringWithAggregatesFilter<"ParentInvite"> | string
    babyId?: IntWithAggregatesFilter<"ParentInvite"> | number
    senderId?: IntWithAggregatesFilter<"ParentInvite"> | number
    status?: StringWithAggregatesFilter<"ParentInvite"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ParentInvite"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ParentInvite"> | Date | string
  }

  export type UserCreateInput = {
    email: string
    passwordHash: string
    firstName?: string
    lastName?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babies?: BabyCaregiverCreateNestedManyWithoutUserInput
    ownedBabies?: BabyCreateNestedManyWithoutOwnerInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    ParentInvite?: ParentInviteCreateNestedManyWithoutSentByInput
    AlbumAccess?: AlbumAccessCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    passwordHash: string
    firstName?: string
    lastName?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babies?: BabyCaregiverUncheckedCreateNestedManyWithoutUserInput
    ownedBabies?: BabyUncheckedCreateNestedManyWithoutOwnerInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ParentInvite?: ParentInviteUncheckedCreateNestedManyWithoutSentByInput
    AlbumAccess?: AlbumAccessUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babies?: BabyCaregiverUpdateManyWithoutUserNestedInput
    ownedBabies?: BabyUpdateManyWithoutOwnerNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    ParentInvite?: ParentInviteUpdateManyWithoutSentByNestedInput
    AlbumAccess?: AlbumAccessUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babies?: BabyCaregiverUncheckedUpdateManyWithoutUserNestedInput
    ownedBabies?: BabyUncheckedUpdateManyWithoutOwnerNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    ParentInvite?: ParentInviteUncheckedUpdateManyWithoutSentByNestedInput
    AlbumAccess?: AlbumAccessUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    passwordHash: string
    firstName?: string
    lastName?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BabyCreateInput = {
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedBabiesInput
    caregivers?: BabyCaregiverCreateNestedManyWithoutBabyInput
    eliminations?: EliminationCreateNestedManyWithoutBabyInput
    feedings?: FeedingCreateNestedManyWithoutBabyInput
    sleepsleepSessions?: SleepCreateNestedManyWithoutBabyInput
    activities?: ActivityCreateNestedManyWithoutBabyInput
    photos?: BabyPhotoCreateNestedManyWithoutBabyInput
    milestones?: MilestoneCreateNestedManyWithoutBabyInput
    healthRecords?: HealthRecordCreateNestedManyWithoutBabyInput
    measurements?: MeasurementCreateNestedManyWithoutBabyInput
    albums?: AlbumCreateNestedManyWithoutBabyInput
    parentInvites?: ParentInviteCreateNestedManyWithoutBabyInput
  }

  export type BabyUncheckedCreateInput = {
    id?: number
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: number
    caregivers?: BabyCaregiverUncheckedCreateNestedManyWithoutBabyInput
    eliminations?: EliminationUncheckedCreateNestedManyWithoutBabyInput
    feedings?: FeedingUncheckedCreateNestedManyWithoutBabyInput
    sleepsleepSessions?: SleepUncheckedCreateNestedManyWithoutBabyInput
    activities?: ActivityUncheckedCreateNestedManyWithoutBabyInput
    photos?: BabyPhotoUncheckedCreateNestedManyWithoutBabyInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutBabyInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutBabyInput
    measurements?: MeasurementUncheckedCreateNestedManyWithoutBabyInput
    albums?: AlbumUncheckedCreateNestedManyWithoutBabyInput
    parentInvites?: ParentInviteUncheckedCreateNestedManyWithoutBabyInput
  }

  export type BabyUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedBabiesNestedInput
    caregivers?: BabyCaregiverUpdateManyWithoutBabyNestedInput
    eliminations?: EliminationUpdateManyWithoutBabyNestedInput
    feedings?: FeedingUpdateManyWithoutBabyNestedInput
    sleepsleepSessions?: SleepUpdateManyWithoutBabyNestedInput
    activities?: ActivityUpdateManyWithoutBabyNestedInput
    photos?: BabyPhotoUpdateManyWithoutBabyNestedInput
    milestones?: MilestoneUpdateManyWithoutBabyNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutBabyNestedInput
    measurements?: MeasurementUpdateManyWithoutBabyNestedInput
    albums?: AlbumUpdateManyWithoutBabyNestedInput
    parentInvites?: ParentInviteUpdateManyWithoutBabyNestedInput
  }

  export type BabyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: IntFieldUpdateOperationsInput | number
    caregivers?: BabyCaregiverUncheckedUpdateManyWithoutBabyNestedInput
    eliminations?: EliminationUncheckedUpdateManyWithoutBabyNestedInput
    feedings?: FeedingUncheckedUpdateManyWithoutBabyNestedInput
    sleepsleepSessions?: SleepUncheckedUpdateManyWithoutBabyNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutBabyNestedInput
    photos?: BabyPhotoUncheckedUpdateManyWithoutBabyNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutBabyNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutBabyNestedInput
    measurements?: MeasurementUncheckedUpdateManyWithoutBabyNestedInput
    albums?: AlbumUncheckedUpdateManyWithoutBabyNestedInput
    parentInvites?: ParentInviteUncheckedUpdateManyWithoutBabyNestedInput
  }

  export type BabyCreateManyInput = {
    id?: number
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: number
  }

  export type BabyUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BabyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: IntFieldUpdateOperationsInput | number
  }

  export type BabyCaregiverCreateInput = {
    relationship: string
    permissions?: BabyCaregiverCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    baby: BabyCreateNestedOneWithoutCaregiversInput
    user: UserCreateNestedOneWithoutBabiesInput
  }

  export type BabyCaregiverUncheckedCreateInput = {
    id?: number
    relationship: string
    permissions?: BabyCaregiverCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    babyId: number
    userId: number
  }

  export type BabyCaregiverUpdateInput = {
    relationship?: StringFieldUpdateOperationsInput | string
    permissions?: BabyCaregiverUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baby?: BabyUpdateOneRequiredWithoutCaregiversNestedInput
    user?: UserUpdateOneRequiredWithoutBabiesNestedInput
  }

  export type BabyCaregiverUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    relationship?: StringFieldUpdateOperationsInput | string
    permissions?: BabyCaregiverUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type BabyCaregiverCreateManyInput = {
    id?: number
    relationship: string
    permissions?: BabyCaregiverCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    babyId: number
    userId: number
  }

  export type BabyCaregiverUpdateManyMutationInput = {
    relationship?: StringFieldUpdateOperationsInput | string
    permissions?: BabyCaregiverUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BabyCaregiverUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    relationship?: StringFieldUpdateOperationsInput | string
    permissions?: BabyCaregiverUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type EliminationCreateInput = {
    timestamp: Date | string
    type: string
    weight?: number | null
    success: boolean
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    baby: BabyCreateNestedOneWithoutEliminationsInput
  }

  export type EliminationUncheckedCreateInput = {
    id?: number
    timestamp: Date | string
    type: string
    weight?: number | null
    success: boolean
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babyId: number
  }

  export type EliminationUpdateInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baby?: BabyUpdateOneRequiredWithoutEliminationsNestedInput
  }

  export type EliminationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyId?: IntFieldUpdateOperationsInput | number
  }

  export type EliminationCreateManyInput = {
    id?: number
    timestamp: Date | string
    type: string
    weight?: number | null
    success: boolean
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babyId: number
  }

  export type EliminationUpdateManyMutationInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EliminationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyId?: IntFieldUpdateOperationsInput | number
  }

  export type FeedingCreateInput = {
    startTime: Date | string
    endTime?: Date | string | null
    type: string
    side?: string | null
    amount?: number | null
    food?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    baby: BabyCreateNestedOneWithoutFeedingsInput
  }

  export type FeedingUncheckedCreateInput = {
    id?: number
    startTime: Date | string
    endTime?: Date | string | null
    type: string
    side?: string | null
    amount?: number | null
    food?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babyId: number
  }

  export type FeedingUpdateInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    side?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    food?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baby?: BabyUpdateOneRequiredWithoutFeedingsNestedInput
  }

  export type FeedingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    side?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    food?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyId?: IntFieldUpdateOperationsInput | number
  }

  export type FeedingCreateManyInput = {
    id?: number
    startTime: Date | string
    endTime?: Date | string | null
    type: string
    side?: string | null
    amount?: number | null
    food?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babyId: number
  }

  export type FeedingUpdateManyMutationInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    side?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    food?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    side?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    food?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyId?: IntFieldUpdateOperationsInput | number
  }

  export type SleepCreateInput = {
    startTime: Date | string
    endTime?: Date | string | null
    how?: string | null
    whereFellAsleep?: string | null
    whereSlept?: string | null
    type: string
    quality?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    baby: BabyCreateNestedOneWithoutSleepsleepSessionsInput
  }

  export type SleepUncheckedCreateInput = {
    id?: number
    startTime: Date | string
    endTime?: Date | string | null
    how?: string | null
    whereFellAsleep?: string | null
    whereSlept?: string | null
    type: string
    quality?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babyId: number
  }

  export type SleepUpdateInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    how?: NullableStringFieldUpdateOperationsInput | string | null
    whereFellAsleep?: NullableStringFieldUpdateOperationsInput | string | null
    whereSlept?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baby?: BabyUpdateOneRequiredWithoutSleepsleepSessionsNestedInput
  }

  export type SleepUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    how?: NullableStringFieldUpdateOperationsInput | string | null
    whereFellAsleep?: NullableStringFieldUpdateOperationsInput | string | null
    whereSlept?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyId?: IntFieldUpdateOperationsInput | number
  }

  export type SleepCreateManyInput = {
    id?: number
    startTime: Date | string
    endTime?: Date | string | null
    how?: string | null
    whereFellAsleep?: string | null
    whereSlept?: string | null
    type: string
    quality?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babyId: number
  }

  export type SleepUpdateManyMutationInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    how?: NullableStringFieldUpdateOperationsInput | string | null
    whereFellAsleep?: NullableStringFieldUpdateOperationsInput | string | null
    whereSlept?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SleepUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    how?: NullableStringFieldUpdateOperationsInput | string | null
    whereFellAsleep?: NullableStringFieldUpdateOperationsInput | string | null
    whereSlept?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyId?: IntFieldUpdateOperationsInput | number
  }

  export type ActivityCreateInput = {
    startTime: Date | string
    endTime?: Date | string | null
    type: string
    description?: string | null
    milestone?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    baby: BabyCreateNestedOneWithoutActivitiesInput
    photos?: ActivityPhotoCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: number
    startTime: Date | string
    endTime?: Date | string | null
    type: string
    description?: string | null
    milestone?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babyId: number
    photos?: ActivityPhotoUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityUpdateInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    milestone?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baby?: BabyUpdateOneRequiredWithoutActivitiesNestedInput
    photos?: ActivityPhotoUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    milestone?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyId?: IntFieldUpdateOperationsInput | number
    photos?: ActivityPhotoUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityCreateManyInput = {
    id?: number
    startTime: Date | string
    endTime?: Date | string | null
    type: string
    description?: string | null
    milestone?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babyId: number
  }

  export type ActivityUpdateManyMutationInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    milestone?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    milestone?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyId?: IntFieldUpdateOperationsInput | number
  }

  export type MilestoneCreateInput = {
    date: Date | string
    category: string
    title: string
    description?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    baby: BabyCreateNestedOneWithoutMilestonesInput
    photos?: MilestonePhotoCreateNestedManyWithoutMilestoneInput
  }

  export type MilestoneUncheckedCreateInput = {
    id?: number
    date: Date | string
    category: string
    title: string
    description?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babyId: number
    photos?: MilestonePhotoUncheckedCreateNestedManyWithoutMilestoneInput
  }

  export type MilestoneUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baby?: BabyUpdateOneRequiredWithoutMilestonesNestedInput
    photos?: MilestonePhotoUpdateManyWithoutMilestoneNestedInput
  }

  export type MilestoneUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyId?: IntFieldUpdateOperationsInput | number
    photos?: MilestonePhotoUncheckedUpdateManyWithoutMilestoneNestedInput
  }

  export type MilestoneCreateManyInput = {
    id?: number
    date: Date | string
    category: string
    title: string
    description?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babyId: number
  }

  export type MilestoneUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyId?: IntFieldUpdateOperationsInput | number
  }

  export type HealthRecordCreateInput = {
    timestamp: Date | string
    type: string
    value?: number | null
    description?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    baby: BabyCreateNestedOneWithoutHealthRecordsInput
  }

  export type HealthRecordUncheckedCreateInput = {
    id?: number
    timestamp: Date | string
    type: string
    value?: number | null
    description?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babyId: number
  }

  export type HealthRecordUpdateInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baby?: BabyUpdateOneRequiredWithoutHealthRecordsNestedInput
  }

  export type HealthRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyId?: IntFieldUpdateOperationsInput | number
  }

  export type HealthRecordCreateManyInput = {
    id?: number
    timestamp: Date | string
    type: string
    value?: number | null
    description?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babyId: number
  }

  export type HealthRecordUpdateManyMutationInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyId?: IntFieldUpdateOperationsInput | number
  }

  export type MeasurementCreateInput = {
    date: Date | string
    weight?: number | null
    height?: number | null
    headCirc?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    baby: BabyCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateInput = {
    id?: number
    date: Date | string
    weight?: number | null
    height?: number | null
    headCirc?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babyId: number
  }

  export type MeasurementUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    headCirc?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baby?: BabyUpdateOneRequiredWithoutMeasurementsNestedInput
  }

  export type MeasurementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    headCirc?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyId?: IntFieldUpdateOperationsInput | number
  }

  export type MeasurementCreateManyInput = {
    id?: number
    date: Date | string
    weight?: number | null
    height?: number | null
    headCirc?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babyId: number
  }

  export type MeasurementUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    headCirc?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeasurementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    headCirc?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyId?: IntFieldUpdateOperationsInput | number
  }

  export type AlbumCreateInput = {
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    baby: BabyCreateNestedOneWithoutAlbumsInput
    photos?: AlbumPhotoCreateNestedManyWithoutAlbumInput
    access?: AlbumAccessCreateNestedManyWithoutAlbumInput
  }

  export type AlbumUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babyId: number
    photos?: AlbumPhotoUncheckedCreateNestedManyWithoutAlbumInput
    access?: AlbumAccessUncheckedCreateNestedManyWithoutAlbumInput
  }

  export type AlbumUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baby?: BabyUpdateOneRequiredWithoutAlbumsNestedInput
    photos?: AlbumPhotoUpdateManyWithoutAlbumNestedInput
    access?: AlbumAccessUpdateManyWithoutAlbumNestedInput
  }

  export type AlbumUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyId?: IntFieldUpdateOperationsInput | number
    photos?: AlbumPhotoUncheckedUpdateManyWithoutAlbumNestedInput
    access?: AlbumAccessUncheckedUpdateManyWithoutAlbumNestedInput
  }

  export type AlbumCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babyId: number
  }

  export type AlbumUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlbumUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyId?: IntFieldUpdateOperationsInput | number
  }

  export type PhotoCreateInput = {
    url: string
    caption?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    babyPhotos?: BabyPhotoCreateNestedManyWithoutPhotoInput
    albumPhotos?: AlbumPhotoCreateNestedManyWithoutPhotoInput
    activityPhotos?: ActivityPhotoCreateNestedManyWithoutPhotoInput
    milestonePhotos?: MilestonePhotoCreateNestedManyWithoutPhotoInput
  }

  export type PhotoUncheckedCreateInput = {
    id?: number
    url: string
    caption?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    babyPhotos?: BabyPhotoUncheckedCreateNestedManyWithoutPhotoInput
    albumPhotos?: AlbumPhotoUncheckedCreateNestedManyWithoutPhotoInput
    activityPhotos?: ActivityPhotoUncheckedCreateNestedManyWithoutPhotoInput
    milestonePhotos?: MilestonePhotoUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type PhotoUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyPhotos?: BabyPhotoUpdateManyWithoutPhotoNestedInput
    albumPhotos?: AlbumPhotoUpdateManyWithoutPhotoNestedInput
    activityPhotos?: ActivityPhotoUpdateManyWithoutPhotoNestedInput
    milestonePhotos?: MilestonePhotoUpdateManyWithoutPhotoNestedInput
  }

  export type PhotoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyPhotos?: BabyPhotoUncheckedUpdateManyWithoutPhotoNestedInput
    albumPhotos?: AlbumPhotoUncheckedUpdateManyWithoutPhotoNestedInput
    activityPhotos?: ActivityPhotoUncheckedUpdateManyWithoutPhotoNestedInput
    milestonePhotos?: MilestonePhotoUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type PhotoCreateManyInput = {
    id?: number
    url: string
    caption?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhotoUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BabyPhotoCreateInput = {
    createdAt?: Date | string
    baby: BabyCreateNestedOneWithoutPhotosInput
    photo: PhotoCreateNestedOneWithoutBabyPhotosInput
  }

  export type BabyPhotoUncheckedCreateInput = {
    babyId: number
    photoId: number
    createdAt?: Date | string
  }

  export type BabyPhotoUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baby?: BabyUpdateOneRequiredWithoutPhotosNestedInput
    photo?: PhotoUpdateOneRequiredWithoutBabyPhotosNestedInput
  }

  export type BabyPhotoUncheckedUpdateInput = {
    babyId?: IntFieldUpdateOperationsInput | number
    photoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BabyPhotoCreateManyInput = {
    babyId: number
    photoId: number
    createdAt?: Date | string
  }

  export type BabyPhotoUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BabyPhotoUncheckedUpdateManyInput = {
    babyId?: IntFieldUpdateOperationsInput | number
    photoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlbumPhotoCreateInput = {
    createdAt?: Date | string
    album: AlbumCreateNestedOneWithoutPhotosInput
    photo: PhotoCreateNestedOneWithoutAlbumPhotosInput
  }

  export type AlbumPhotoUncheckedCreateInput = {
    albumId: number
    photoId: number
    createdAt?: Date | string
  }

  export type AlbumPhotoUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    album?: AlbumUpdateOneRequiredWithoutPhotosNestedInput
    photo?: PhotoUpdateOneRequiredWithoutAlbumPhotosNestedInput
  }

  export type AlbumPhotoUncheckedUpdateInput = {
    albumId?: IntFieldUpdateOperationsInput | number
    photoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlbumPhotoCreateManyInput = {
    albumId: number
    photoId: number
    createdAt?: Date | string
  }

  export type AlbumPhotoUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlbumPhotoUncheckedUpdateManyInput = {
    albumId?: IntFieldUpdateOperationsInput | number
    photoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityPhotoCreateInput = {
    createdAt?: Date | string
    activity: ActivityCreateNestedOneWithoutPhotosInput
    photo: PhotoCreateNestedOneWithoutActivityPhotosInput
  }

  export type ActivityPhotoUncheckedCreateInput = {
    activityId: number
    photoId: number
    createdAt?: Date | string
  }

  export type ActivityPhotoUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneRequiredWithoutPhotosNestedInput
    photo?: PhotoUpdateOneRequiredWithoutActivityPhotosNestedInput
  }

  export type ActivityPhotoUncheckedUpdateInput = {
    activityId?: IntFieldUpdateOperationsInput | number
    photoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityPhotoCreateManyInput = {
    activityId: number
    photoId: number
    createdAt?: Date | string
  }

  export type ActivityPhotoUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityPhotoUncheckedUpdateManyInput = {
    activityId?: IntFieldUpdateOperationsInput | number
    photoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestonePhotoCreateInput = {
    createdAt?: Date | string
    milestone: MilestoneCreateNestedOneWithoutPhotosInput
    photo: PhotoCreateNestedOneWithoutMilestonePhotosInput
  }

  export type MilestonePhotoUncheckedCreateInput = {
    milestoneId: number
    photoId: number
    createdAt?: Date | string
  }

  export type MilestonePhotoUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestone?: MilestoneUpdateOneRequiredWithoutPhotosNestedInput
    photo?: PhotoUpdateOneRequiredWithoutMilestonePhotosNestedInput
  }

  export type MilestonePhotoUncheckedUpdateInput = {
    milestoneId?: IntFieldUpdateOperationsInput | number
    photoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestonePhotoCreateManyInput = {
    milestoneId: number
    photoId: number
    createdAt?: Date | string
  }

  export type MilestonePhotoUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestonePhotoUncheckedUpdateManyInput = {
    milestoneId?: IntFieldUpdateOperationsInput | number
    photoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlbumAccessCreateInput = {
    permissions?: AlbumAccessCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    album: AlbumCreateNestedOneWithoutAccessInput
    user: UserCreateNestedOneWithoutAlbumAccessInput
  }

  export type AlbumAccessUncheckedCreateInput = {
    id?: number
    permissions?: AlbumAccessCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    albumId: number
    userId: number
  }

  export type AlbumAccessUpdateInput = {
    permissions?: AlbumAccessUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    album?: AlbumUpdateOneRequiredWithoutAccessNestedInput
    user?: UserUpdateOneRequiredWithoutAlbumAccessNestedInput
  }

  export type AlbumAccessUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissions?: AlbumAccessUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albumId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type AlbumAccessCreateManyInput = {
    id?: number
    permissions?: AlbumAccessCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    albumId: number
    userId: number
  }

  export type AlbumAccessUpdateManyMutationInput = {
    permissions?: AlbumAccessUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlbumAccessUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissions?: AlbumAccessUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albumId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type PostCreateInput = {
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: number
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: number
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: number
  }

  export type PostUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: IntFieldUpdateOperationsInput | number
  }

  export type CommentCreateInput = {
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postId: number
    authorId: number
  }

  export type CommentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
  }

  export type CommentCreateManyInput = {
    id?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postId: number
    authorId: number
  }

  export type CommentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
  }

  export type ParentInviteCreateInput = {
    email: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    baby: BabyCreateNestedOneWithoutParentInvitesInput
    sentBy: UserCreateNestedOneWithoutParentInviteInput
  }

  export type ParentInviteUncheckedCreateInput = {
    id?: number
    email: string
    babyId: number
    senderId: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentInviteUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baby?: BabyUpdateOneRequiredWithoutParentInvitesNestedInput
    sentBy?: UserUpdateOneRequiredWithoutParentInviteNestedInput
  }

  export type ParentInviteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    babyId?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentInviteCreateManyInput = {
    id?: number
    email: string
    babyId: number
    senderId: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentInviteUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentInviteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    babyId?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BabyCaregiverListRelationFilter = {
    every?: BabyCaregiverWhereInput
    some?: BabyCaregiverWhereInput
    none?: BabyCaregiverWhereInput
  }

  export type BabyListRelationFilter = {
    every?: BabyWhereInput
    some?: BabyWhereInput
    none?: BabyWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type ParentInviteListRelationFilter = {
    every?: ParentInviteWhereInput
    some?: ParentInviteWhereInput
    none?: ParentInviteWhereInput
  }

  export type AlbumAccessListRelationFilter = {
    every?: AlbumAccessWhereInput
    some?: AlbumAccessWhereInput
    none?: AlbumAccessWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BabyCaregiverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BabyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParentInviteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlbumAccessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type EliminationListRelationFilter = {
    every?: EliminationWhereInput
    some?: EliminationWhereInput
    none?: EliminationWhereInput
  }

  export type FeedingListRelationFilter = {
    every?: FeedingWhereInput
    some?: FeedingWhereInput
    none?: FeedingWhereInput
  }

  export type SleepListRelationFilter = {
    every?: SleepWhereInput
    some?: SleepWhereInput
    none?: SleepWhereInput
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type BabyPhotoListRelationFilter = {
    every?: BabyPhotoWhereInput
    some?: BabyPhotoWhereInput
    none?: BabyPhotoWhereInput
  }

  export type MilestoneListRelationFilter = {
    every?: MilestoneWhereInput
    some?: MilestoneWhereInput
    none?: MilestoneWhereInput
  }

  export type HealthRecordListRelationFilter = {
    every?: HealthRecordWhereInput
    some?: HealthRecordWhereInput
    none?: HealthRecordWhereInput
  }

  export type MeasurementListRelationFilter = {
    every?: MeasurementWhereInput
    some?: MeasurementWhereInput
    none?: MeasurementWhereInput
  }

  export type AlbumListRelationFilter = {
    every?: AlbumWhereInput
    some?: AlbumWhereInput
    none?: AlbumWhereInput
  }

  export type EliminationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SleepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BabyPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MilestoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HealthRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MeasurementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlbumOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BabyCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
  }

  export type BabyAvgOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
  }

  export type BabyMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
  }

  export type BabyMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
  }

  export type BabySumOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BabyRelationFilter = {
    is?: BabyWhereInput
    isNot?: BabyWhereInput
  }

  export type BabyCaregiverBabyIdUserIdCompoundUniqueInput = {
    babyId: number
    userId: number
  }

  export type BabyCaregiverCountOrderByAggregateInput = {
    id?: SortOrder
    relationship?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
    userId?: SortOrder
  }

  export type BabyCaregiverAvgOrderByAggregateInput = {
    id?: SortOrder
    babyId?: SortOrder
    userId?: SortOrder
  }

  export type BabyCaregiverMaxOrderByAggregateInput = {
    id?: SortOrder
    relationship?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
    userId?: SortOrder
  }

  export type BabyCaregiverMinOrderByAggregateInput = {
    id?: SortOrder
    relationship?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
    userId?: SortOrder
  }

  export type BabyCaregiverSumOrderByAggregateInput = {
    id?: SortOrder
    babyId?: SortOrder
    userId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EliminationCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    weight?: SortOrder
    success?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
  }

  export type EliminationAvgOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    babyId?: SortOrder
  }

  export type EliminationMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    weight?: SortOrder
    success?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
  }

  export type EliminationMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    weight?: SortOrder
    success?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
  }

  export type EliminationSumOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    babyId?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FeedingCountOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    side?: SortOrder
    amount?: SortOrder
    food?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
  }

  export type FeedingAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    babyId?: SortOrder
  }

  export type FeedingMaxOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    side?: SortOrder
    amount?: SortOrder
    food?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
  }

  export type FeedingMinOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    side?: SortOrder
    amount?: SortOrder
    food?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
  }

  export type FeedingSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    babyId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SleepCountOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    how?: SortOrder
    whereFellAsleep?: SortOrder
    whereSlept?: SortOrder
    type?: SortOrder
    quality?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
  }

  export type SleepAvgOrderByAggregateInput = {
    id?: SortOrder
    quality?: SortOrder
    babyId?: SortOrder
  }

  export type SleepMaxOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    how?: SortOrder
    whereFellAsleep?: SortOrder
    whereSlept?: SortOrder
    type?: SortOrder
    quality?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
  }

  export type SleepMinOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    how?: SortOrder
    whereFellAsleep?: SortOrder
    whereSlept?: SortOrder
    type?: SortOrder
    quality?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
  }

  export type SleepSumOrderByAggregateInput = {
    id?: SortOrder
    quality?: SortOrder
    babyId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ActivityPhotoListRelationFilter = {
    every?: ActivityPhotoWhereInput
    some?: ActivityPhotoWhereInput
    none?: ActivityPhotoWhereInput
  }

  export type ActivityPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    description?: SortOrder
    milestone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
  }

  export type ActivityAvgOrderByAggregateInput = {
    id?: SortOrder
    babyId?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    description?: SortOrder
    milestone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    description?: SortOrder
    milestone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
  }

  export type ActivitySumOrderByAggregateInput = {
    id?: SortOrder
    babyId?: SortOrder
  }

  export type MilestonePhotoListRelationFilter = {
    every?: MilestonePhotoWhereInput
    some?: MilestonePhotoWhereInput
    none?: MilestonePhotoWhereInput
  }

  export type MilestonePhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MilestoneCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
  }

  export type MilestoneAvgOrderByAggregateInput = {
    id?: SortOrder
    babyId?: SortOrder
  }

  export type MilestoneMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
  }

  export type MilestoneMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
  }

  export type MilestoneSumOrderByAggregateInput = {
    id?: SortOrder
    babyId?: SortOrder
  }

  export type HealthRecordCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    value?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
  }

  export type HealthRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    babyId?: SortOrder
  }

  export type HealthRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    value?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
  }

  export type HealthRecordMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    value?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
  }

  export type HealthRecordSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    babyId?: SortOrder
  }

  export type MeasurementCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    weight?: SortOrder
    height?: SortOrder
    headCirc?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
  }

  export type MeasurementAvgOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    height?: SortOrder
    headCirc?: SortOrder
    babyId?: SortOrder
  }

  export type MeasurementMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    weight?: SortOrder
    height?: SortOrder
    headCirc?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
  }

  export type MeasurementMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    weight?: SortOrder
    height?: SortOrder
    headCirc?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
  }

  export type MeasurementSumOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    height?: SortOrder
    headCirc?: SortOrder
    babyId?: SortOrder
  }

  export type AlbumPhotoListRelationFilter = {
    every?: AlbumPhotoWhereInput
    some?: AlbumPhotoWhereInput
    none?: AlbumPhotoWhereInput
  }

  export type AlbumPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlbumCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
  }

  export type AlbumAvgOrderByAggregateInput = {
    id?: SortOrder
    babyId?: SortOrder
  }

  export type AlbumMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
  }

  export type AlbumMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    babyId?: SortOrder
  }

  export type AlbumSumOrderByAggregateInput = {
    id?: SortOrder
    babyId?: SortOrder
  }

  export type PhotoCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    caption?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhotoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    caption?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhotoMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    caption?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhotoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PhotoRelationFilter = {
    is?: PhotoWhereInput
    isNot?: PhotoWhereInput
  }

  export type BabyPhotoBabyIdPhotoIdCompoundUniqueInput = {
    babyId: number
    photoId: number
  }

  export type BabyPhotoCountOrderByAggregateInput = {
    babyId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
  }

  export type BabyPhotoAvgOrderByAggregateInput = {
    babyId?: SortOrder
    photoId?: SortOrder
  }

  export type BabyPhotoMaxOrderByAggregateInput = {
    babyId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
  }

  export type BabyPhotoMinOrderByAggregateInput = {
    babyId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
  }

  export type BabyPhotoSumOrderByAggregateInput = {
    babyId?: SortOrder
    photoId?: SortOrder
  }

  export type AlbumRelationFilter = {
    is?: AlbumWhereInput
    isNot?: AlbumWhereInput
  }

  export type AlbumPhotoAlbumIdPhotoIdCompoundUniqueInput = {
    albumId: number
    photoId: number
  }

  export type AlbumPhotoCountOrderByAggregateInput = {
    albumId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
  }

  export type AlbumPhotoAvgOrderByAggregateInput = {
    albumId?: SortOrder
    photoId?: SortOrder
  }

  export type AlbumPhotoMaxOrderByAggregateInput = {
    albumId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
  }

  export type AlbumPhotoMinOrderByAggregateInput = {
    albumId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
  }

  export type AlbumPhotoSumOrderByAggregateInput = {
    albumId?: SortOrder
    photoId?: SortOrder
  }

  export type ActivityRelationFilter = {
    is?: ActivityWhereInput
    isNot?: ActivityWhereInput
  }

  export type ActivityPhotoActivityIdPhotoIdCompoundUniqueInput = {
    activityId: number
    photoId: number
  }

  export type ActivityPhotoCountOrderByAggregateInput = {
    activityId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityPhotoAvgOrderByAggregateInput = {
    activityId?: SortOrder
    photoId?: SortOrder
  }

  export type ActivityPhotoMaxOrderByAggregateInput = {
    activityId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityPhotoMinOrderByAggregateInput = {
    activityId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityPhotoSumOrderByAggregateInput = {
    activityId?: SortOrder
    photoId?: SortOrder
  }

  export type MilestoneRelationFilter = {
    is?: MilestoneWhereInput
    isNot?: MilestoneWhereInput
  }

  export type MilestonePhotoMilestoneIdPhotoIdCompoundUniqueInput = {
    milestoneId: number
    photoId: number
  }

  export type MilestonePhotoCountOrderByAggregateInput = {
    milestoneId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
  }

  export type MilestonePhotoAvgOrderByAggregateInput = {
    milestoneId?: SortOrder
    photoId?: SortOrder
  }

  export type MilestonePhotoMaxOrderByAggregateInput = {
    milestoneId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
  }

  export type MilestonePhotoMinOrderByAggregateInput = {
    milestoneId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
  }

  export type MilestonePhotoSumOrderByAggregateInput = {
    milestoneId?: SortOrder
    photoId?: SortOrder
  }

  export type AlbumAccessAlbumIdUserIdCompoundUniqueInput = {
    albumId: number
    userId: number
  }

  export type AlbumAccessCountOrderByAggregateInput = {
    id?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    albumId?: SortOrder
    userId?: SortOrder
  }

  export type AlbumAccessAvgOrderByAggregateInput = {
    id?: SortOrder
    albumId?: SortOrder
    userId?: SortOrder
  }

  export type AlbumAccessMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    albumId?: SortOrder
    userId?: SortOrder
  }

  export type AlbumAccessMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    albumId?: SortOrder
    userId?: SortOrder
  }

  export type AlbumAccessSumOrderByAggregateInput = {
    id?: SortOrder
    albumId?: SortOrder
    userId?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
  }

  export type PostRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
  }

  export type ParentInviteEmailBabyIdCompoundUniqueInput = {
    email: string
    babyId: number
  }

  export type ParentInviteCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    babyId?: SortOrder
    senderId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentInviteAvgOrderByAggregateInput = {
    id?: SortOrder
    babyId?: SortOrder
    senderId?: SortOrder
  }

  export type ParentInviteMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    babyId?: SortOrder
    senderId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentInviteMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    babyId?: SortOrder
    senderId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentInviteSumOrderByAggregateInput = {
    id?: SortOrder
    babyId?: SortOrder
    senderId?: SortOrder
  }

  export type BabyCaregiverCreateNestedManyWithoutUserInput = {
    create?: XOR<BabyCaregiverCreateWithoutUserInput, BabyCaregiverUncheckedCreateWithoutUserInput> | BabyCaregiverCreateWithoutUserInput[] | BabyCaregiverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BabyCaregiverCreateOrConnectWithoutUserInput | BabyCaregiverCreateOrConnectWithoutUserInput[]
    createMany?: BabyCaregiverCreateManyUserInputEnvelope
    connect?: BabyCaregiverWhereUniqueInput | BabyCaregiverWhereUniqueInput[]
  }

  export type BabyCreateNestedManyWithoutOwnerInput = {
    create?: XOR<BabyCreateWithoutOwnerInput, BabyUncheckedCreateWithoutOwnerInput> | BabyCreateWithoutOwnerInput[] | BabyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BabyCreateOrConnectWithoutOwnerInput | BabyCreateOrConnectWithoutOwnerInput[]
    createMany?: BabyCreateManyOwnerInputEnvelope
    connect?: BabyWhereUniqueInput | BabyWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ParentInviteCreateNestedManyWithoutSentByInput = {
    create?: XOR<ParentInviteCreateWithoutSentByInput, ParentInviteUncheckedCreateWithoutSentByInput> | ParentInviteCreateWithoutSentByInput[] | ParentInviteUncheckedCreateWithoutSentByInput[]
    connectOrCreate?: ParentInviteCreateOrConnectWithoutSentByInput | ParentInviteCreateOrConnectWithoutSentByInput[]
    createMany?: ParentInviteCreateManySentByInputEnvelope
    connect?: ParentInviteWhereUniqueInput | ParentInviteWhereUniqueInput[]
  }

  export type AlbumAccessCreateNestedManyWithoutUserInput = {
    create?: XOR<AlbumAccessCreateWithoutUserInput, AlbumAccessUncheckedCreateWithoutUserInput> | AlbumAccessCreateWithoutUserInput[] | AlbumAccessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlbumAccessCreateOrConnectWithoutUserInput | AlbumAccessCreateOrConnectWithoutUserInput[]
    createMany?: AlbumAccessCreateManyUserInputEnvelope
    connect?: AlbumAccessWhereUniqueInput | AlbumAccessWhereUniqueInput[]
  }

  export type BabyCaregiverUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BabyCaregiverCreateWithoutUserInput, BabyCaregiverUncheckedCreateWithoutUserInput> | BabyCaregiverCreateWithoutUserInput[] | BabyCaregiverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BabyCaregiverCreateOrConnectWithoutUserInput | BabyCaregiverCreateOrConnectWithoutUserInput[]
    createMany?: BabyCaregiverCreateManyUserInputEnvelope
    connect?: BabyCaregiverWhereUniqueInput | BabyCaregiverWhereUniqueInput[]
  }

  export type BabyUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<BabyCreateWithoutOwnerInput, BabyUncheckedCreateWithoutOwnerInput> | BabyCreateWithoutOwnerInput[] | BabyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BabyCreateOrConnectWithoutOwnerInput | BabyCreateOrConnectWithoutOwnerInput[]
    createMany?: BabyCreateManyOwnerInputEnvelope
    connect?: BabyWhereUniqueInput | BabyWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ParentInviteUncheckedCreateNestedManyWithoutSentByInput = {
    create?: XOR<ParentInviteCreateWithoutSentByInput, ParentInviteUncheckedCreateWithoutSentByInput> | ParentInviteCreateWithoutSentByInput[] | ParentInviteUncheckedCreateWithoutSentByInput[]
    connectOrCreate?: ParentInviteCreateOrConnectWithoutSentByInput | ParentInviteCreateOrConnectWithoutSentByInput[]
    createMany?: ParentInviteCreateManySentByInputEnvelope
    connect?: ParentInviteWhereUniqueInput | ParentInviteWhereUniqueInput[]
  }

  export type AlbumAccessUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AlbumAccessCreateWithoutUserInput, AlbumAccessUncheckedCreateWithoutUserInput> | AlbumAccessCreateWithoutUserInput[] | AlbumAccessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlbumAccessCreateOrConnectWithoutUserInput | AlbumAccessCreateOrConnectWithoutUserInput[]
    createMany?: AlbumAccessCreateManyUserInputEnvelope
    connect?: AlbumAccessWhereUniqueInput | AlbumAccessWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BabyCaregiverUpdateManyWithoutUserNestedInput = {
    create?: XOR<BabyCaregiverCreateWithoutUserInput, BabyCaregiverUncheckedCreateWithoutUserInput> | BabyCaregiverCreateWithoutUserInput[] | BabyCaregiverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BabyCaregiverCreateOrConnectWithoutUserInput | BabyCaregiverCreateOrConnectWithoutUserInput[]
    upsert?: BabyCaregiverUpsertWithWhereUniqueWithoutUserInput | BabyCaregiverUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BabyCaregiverCreateManyUserInputEnvelope
    set?: BabyCaregiverWhereUniqueInput | BabyCaregiverWhereUniqueInput[]
    disconnect?: BabyCaregiverWhereUniqueInput | BabyCaregiverWhereUniqueInput[]
    delete?: BabyCaregiverWhereUniqueInput | BabyCaregiverWhereUniqueInput[]
    connect?: BabyCaregiverWhereUniqueInput | BabyCaregiverWhereUniqueInput[]
    update?: BabyCaregiverUpdateWithWhereUniqueWithoutUserInput | BabyCaregiverUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BabyCaregiverUpdateManyWithWhereWithoutUserInput | BabyCaregiverUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BabyCaregiverScalarWhereInput | BabyCaregiverScalarWhereInput[]
  }

  export type BabyUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<BabyCreateWithoutOwnerInput, BabyUncheckedCreateWithoutOwnerInput> | BabyCreateWithoutOwnerInput[] | BabyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BabyCreateOrConnectWithoutOwnerInput | BabyCreateOrConnectWithoutOwnerInput[]
    upsert?: BabyUpsertWithWhereUniqueWithoutOwnerInput | BabyUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: BabyCreateManyOwnerInputEnvelope
    set?: BabyWhereUniqueInput | BabyWhereUniqueInput[]
    disconnect?: BabyWhereUniqueInput | BabyWhereUniqueInput[]
    delete?: BabyWhereUniqueInput | BabyWhereUniqueInput[]
    connect?: BabyWhereUniqueInput | BabyWhereUniqueInput[]
    update?: BabyUpdateWithWhereUniqueWithoutOwnerInput | BabyUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: BabyUpdateManyWithWhereWithoutOwnerInput | BabyUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: BabyScalarWhereInput | BabyScalarWhereInput[]
  }

  export type PostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ParentInviteUpdateManyWithoutSentByNestedInput = {
    create?: XOR<ParentInviteCreateWithoutSentByInput, ParentInviteUncheckedCreateWithoutSentByInput> | ParentInviteCreateWithoutSentByInput[] | ParentInviteUncheckedCreateWithoutSentByInput[]
    connectOrCreate?: ParentInviteCreateOrConnectWithoutSentByInput | ParentInviteCreateOrConnectWithoutSentByInput[]
    upsert?: ParentInviteUpsertWithWhereUniqueWithoutSentByInput | ParentInviteUpsertWithWhereUniqueWithoutSentByInput[]
    createMany?: ParentInviteCreateManySentByInputEnvelope
    set?: ParentInviteWhereUniqueInput | ParentInviteWhereUniqueInput[]
    disconnect?: ParentInviteWhereUniqueInput | ParentInviteWhereUniqueInput[]
    delete?: ParentInviteWhereUniqueInput | ParentInviteWhereUniqueInput[]
    connect?: ParentInviteWhereUniqueInput | ParentInviteWhereUniqueInput[]
    update?: ParentInviteUpdateWithWhereUniqueWithoutSentByInput | ParentInviteUpdateWithWhereUniqueWithoutSentByInput[]
    updateMany?: ParentInviteUpdateManyWithWhereWithoutSentByInput | ParentInviteUpdateManyWithWhereWithoutSentByInput[]
    deleteMany?: ParentInviteScalarWhereInput | ParentInviteScalarWhereInput[]
  }

  export type AlbumAccessUpdateManyWithoutUserNestedInput = {
    create?: XOR<AlbumAccessCreateWithoutUserInput, AlbumAccessUncheckedCreateWithoutUserInput> | AlbumAccessCreateWithoutUserInput[] | AlbumAccessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlbumAccessCreateOrConnectWithoutUserInput | AlbumAccessCreateOrConnectWithoutUserInput[]
    upsert?: AlbumAccessUpsertWithWhereUniqueWithoutUserInput | AlbumAccessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AlbumAccessCreateManyUserInputEnvelope
    set?: AlbumAccessWhereUniqueInput | AlbumAccessWhereUniqueInput[]
    disconnect?: AlbumAccessWhereUniqueInput | AlbumAccessWhereUniqueInput[]
    delete?: AlbumAccessWhereUniqueInput | AlbumAccessWhereUniqueInput[]
    connect?: AlbumAccessWhereUniqueInput | AlbumAccessWhereUniqueInput[]
    update?: AlbumAccessUpdateWithWhereUniqueWithoutUserInput | AlbumAccessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AlbumAccessUpdateManyWithWhereWithoutUserInput | AlbumAccessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AlbumAccessScalarWhereInput | AlbumAccessScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BabyCaregiverUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BabyCaregiverCreateWithoutUserInput, BabyCaregiverUncheckedCreateWithoutUserInput> | BabyCaregiverCreateWithoutUserInput[] | BabyCaregiverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BabyCaregiverCreateOrConnectWithoutUserInput | BabyCaregiverCreateOrConnectWithoutUserInput[]
    upsert?: BabyCaregiverUpsertWithWhereUniqueWithoutUserInput | BabyCaregiverUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BabyCaregiverCreateManyUserInputEnvelope
    set?: BabyCaregiverWhereUniqueInput | BabyCaregiverWhereUniqueInput[]
    disconnect?: BabyCaregiverWhereUniqueInput | BabyCaregiverWhereUniqueInput[]
    delete?: BabyCaregiverWhereUniqueInput | BabyCaregiverWhereUniqueInput[]
    connect?: BabyCaregiverWhereUniqueInput | BabyCaregiverWhereUniqueInput[]
    update?: BabyCaregiverUpdateWithWhereUniqueWithoutUserInput | BabyCaregiverUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BabyCaregiverUpdateManyWithWhereWithoutUserInput | BabyCaregiverUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BabyCaregiverScalarWhereInput | BabyCaregiverScalarWhereInput[]
  }

  export type BabyUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<BabyCreateWithoutOwnerInput, BabyUncheckedCreateWithoutOwnerInput> | BabyCreateWithoutOwnerInput[] | BabyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BabyCreateOrConnectWithoutOwnerInput | BabyCreateOrConnectWithoutOwnerInput[]
    upsert?: BabyUpsertWithWhereUniqueWithoutOwnerInput | BabyUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: BabyCreateManyOwnerInputEnvelope
    set?: BabyWhereUniqueInput | BabyWhereUniqueInput[]
    disconnect?: BabyWhereUniqueInput | BabyWhereUniqueInput[]
    delete?: BabyWhereUniqueInput | BabyWhereUniqueInput[]
    connect?: BabyWhereUniqueInput | BabyWhereUniqueInput[]
    update?: BabyUpdateWithWhereUniqueWithoutOwnerInput | BabyUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: BabyUpdateManyWithWhereWithoutOwnerInput | BabyUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: BabyScalarWhereInput | BabyScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ParentInviteUncheckedUpdateManyWithoutSentByNestedInput = {
    create?: XOR<ParentInviteCreateWithoutSentByInput, ParentInviteUncheckedCreateWithoutSentByInput> | ParentInviteCreateWithoutSentByInput[] | ParentInviteUncheckedCreateWithoutSentByInput[]
    connectOrCreate?: ParentInviteCreateOrConnectWithoutSentByInput | ParentInviteCreateOrConnectWithoutSentByInput[]
    upsert?: ParentInviteUpsertWithWhereUniqueWithoutSentByInput | ParentInviteUpsertWithWhereUniqueWithoutSentByInput[]
    createMany?: ParentInviteCreateManySentByInputEnvelope
    set?: ParentInviteWhereUniqueInput | ParentInviteWhereUniqueInput[]
    disconnect?: ParentInviteWhereUniqueInput | ParentInviteWhereUniqueInput[]
    delete?: ParentInviteWhereUniqueInput | ParentInviteWhereUniqueInput[]
    connect?: ParentInviteWhereUniqueInput | ParentInviteWhereUniqueInput[]
    update?: ParentInviteUpdateWithWhereUniqueWithoutSentByInput | ParentInviteUpdateWithWhereUniqueWithoutSentByInput[]
    updateMany?: ParentInviteUpdateManyWithWhereWithoutSentByInput | ParentInviteUpdateManyWithWhereWithoutSentByInput[]
    deleteMany?: ParentInviteScalarWhereInput | ParentInviteScalarWhereInput[]
  }

  export type AlbumAccessUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AlbumAccessCreateWithoutUserInput, AlbumAccessUncheckedCreateWithoutUserInput> | AlbumAccessCreateWithoutUserInput[] | AlbumAccessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlbumAccessCreateOrConnectWithoutUserInput | AlbumAccessCreateOrConnectWithoutUserInput[]
    upsert?: AlbumAccessUpsertWithWhereUniqueWithoutUserInput | AlbumAccessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AlbumAccessCreateManyUserInputEnvelope
    set?: AlbumAccessWhereUniqueInput | AlbumAccessWhereUniqueInput[]
    disconnect?: AlbumAccessWhereUniqueInput | AlbumAccessWhereUniqueInput[]
    delete?: AlbumAccessWhereUniqueInput | AlbumAccessWhereUniqueInput[]
    connect?: AlbumAccessWhereUniqueInput | AlbumAccessWhereUniqueInput[]
    update?: AlbumAccessUpdateWithWhereUniqueWithoutUserInput | AlbumAccessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AlbumAccessUpdateManyWithWhereWithoutUserInput | AlbumAccessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AlbumAccessScalarWhereInput | AlbumAccessScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOwnedBabiesInput = {
    create?: XOR<UserCreateWithoutOwnedBabiesInput, UserUncheckedCreateWithoutOwnedBabiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedBabiesInput
    connect?: UserWhereUniqueInput
  }

  export type BabyCaregiverCreateNestedManyWithoutBabyInput = {
    create?: XOR<BabyCaregiverCreateWithoutBabyInput, BabyCaregiverUncheckedCreateWithoutBabyInput> | BabyCaregiverCreateWithoutBabyInput[] | BabyCaregiverUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: BabyCaregiverCreateOrConnectWithoutBabyInput | BabyCaregiverCreateOrConnectWithoutBabyInput[]
    createMany?: BabyCaregiverCreateManyBabyInputEnvelope
    connect?: BabyCaregiverWhereUniqueInput | BabyCaregiverWhereUniqueInput[]
  }

  export type EliminationCreateNestedManyWithoutBabyInput = {
    create?: XOR<EliminationCreateWithoutBabyInput, EliminationUncheckedCreateWithoutBabyInput> | EliminationCreateWithoutBabyInput[] | EliminationUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: EliminationCreateOrConnectWithoutBabyInput | EliminationCreateOrConnectWithoutBabyInput[]
    createMany?: EliminationCreateManyBabyInputEnvelope
    connect?: EliminationWhereUniqueInput | EliminationWhereUniqueInput[]
  }

  export type FeedingCreateNestedManyWithoutBabyInput = {
    create?: XOR<FeedingCreateWithoutBabyInput, FeedingUncheckedCreateWithoutBabyInput> | FeedingCreateWithoutBabyInput[] | FeedingUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: FeedingCreateOrConnectWithoutBabyInput | FeedingCreateOrConnectWithoutBabyInput[]
    createMany?: FeedingCreateManyBabyInputEnvelope
    connect?: FeedingWhereUniqueInput | FeedingWhereUniqueInput[]
  }

  export type SleepCreateNestedManyWithoutBabyInput = {
    create?: XOR<SleepCreateWithoutBabyInput, SleepUncheckedCreateWithoutBabyInput> | SleepCreateWithoutBabyInput[] | SleepUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: SleepCreateOrConnectWithoutBabyInput | SleepCreateOrConnectWithoutBabyInput[]
    createMany?: SleepCreateManyBabyInputEnvelope
    connect?: SleepWhereUniqueInput | SleepWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutBabyInput = {
    create?: XOR<ActivityCreateWithoutBabyInput, ActivityUncheckedCreateWithoutBabyInput> | ActivityCreateWithoutBabyInput[] | ActivityUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutBabyInput | ActivityCreateOrConnectWithoutBabyInput[]
    createMany?: ActivityCreateManyBabyInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type BabyPhotoCreateNestedManyWithoutBabyInput = {
    create?: XOR<BabyPhotoCreateWithoutBabyInput, BabyPhotoUncheckedCreateWithoutBabyInput> | BabyPhotoCreateWithoutBabyInput[] | BabyPhotoUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: BabyPhotoCreateOrConnectWithoutBabyInput | BabyPhotoCreateOrConnectWithoutBabyInput[]
    createMany?: BabyPhotoCreateManyBabyInputEnvelope
    connect?: BabyPhotoWhereUniqueInput | BabyPhotoWhereUniqueInput[]
  }

  export type MilestoneCreateNestedManyWithoutBabyInput = {
    create?: XOR<MilestoneCreateWithoutBabyInput, MilestoneUncheckedCreateWithoutBabyInput> | MilestoneCreateWithoutBabyInput[] | MilestoneUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutBabyInput | MilestoneCreateOrConnectWithoutBabyInput[]
    createMany?: MilestoneCreateManyBabyInputEnvelope
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type HealthRecordCreateNestedManyWithoutBabyInput = {
    create?: XOR<HealthRecordCreateWithoutBabyInput, HealthRecordUncheckedCreateWithoutBabyInput> | HealthRecordCreateWithoutBabyInput[] | HealthRecordUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: HealthRecordCreateOrConnectWithoutBabyInput | HealthRecordCreateOrConnectWithoutBabyInput[]
    createMany?: HealthRecordCreateManyBabyInputEnvelope
    connect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
  }

  export type MeasurementCreateNestedManyWithoutBabyInput = {
    create?: XOR<MeasurementCreateWithoutBabyInput, MeasurementUncheckedCreateWithoutBabyInput> | MeasurementCreateWithoutBabyInput[] | MeasurementUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: MeasurementCreateOrConnectWithoutBabyInput | MeasurementCreateOrConnectWithoutBabyInput[]
    createMany?: MeasurementCreateManyBabyInputEnvelope
    connect?: MeasurementWhereUniqueInput | MeasurementWhereUniqueInput[]
  }

  export type AlbumCreateNestedManyWithoutBabyInput = {
    create?: XOR<AlbumCreateWithoutBabyInput, AlbumUncheckedCreateWithoutBabyInput> | AlbumCreateWithoutBabyInput[] | AlbumUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: AlbumCreateOrConnectWithoutBabyInput | AlbumCreateOrConnectWithoutBabyInput[]
    createMany?: AlbumCreateManyBabyInputEnvelope
    connect?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
  }

  export type ParentInviteCreateNestedManyWithoutBabyInput = {
    create?: XOR<ParentInviteCreateWithoutBabyInput, ParentInviteUncheckedCreateWithoutBabyInput> | ParentInviteCreateWithoutBabyInput[] | ParentInviteUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: ParentInviteCreateOrConnectWithoutBabyInput | ParentInviteCreateOrConnectWithoutBabyInput[]
    createMany?: ParentInviteCreateManyBabyInputEnvelope
    connect?: ParentInviteWhereUniqueInput | ParentInviteWhereUniqueInput[]
  }

  export type BabyCaregiverUncheckedCreateNestedManyWithoutBabyInput = {
    create?: XOR<BabyCaregiverCreateWithoutBabyInput, BabyCaregiverUncheckedCreateWithoutBabyInput> | BabyCaregiverCreateWithoutBabyInput[] | BabyCaregiverUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: BabyCaregiverCreateOrConnectWithoutBabyInput | BabyCaregiverCreateOrConnectWithoutBabyInput[]
    createMany?: BabyCaregiverCreateManyBabyInputEnvelope
    connect?: BabyCaregiverWhereUniqueInput | BabyCaregiverWhereUniqueInput[]
  }

  export type EliminationUncheckedCreateNestedManyWithoutBabyInput = {
    create?: XOR<EliminationCreateWithoutBabyInput, EliminationUncheckedCreateWithoutBabyInput> | EliminationCreateWithoutBabyInput[] | EliminationUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: EliminationCreateOrConnectWithoutBabyInput | EliminationCreateOrConnectWithoutBabyInput[]
    createMany?: EliminationCreateManyBabyInputEnvelope
    connect?: EliminationWhereUniqueInput | EliminationWhereUniqueInput[]
  }

  export type FeedingUncheckedCreateNestedManyWithoutBabyInput = {
    create?: XOR<FeedingCreateWithoutBabyInput, FeedingUncheckedCreateWithoutBabyInput> | FeedingCreateWithoutBabyInput[] | FeedingUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: FeedingCreateOrConnectWithoutBabyInput | FeedingCreateOrConnectWithoutBabyInput[]
    createMany?: FeedingCreateManyBabyInputEnvelope
    connect?: FeedingWhereUniqueInput | FeedingWhereUniqueInput[]
  }

  export type SleepUncheckedCreateNestedManyWithoutBabyInput = {
    create?: XOR<SleepCreateWithoutBabyInput, SleepUncheckedCreateWithoutBabyInput> | SleepCreateWithoutBabyInput[] | SleepUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: SleepCreateOrConnectWithoutBabyInput | SleepCreateOrConnectWithoutBabyInput[]
    createMany?: SleepCreateManyBabyInputEnvelope
    connect?: SleepWhereUniqueInput | SleepWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutBabyInput = {
    create?: XOR<ActivityCreateWithoutBabyInput, ActivityUncheckedCreateWithoutBabyInput> | ActivityCreateWithoutBabyInput[] | ActivityUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutBabyInput | ActivityCreateOrConnectWithoutBabyInput[]
    createMany?: ActivityCreateManyBabyInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type BabyPhotoUncheckedCreateNestedManyWithoutBabyInput = {
    create?: XOR<BabyPhotoCreateWithoutBabyInput, BabyPhotoUncheckedCreateWithoutBabyInput> | BabyPhotoCreateWithoutBabyInput[] | BabyPhotoUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: BabyPhotoCreateOrConnectWithoutBabyInput | BabyPhotoCreateOrConnectWithoutBabyInput[]
    createMany?: BabyPhotoCreateManyBabyInputEnvelope
    connect?: BabyPhotoWhereUniqueInput | BabyPhotoWhereUniqueInput[]
  }

  export type MilestoneUncheckedCreateNestedManyWithoutBabyInput = {
    create?: XOR<MilestoneCreateWithoutBabyInput, MilestoneUncheckedCreateWithoutBabyInput> | MilestoneCreateWithoutBabyInput[] | MilestoneUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutBabyInput | MilestoneCreateOrConnectWithoutBabyInput[]
    createMany?: MilestoneCreateManyBabyInputEnvelope
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type HealthRecordUncheckedCreateNestedManyWithoutBabyInput = {
    create?: XOR<HealthRecordCreateWithoutBabyInput, HealthRecordUncheckedCreateWithoutBabyInput> | HealthRecordCreateWithoutBabyInput[] | HealthRecordUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: HealthRecordCreateOrConnectWithoutBabyInput | HealthRecordCreateOrConnectWithoutBabyInput[]
    createMany?: HealthRecordCreateManyBabyInputEnvelope
    connect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
  }

  export type MeasurementUncheckedCreateNestedManyWithoutBabyInput = {
    create?: XOR<MeasurementCreateWithoutBabyInput, MeasurementUncheckedCreateWithoutBabyInput> | MeasurementCreateWithoutBabyInput[] | MeasurementUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: MeasurementCreateOrConnectWithoutBabyInput | MeasurementCreateOrConnectWithoutBabyInput[]
    createMany?: MeasurementCreateManyBabyInputEnvelope
    connect?: MeasurementWhereUniqueInput | MeasurementWhereUniqueInput[]
  }

  export type AlbumUncheckedCreateNestedManyWithoutBabyInput = {
    create?: XOR<AlbumCreateWithoutBabyInput, AlbumUncheckedCreateWithoutBabyInput> | AlbumCreateWithoutBabyInput[] | AlbumUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: AlbumCreateOrConnectWithoutBabyInput | AlbumCreateOrConnectWithoutBabyInput[]
    createMany?: AlbumCreateManyBabyInputEnvelope
    connect?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
  }

  export type ParentInviteUncheckedCreateNestedManyWithoutBabyInput = {
    create?: XOR<ParentInviteCreateWithoutBabyInput, ParentInviteUncheckedCreateWithoutBabyInput> | ParentInviteCreateWithoutBabyInput[] | ParentInviteUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: ParentInviteCreateOrConnectWithoutBabyInput | ParentInviteCreateOrConnectWithoutBabyInput[]
    createMany?: ParentInviteCreateManyBabyInputEnvelope
    connect?: ParentInviteWhereUniqueInput | ParentInviteWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutOwnedBabiesNestedInput = {
    create?: XOR<UserCreateWithoutOwnedBabiesInput, UserUncheckedCreateWithoutOwnedBabiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedBabiesInput
    upsert?: UserUpsertWithoutOwnedBabiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedBabiesInput, UserUpdateWithoutOwnedBabiesInput>, UserUncheckedUpdateWithoutOwnedBabiesInput>
  }

  export type BabyCaregiverUpdateManyWithoutBabyNestedInput = {
    create?: XOR<BabyCaregiverCreateWithoutBabyInput, BabyCaregiverUncheckedCreateWithoutBabyInput> | BabyCaregiverCreateWithoutBabyInput[] | BabyCaregiverUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: BabyCaregiverCreateOrConnectWithoutBabyInput | BabyCaregiverCreateOrConnectWithoutBabyInput[]
    upsert?: BabyCaregiverUpsertWithWhereUniqueWithoutBabyInput | BabyCaregiverUpsertWithWhereUniqueWithoutBabyInput[]
    createMany?: BabyCaregiverCreateManyBabyInputEnvelope
    set?: BabyCaregiverWhereUniqueInput | BabyCaregiverWhereUniqueInput[]
    disconnect?: BabyCaregiverWhereUniqueInput | BabyCaregiverWhereUniqueInput[]
    delete?: BabyCaregiverWhereUniqueInput | BabyCaregiverWhereUniqueInput[]
    connect?: BabyCaregiverWhereUniqueInput | BabyCaregiverWhereUniqueInput[]
    update?: BabyCaregiverUpdateWithWhereUniqueWithoutBabyInput | BabyCaregiverUpdateWithWhereUniqueWithoutBabyInput[]
    updateMany?: BabyCaregiverUpdateManyWithWhereWithoutBabyInput | BabyCaregiverUpdateManyWithWhereWithoutBabyInput[]
    deleteMany?: BabyCaregiverScalarWhereInput | BabyCaregiverScalarWhereInput[]
  }

  export type EliminationUpdateManyWithoutBabyNestedInput = {
    create?: XOR<EliminationCreateWithoutBabyInput, EliminationUncheckedCreateWithoutBabyInput> | EliminationCreateWithoutBabyInput[] | EliminationUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: EliminationCreateOrConnectWithoutBabyInput | EliminationCreateOrConnectWithoutBabyInput[]
    upsert?: EliminationUpsertWithWhereUniqueWithoutBabyInput | EliminationUpsertWithWhereUniqueWithoutBabyInput[]
    createMany?: EliminationCreateManyBabyInputEnvelope
    set?: EliminationWhereUniqueInput | EliminationWhereUniqueInput[]
    disconnect?: EliminationWhereUniqueInput | EliminationWhereUniqueInput[]
    delete?: EliminationWhereUniqueInput | EliminationWhereUniqueInput[]
    connect?: EliminationWhereUniqueInput | EliminationWhereUniqueInput[]
    update?: EliminationUpdateWithWhereUniqueWithoutBabyInput | EliminationUpdateWithWhereUniqueWithoutBabyInput[]
    updateMany?: EliminationUpdateManyWithWhereWithoutBabyInput | EliminationUpdateManyWithWhereWithoutBabyInput[]
    deleteMany?: EliminationScalarWhereInput | EliminationScalarWhereInput[]
  }

  export type FeedingUpdateManyWithoutBabyNestedInput = {
    create?: XOR<FeedingCreateWithoutBabyInput, FeedingUncheckedCreateWithoutBabyInput> | FeedingCreateWithoutBabyInput[] | FeedingUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: FeedingCreateOrConnectWithoutBabyInput | FeedingCreateOrConnectWithoutBabyInput[]
    upsert?: FeedingUpsertWithWhereUniqueWithoutBabyInput | FeedingUpsertWithWhereUniqueWithoutBabyInput[]
    createMany?: FeedingCreateManyBabyInputEnvelope
    set?: FeedingWhereUniqueInput | FeedingWhereUniqueInput[]
    disconnect?: FeedingWhereUniqueInput | FeedingWhereUniqueInput[]
    delete?: FeedingWhereUniqueInput | FeedingWhereUniqueInput[]
    connect?: FeedingWhereUniqueInput | FeedingWhereUniqueInput[]
    update?: FeedingUpdateWithWhereUniqueWithoutBabyInput | FeedingUpdateWithWhereUniqueWithoutBabyInput[]
    updateMany?: FeedingUpdateManyWithWhereWithoutBabyInput | FeedingUpdateManyWithWhereWithoutBabyInput[]
    deleteMany?: FeedingScalarWhereInput | FeedingScalarWhereInput[]
  }

  export type SleepUpdateManyWithoutBabyNestedInput = {
    create?: XOR<SleepCreateWithoutBabyInput, SleepUncheckedCreateWithoutBabyInput> | SleepCreateWithoutBabyInput[] | SleepUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: SleepCreateOrConnectWithoutBabyInput | SleepCreateOrConnectWithoutBabyInput[]
    upsert?: SleepUpsertWithWhereUniqueWithoutBabyInput | SleepUpsertWithWhereUniqueWithoutBabyInput[]
    createMany?: SleepCreateManyBabyInputEnvelope
    set?: SleepWhereUniqueInput | SleepWhereUniqueInput[]
    disconnect?: SleepWhereUniqueInput | SleepWhereUniqueInput[]
    delete?: SleepWhereUniqueInput | SleepWhereUniqueInput[]
    connect?: SleepWhereUniqueInput | SleepWhereUniqueInput[]
    update?: SleepUpdateWithWhereUniqueWithoutBabyInput | SleepUpdateWithWhereUniqueWithoutBabyInput[]
    updateMany?: SleepUpdateManyWithWhereWithoutBabyInput | SleepUpdateManyWithWhereWithoutBabyInput[]
    deleteMany?: SleepScalarWhereInput | SleepScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutBabyNestedInput = {
    create?: XOR<ActivityCreateWithoutBabyInput, ActivityUncheckedCreateWithoutBabyInput> | ActivityCreateWithoutBabyInput[] | ActivityUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutBabyInput | ActivityCreateOrConnectWithoutBabyInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutBabyInput | ActivityUpsertWithWhereUniqueWithoutBabyInput[]
    createMany?: ActivityCreateManyBabyInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutBabyInput | ActivityUpdateWithWhereUniqueWithoutBabyInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutBabyInput | ActivityUpdateManyWithWhereWithoutBabyInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type BabyPhotoUpdateManyWithoutBabyNestedInput = {
    create?: XOR<BabyPhotoCreateWithoutBabyInput, BabyPhotoUncheckedCreateWithoutBabyInput> | BabyPhotoCreateWithoutBabyInput[] | BabyPhotoUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: BabyPhotoCreateOrConnectWithoutBabyInput | BabyPhotoCreateOrConnectWithoutBabyInput[]
    upsert?: BabyPhotoUpsertWithWhereUniqueWithoutBabyInput | BabyPhotoUpsertWithWhereUniqueWithoutBabyInput[]
    createMany?: BabyPhotoCreateManyBabyInputEnvelope
    set?: BabyPhotoWhereUniqueInput | BabyPhotoWhereUniqueInput[]
    disconnect?: BabyPhotoWhereUniqueInput | BabyPhotoWhereUniqueInput[]
    delete?: BabyPhotoWhereUniqueInput | BabyPhotoWhereUniqueInput[]
    connect?: BabyPhotoWhereUniqueInput | BabyPhotoWhereUniqueInput[]
    update?: BabyPhotoUpdateWithWhereUniqueWithoutBabyInput | BabyPhotoUpdateWithWhereUniqueWithoutBabyInput[]
    updateMany?: BabyPhotoUpdateManyWithWhereWithoutBabyInput | BabyPhotoUpdateManyWithWhereWithoutBabyInput[]
    deleteMany?: BabyPhotoScalarWhereInput | BabyPhotoScalarWhereInput[]
  }

  export type MilestoneUpdateManyWithoutBabyNestedInput = {
    create?: XOR<MilestoneCreateWithoutBabyInput, MilestoneUncheckedCreateWithoutBabyInput> | MilestoneCreateWithoutBabyInput[] | MilestoneUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutBabyInput | MilestoneCreateOrConnectWithoutBabyInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutBabyInput | MilestoneUpsertWithWhereUniqueWithoutBabyInput[]
    createMany?: MilestoneCreateManyBabyInputEnvelope
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutBabyInput | MilestoneUpdateWithWhereUniqueWithoutBabyInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutBabyInput | MilestoneUpdateManyWithWhereWithoutBabyInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type HealthRecordUpdateManyWithoutBabyNestedInput = {
    create?: XOR<HealthRecordCreateWithoutBabyInput, HealthRecordUncheckedCreateWithoutBabyInput> | HealthRecordCreateWithoutBabyInput[] | HealthRecordUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: HealthRecordCreateOrConnectWithoutBabyInput | HealthRecordCreateOrConnectWithoutBabyInput[]
    upsert?: HealthRecordUpsertWithWhereUniqueWithoutBabyInput | HealthRecordUpsertWithWhereUniqueWithoutBabyInput[]
    createMany?: HealthRecordCreateManyBabyInputEnvelope
    set?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    disconnect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    delete?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    connect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    update?: HealthRecordUpdateWithWhereUniqueWithoutBabyInput | HealthRecordUpdateWithWhereUniqueWithoutBabyInput[]
    updateMany?: HealthRecordUpdateManyWithWhereWithoutBabyInput | HealthRecordUpdateManyWithWhereWithoutBabyInput[]
    deleteMany?: HealthRecordScalarWhereInput | HealthRecordScalarWhereInput[]
  }

  export type MeasurementUpdateManyWithoutBabyNestedInput = {
    create?: XOR<MeasurementCreateWithoutBabyInput, MeasurementUncheckedCreateWithoutBabyInput> | MeasurementCreateWithoutBabyInput[] | MeasurementUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: MeasurementCreateOrConnectWithoutBabyInput | MeasurementCreateOrConnectWithoutBabyInput[]
    upsert?: MeasurementUpsertWithWhereUniqueWithoutBabyInput | MeasurementUpsertWithWhereUniqueWithoutBabyInput[]
    createMany?: MeasurementCreateManyBabyInputEnvelope
    set?: MeasurementWhereUniqueInput | MeasurementWhereUniqueInput[]
    disconnect?: MeasurementWhereUniqueInput | MeasurementWhereUniqueInput[]
    delete?: MeasurementWhereUniqueInput | MeasurementWhereUniqueInput[]
    connect?: MeasurementWhereUniqueInput | MeasurementWhereUniqueInput[]
    update?: MeasurementUpdateWithWhereUniqueWithoutBabyInput | MeasurementUpdateWithWhereUniqueWithoutBabyInput[]
    updateMany?: MeasurementUpdateManyWithWhereWithoutBabyInput | MeasurementUpdateManyWithWhereWithoutBabyInput[]
    deleteMany?: MeasurementScalarWhereInput | MeasurementScalarWhereInput[]
  }

  export type AlbumUpdateManyWithoutBabyNestedInput = {
    create?: XOR<AlbumCreateWithoutBabyInput, AlbumUncheckedCreateWithoutBabyInput> | AlbumCreateWithoutBabyInput[] | AlbumUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: AlbumCreateOrConnectWithoutBabyInput | AlbumCreateOrConnectWithoutBabyInput[]
    upsert?: AlbumUpsertWithWhereUniqueWithoutBabyInput | AlbumUpsertWithWhereUniqueWithoutBabyInput[]
    createMany?: AlbumCreateManyBabyInputEnvelope
    set?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
    disconnect?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
    delete?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
    connect?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
    update?: AlbumUpdateWithWhereUniqueWithoutBabyInput | AlbumUpdateWithWhereUniqueWithoutBabyInput[]
    updateMany?: AlbumUpdateManyWithWhereWithoutBabyInput | AlbumUpdateManyWithWhereWithoutBabyInput[]
    deleteMany?: AlbumScalarWhereInput | AlbumScalarWhereInput[]
  }

  export type ParentInviteUpdateManyWithoutBabyNestedInput = {
    create?: XOR<ParentInviteCreateWithoutBabyInput, ParentInviteUncheckedCreateWithoutBabyInput> | ParentInviteCreateWithoutBabyInput[] | ParentInviteUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: ParentInviteCreateOrConnectWithoutBabyInput | ParentInviteCreateOrConnectWithoutBabyInput[]
    upsert?: ParentInviteUpsertWithWhereUniqueWithoutBabyInput | ParentInviteUpsertWithWhereUniqueWithoutBabyInput[]
    createMany?: ParentInviteCreateManyBabyInputEnvelope
    set?: ParentInviteWhereUniqueInput | ParentInviteWhereUniqueInput[]
    disconnect?: ParentInviteWhereUniqueInput | ParentInviteWhereUniqueInput[]
    delete?: ParentInviteWhereUniqueInput | ParentInviteWhereUniqueInput[]
    connect?: ParentInviteWhereUniqueInput | ParentInviteWhereUniqueInput[]
    update?: ParentInviteUpdateWithWhereUniqueWithoutBabyInput | ParentInviteUpdateWithWhereUniqueWithoutBabyInput[]
    updateMany?: ParentInviteUpdateManyWithWhereWithoutBabyInput | ParentInviteUpdateManyWithWhereWithoutBabyInput[]
    deleteMany?: ParentInviteScalarWhereInput | ParentInviteScalarWhereInput[]
  }

  export type BabyCaregiverUncheckedUpdateManyWithoutBabyNestedInput = {
    create?: XOR<BabyCaregiverCreateWithoutBabyInput, BabyCaregiverUncheckedCreateWithoutBabyInput> | BabyCaregiverCreateWithoutBabyInput[] | BabyCaregiverUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: BabyCaregiverCreateOrConnectWithoutBabyInput | BabyCaregiverCreateOrConnectWithoutBabyInput[]
    upsert?: BabyCaregiverUpsertWithWhereUniqueWithoutBabyInput | BabyCaregiverUpsertWithWhereUniqueWithoutBabyInput[]
    createMany?: BabyCaregiverCreateManyBabyInputEnvelope
    set?: BabyCaregiverWhereUniqueInput | BabyCaregiverWhereUniqueInput[]
    disconnect?: BabyCaregiverWhereUniqueInput | BabyCaregiverWhereUniqueInput[]
    delete?: BabyCaregiverWhereUniqueInput | BabyCaregiverWhereUniqueInput[]
    connect?: BabyCaregiverWhereUniqueInput | BabyCaregiverWhereUniqueInput[]
    update?: BabyCaregiverUpdateWithWhereUniqueWithoutBabyInput | BabyCaregiverUpdateWithWhereUniqueWithoutBabyInput[]
    updateMany?: BabyCaregiverUpdateManyWithWhereWithoutBabyInput | BabyCaregiverUpdateManyWithWhereWithoutBabyInput[]
    deleteMany?: BabyCaregiverScalarWhereInput | BabyCaregiverScalarWhereInput[]
  }

  export type EliminationUncheckedUpdateManyWithoutBabyNestedInput = {
    create?: XOR<EliminationCreateWithoutBabyInput, EliminationUncheckedCreateWithoutBabyInput> | EliminationCreateWithoutBabyInput[] | EliminationUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: EliminationCreateOrConnectWithoutBabyInput | EliminationCreateOrConnectWithoutBabyInput[]
    upsert?: EliminationUpsertWithWhereUniqueWithoutBabyInput | EliminationUpsertWithWhereUniqueWithoutBabyInput[]
    createMany?: EliminationCreateManyBabyInputEnvelope
    set?: EliminationWhereUniqueInput | EliminationWhereUniqueInput[]
    disconnect?: EliminationWhereUniqueInput | EliminationWhereUniqueInput[]
    delete?: EliminationWhereUniqueInput | EliminationWhereUniqueInput[]
    connect?: EliminationWhereUniqueInput | EliminationWhereUniqueInput[]
    update?: EliminationUpdateWithWhereUniqueWithoutBabyInput | EliminationUpdateWithWhereUniqueWithoutBabyInput[]
    updateMany?: EliminationUpdateManyWithWhereWithoutBabyInput | EliminationUpdateManyWithWhereWithoutBabyInput[]
    deleteMany?: EliminationScalarWhereInput | EliminationScalarWhereInput[]
  }

  export type FeedingUncheckedUpdateManyWithoutBabyNestedInput = {
    create?: XOR<FeedingCreateWithoutBabyInput, FeedingUncheckedCreateWithoutBabyInput> | FeedingCreateWithoutBabyInput[] | FeedingUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: FeedingCreateOrConnectWithoutBabyInput | FeedingCreateOrConnectWithoutBabyInput[]
    upsert?: FeedingUpsertWithWhereUniqueWithoutBabyInput | FeedingUpsertWithWhereUniqueWithoutBabyInput[]
    createMany?: FeedingCreateManyBabyInputEnvelope
    set?: FeedingWhereUniqueInput | FeedingWhereUniqueInput[]
    disconnect?: FeedingWhereUniqueInput | FeedingWhereUniqueInput[]
    delete?: FeedingWhereUniqueInput | FeedingWhereUniqueInput[]
    connect?: FeedingWhereUniqueInput | FeedingWhereUniqueInput[]
    update?: FeedingUpdateWithWhereUniqueWithoutBabyInput | FeedingUpdateWithWhereUniqueWithoutBabyInput[]
    updateMany?: FeedingUpdateManyWithWhereWithoutBabyInput | FeedingUpdateManyWithWhereWithoutBabyInput[]
    deleteMany?: FeedingScalarWhereInput | FeedingScalarWhereInput[]
  }

  export type SleepUncheckedUpdateManyWithoutBabyNestedInput = {
    create?: XOR<SleepCreateWithoutBabyInput, SleepUncheckedCreateWithoutBabyInput> | SleepCreateWithoutBabyInput[] | SleepUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: SleepCreateOrConnectWithoutBabyInput | SleepCreateOrConnectWithoutBabyInput[]
    upsert?: SleepUpsertWithWhereUniqueWithoutBabyInput | SleepUpsertWithWhereUniqueWithoutBabyInput[]
    createMany?: SleepCreateManyBabyInputEnvelope
    set?: SleepWhereUniqueInput | SleepWhereUniqueInput[]
    disconnect?: SleepWhereUniqueInput | SleepWhereUniqueInput[]
    delete?: SleepWhereUniqueInput | SleepWhereUniqueInput[]
    connect?: SleepWhereUniqueInput | SleepWhereUniqueInput[]
    update?: SleepUpdateWithWhereUniqueWithoutBabyInput | SleepUpdateWithWhereUniqueWithoutBabyInput[]
    updateMany?: SleepUpdateManyWithWhereWithoutBabyInput | SleepUpdateManyWithWhereWithoutBabyInput[]
    deleteMany?: SleepScalarWhereInput | SleepScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutBabyNestedInput = {
    create?: XOR<ActivityCreateWithoutBabyInput, ActivityUncheckedCreateWithoutBabyInput> | ActivityCreateWithoutBabyInput[] | ActivityUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutBabyInput | ActivityCreateOrConnectWithoutBabyInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutBabyInput | ActivityUpsertWithWhereUniqueWithoutBabyInput[]
    createMany?: ActivityCreateManyBabyInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutBabyInput | ActivityUpdateWithWhereUniqueWithoutBabyInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutBabyInput | ActivityUpdateManyWithWhereWithoutBabyInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type BabyPhotoUncheckedUpdateManyWithoutBabyNestedInput = {
    create?: XOR<BabyPhotoCreateWithoutBabyInput, BabyPhotoUncheckedCreateWithoutBabyInput> | BabyPhotoCreateWithoutBabyInput[] | BabyPhotoUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: BabyPhotoCreateOrConnectWithoutBabyInput | BabyPhotoCreateOrConnectWithoutBabyInput[]
    upsert?: BabyPhotoUpsertWithWhereUniqueWithoutBabyInput | BabyPhotoUpsertWithWhereUniqueWithoutBabyInput[]
    createMany?: BabyPhotoCreateManyBabyInputEnvelope
    set?: BabyPhotoWhereUniqueInput | BabyPhotoWhereUniqueInput[]
    disconnect?: BabyPhotoWhereUniqueInput | BabyPhotoWhereUniqueInput[]
    delete?: BabyPhotoWhereUniqueInput | BabyPhotoWhereUniqueInput[]
    connect?: BabyPhotoWhereUniqueInput | BabyPhotoWhereUniqueInput[]
    update?: BabyPhotoUpdateWithWhereUniqueWithoutBabyInput | BabyPhotoUpdateWithWhereUniqueWithoutBabyInput[]
    updateMany?: BabyPhotoUpdateManyWithWhereWithoutBabyInput | BabyPhotoUpdateManyWithWhereWithoutBabyInput[]
    deleteMany?: BabyPhotoScalarWhereInput | BabyPhotoScalarWhereInput[]
  }

  export type MilestoneUncheckedUpdateManyWithoutBabyNestedInput = {
    create?: XOR<MilestoneCreateWithoutBabyInput, MilestoneUncheckedCreateWithoutBabyInput> | MilestoneCreateWithoutBabyInput[] | MilestoneUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutBabyInput | MilestoneCreateOrConnectWithoutBabyInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutBabyInput | MilestoneUpsertWithWhereUniqueWithoutBabyInput[]
    createMany?: MilestoneCreateManyBabyInputEnvelope
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutBabyInput | MilestoneUpdateWithWhereUniqueWithoutBabyInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutBabyInput | MilestoneUpdateManyWithWhereWithoutBabyInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type HealthRecordUncheckedUpdateManyWithoutBabyNestedInput = {
    create?: XOR<HealthRecordCreateWithoutBabyInput, HealthRecordUncheckedCreateWithoutBabyInput> | HealthRecordCreateWithoutBabyInput[] | HealthRecordUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: HealthRecordCreateOrConnectWithoutBabyInput | HealthRecordCreateOrConnectWithoutBabyInput[]
    upsert?: HealthRecordUpsertWithWhereUniqueWithoutBabyInput | HealthRecordUpsertWithWhereUniqueWithoutBabyInput[]
    createMany?: HealthRecordCreateManyBabyInputEnvelope
    set?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    disconnect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    delete?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    connect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    update?: HealthRecordUpdateWithWhereUniqueWithoutBabyInput | HealthRecordUpdateWithWhereUniqueWithoutBabyInput[]
    updateMany?: HealthRecordUpdateManyWithWhereWithoutBabyInput | HealthRecordUpdateManyWithWhereWithoutBabyInput[]
    deleteMany?: HealthRecordScalarWhereInput | HealthRecordScalarWhereInput[]
  }

  export type MeasurementUncheckedUpdateManyWithoutBabyNestedInput = {
    create?: XOR<MeasurementCreateWithoutBabyInput, MeasurementUncheckedCreateWithoutBabyInput> | MeasurementCreateWithoutBabyInput[] | MeasurementUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: MeasurementCreateOrConnectWithoutBabyInput | MeasurementCreateOrConnectWithoutBabyInput[]
    upsert?: MeasurementUpsertWithWhereUniqueWithoutBabyInput | MeasurementUpsertWithWhereUniqueWithoutBabyInput[]
    createMany?: MeasurementCreateManyBabyInputEnvelope
    set?: MeasurementWhereUniqueInput | MeasurementWhereUniqueInput[]
    disconnect?: MeasurementWhereUniqueInput | MeasurementWhereUniqueInput[]
    delete?: MeasurementWhereUniqueInput | MeasurementWhereUniqueInput[]
    connect?: MeasurementWhereUniqueInput | MeasurementWhereUniqueInput[]
    update?: MeasurementUpdateWithWhereUniqueWithoutBabyInput | MeasurementUpdateWithWhereUniqueWithoutBabyInput[]
    updateMany?: MeasurementUpdateManyWithWhereWithoutBabyInput | MeasurementUpdateManyWithWhereWithoutBabyInput[]
    deleteMany?: MeasurementScalarWhereInput | MeasurementScalarWhereInput[]
  }

  export type AlbumUncheckedUpdateManyWithoutBabyNestedInput = {
    create?: XOR<AlbumCreateWithoutBabyInput, AlbumUncheckedCreateWithoutBabyInput> | AlbumCreateWithoutBabyInput[] | AlbumUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: AlbumCreateOrConnectWithoutBabyInput | AlbumCreateOrConnectWithoutBabyInput[]
    upsert?: AlbumUpsertWithWhereUniqueWithoutBabyInput | AlbumUpsertWithWhereUniqueWithoutBabyInput[]
    createMany?: AlbumCreateManyBabyInputEnvelope
    set?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
    disconnect?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
    delete?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
    connect?: AlbumWhereUniqueInput | AlbumWhereUniqueInput[]
    update?: AlbumUpdateWithWhereUniqueWithoutBabyInput | AlbumUpdateWithWhereUniqueWithoutBabyInput[]
    updateMany?: AlbumUpdateManyWithWhereWithoutBabyInput | AlbumUpdateManyWithWhereWithoutBabyInput[]
    deleteMany?: AlbumScalarWhereInput | AlbumScalarWhereInput[]
  }

  export type ParentInviteUncheckedUpdateManyWithoutBabyNestedInput = {
    create?: XOR<ParentInviteCreateWithoutBabyInput, ParentInviteUncheckedCreateWithoutBabyInput> | ParentInviteCreateWithoutBabyInput[] | ParentInviteUncheckedCreateWithoutBabyInput[]
    connectOrCreate?: ParentInviteCreateOrConnectWithoutBabyInput | ParentInviteCreateOrConnectWithoutBabyInput[]
    upsert?: ParentInviteUpsertWithWhereUniqueWithoutBabyInput | ParentInviteUpsertWithWhereUniqueWithoutBabyInput[]
    createMany?: ParentInviteCreateManyBabyInputEnvelope
    set?: ParentInviteWhereUniqueInput | ParentInviteWhereUniqueInput[]
    disconnect?: ParentInviteWhereUniqueInput | ParentInviteWhereUniqueInput[]
    delete?: ParentInviteWhereUniqueInput | ParentInviteWhereUniqueInput[]
    connect?: ParentInviteWhereUniqueInput | ParentInviteWhereUniqueInput[]
    update?: ParentInviteUpdateWithWhereUniqueWithoutBabyInput | ParentInviteUpdateWithWhereUniqueWithoutBabyInput[]
    updateMany?: ParentInviteUpdateManyWithWhereWithoutBabyInput | ParentInviteUpdateManyWithWhereWithoutBabyInput[]
    deleteMany?: ParentInviteScalarWhereInput | ParentInviteScalarWhereInput[]
  }

  export type BabyCaregiverCreatepermissionsInput = {
    set: string[]
  }

  export type BabyCreateNestedOneWithoutCaregiversInput = {
    create?: XOR<BabyCreateWithoutCaregiversInput, BabyUncheckedCreateWithoutCaregiversInput>
    connectOrCreate?: BabyCreateOrConnectWithoutCaregiversInput
    connect?: BabyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBabiesInput = {
    create?: XOR<UserCreateWithoutBabiesInput, UserUncheckedCreateWithoutBabiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBabiesInput
    connect?: UserWhereUniqueInput
  }

  export type BabyCaregiverUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BabyUpdateOneRequiredWithoutCaregiversNestedInput = {
    create?: XOR<BabyCreateWithoutCaregiversInput, BabyUncheckedCreateWithoutCaregiversInput>
    connectOrCreate?: BabyCreateOrConnectWithoutCaregiversInput
    upsert?: BabyUpsertWithoutCaregiversInput
    connect?: BabyWhereUniqueInput
    update?: XOR<XOR<BabyUpdateToOneWithWhereWithoutCaregiversInput, BabyUpdateWithoutCaregiversInput>, BabyUncheckedUpdateWithoutCaregiversInput>
  }

  export type UserUpdateOneRequiredWithoutBabiesNestedInput = {
    create?: XOR<UserCreateWithoutBabiesInput, UserUncheckedCreateWithoutBabiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBabiesInput
    upsert?: UserUpsertWithoutBabiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBabiesInput, UserUpdateWithoutBabiesInput>, UserUncheckedUpdateWithoutBabiesInput>
  }

  export type BabyCreateNestedOneWithoutEliminationsInput = {
    create?: XOR<BabyCreateWithoutEliminationsInput, BabyUncheckedCreateWithoutEliminationsInput>
    connectOrCreate?: BabyCreateOrConnectWithoutEliminationsInput
    connect?: BabyWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BabyUpdateOneRequiredWithoutEliminationsNestedInput = {
    create?: XOR<BabyCreateWithoutEliminationsInput, BabyUncheckedCreateWithoutEliminationsInput>
    connectOrCreate?: BabyCreateOrConnectWithoutEliminationsInput
    upsert?: BabyUpsertWithoutEliminationsInput
    connect?: BabyWhereUniqueInput
    update?: XOR<XOR<BabyUpdateToOneWithWhereWithoutEliminationsInput, BabyUpdateWithoutEliminationsInput>, BabyUncheckedUpdateWithoutEliminationsInput>
  }

  export type BabyCreateNestedOneWithoutFeedingsInput = {
    create?: XOR<BabyCreateWithoutFeedingsInput, BabyUncheckedCreateWithoutFeedingsInput>
    connectOrCreate?: BabyCreateOrConnectWithoutFeedingsInput
    connect?: BabyWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BabyUpdateOneRequiredWithoutFeedingsNestedInput = {
    create?: XOR<BabyCreateWithoutFeedingsInput, BabyUncheckedCreateWithoutFeedingsInput>
    connectOrCreate?: BabyCreateOrConnectWithoutFeedingsInput
    upsert?: BabyUpsertWithoutFeedingsInput
    connect?: BabyWhereUniqueInput
    update?: XOR<XOR<BabyUpdateToOneWithWhereWithoutFeedingsInput, BabyUpdateWithoutFeedingsInput>, BabyUncheckedUpdateWithoutFeedingsInput>
  }

  export type BabyCreateNestedOneWithoutSleepsleepSessionsInput = {
    create?: XOR<BabyCreateWithoutSleepsleepSessionsInput, BabyUncheckedCreateWithoutSleepsleepSessionsInput>
    connectOrCreate?: BabyCreateOrConnectWithoutSleepsleepSessionsInput
    connect?: BabyWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BabyUpdateOneRequiredWithoutSleepsleepSessionsNestedInput = {
    create?: XOR<BabyCreateWithoutSleepsleepSessionsInput, BabyUncheckedCreateWithoutSleepsleepSessionsInput>
    connectOrCreate?: BabyCreateOrConnectWithoutSleepsleepSessionsInput
    upsert?: BabyUpsertWithoutSleepsleepSessionsInput
    connect?: BabyWhereUniqueInput
    update?: XOR<XOR<BabyUpdateToOneWithWhereWithoutSleepsleepSessionsInput, BabyUpdateWithoutSleepsleepSessionsInput>, BabyUncheckedUpdateWithoutSleepsleepSessionsInput>
  }

  export type BabyCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<BabyCreateWithoutActivitiesInput, BabyUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: BabyCreateOrConnectWithoutActivitiesInput
    connect?: BabyWhereUniqueInput
  }

  export type ActivityPhotoCreateNestedManyWithoutActivityInput = {
    create?: XOR<ActivityPhotoCreateWithoutActivityInput, ActivityPhotoUncheckedCreateWithoutActivityInput> | ActivityPhotoCreateWithoutActivityInput[] | ActivityPhotoUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityPhotoCreateOrConnectWithoutActivityInput | ActivityPhotoCreateOrConnectWithoutActivityInput[]
    createMany?: ActivityPhotoCreateManyActivityInputEnvelope
    connect?: ActivityPhotoWhereUniqueInput | ActivityPhotoWhereUniqueInput[]
  }

  export type ActivityPhotoUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<ActivityPhotoCreateWithoutActivityInput, ActivityPhotoUncheckedCreateWithoutActivityInput> | ActivityPhotoCreateWithoutActivityInput[] | ActivityPhotoUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityPhotoCreateOrConnectWithoutActivityInput | ActivityPhotoCreateOrConnectWithoutActivityInput[]
    createMany?: ActivityPhotoCreateManyActivityInputEnvelope
    connect?: ActivityPhotoWhereUniqueInput | ActivityPhotoWhereUniqueInput[]
  }

  export type BabyUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<BabyCreateWithoutActivitiesInput, BabyUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: BabyCreateOrConnectWithoutActivitiesInput
    upsert?: BabyUpsertWithoutActivitiesInput
    connect?: BabyWhereUniqueInput
    update?: XOR<XOR<BabyUpdateToOneWithWhereWithoutActivitiesInput, BabyUpdateWithoutActivitiesInput>, BabyUncheckedUpdateWithoutActivitiesInput>
  }

  export type ActivityPhotoUpdateManyWithoutActivityNestedInput = {
    create?: XOR<ActivityPhotoCreateWithoutActivityInput, ActivityPhotoUncheckedCreateWithoutActivityInput> | ActivityPhotoCreateWithoutActivityInput[] | ActivityPhotoUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityPhotoCreateOrConnectWithoutActivityInput | ActivityPhotoCreateOrConnectWithoutActivityInput[]
    upsert?: ActivityPhotoUpsertWithWhereUniqueWithoutActivityInput | ActivityPhotoUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: ActivityPhotoCreateManyActivityInputEnvelope
    set?: ActivityPhotoWhereUniqueInput | ActivityPhotoWhereUniqueInput[]
    disconnect?: ActivityPhotoWhereUniqueInput | ActivityPhotoWhereUniqueInput[]
    delete?: ActivityPhotoWhereUniqueInput | ActivityPhotoWhereUniqueInput[]
    connect?: ActivityPhotoWhereUniqueInput | ActivityPhotoWhereUniqueInput[]
    update?: ActivityPhotoUpdateWithWhereUniqueWithoutActivityInput | ActivityPhotoUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: ActivityPhotoUpdateManyWithWhereWithoutActivityInput | ActivityPhotoUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: ActivityPhotoScalarWhereInput | ActivityPhotoScalarWhereInput[]
  }

  export type ActivityPhotoUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<ActivityPhotoCreateWithoutActivityInput, ActivityPhotoUncheckedCreateWithoutActivityInput> | ActivityPhotoCreateWithoutActivityInput[] | ActivityPhotoUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityPhotoCreateOrConnectWithoutActivityInput | ActivityPhotoCreateOrConnectWithoutActivityInput[]
    upsert?: ActivityPhotoUpsertWithWhereUniqueWithoutActivityInput | ActivityPhotoUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: ActivityPhotoCreateManyActivityInputEnvelope
    set?: ActivityPhotoWhereUniqueInput | ActivityPhotoWhereUniqueInput[]
    disconnect?: ActivityPhotoWhereUniqueInput | ActivityPhotoWhereUniqueInput[]
    delete?: ActivityPhotoWhereUniqueInput | ActivityPhotoWhereUniqueInput[]
    connect?: ActivityPhotoWhereUniqueInput | ActivityPhotoWhereUniqueInput[]
    update?: ActivityPhotoUpdateWithWhereUniqueWithoutActivityInput | ActivityPhotoUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: ActivityPhotoUpdateManyWithWhereWithoutActivityInput | ActivityPhotoUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: ActivityPhotoScalarWhereInput | ActivityPhotoScalarWhereInput[]
  }

  export type BabyCreateNestedOneWithoutMilestonesInput = {
    create?: XOR<BabyCreateWithoutMilestonesInput, BabyUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: BabyCreateOrConnectWithoutMilestonesInput
    connect?: BabyWhereUniqueInput
  }

  export type MilestonePhotoCreateNestedManyWithoutMilestoneInput = {
    create?: XOR<MilestonePhotoCreateWithoutMilestoneInput, MilestonePhotoUncheckedCreateWithoutMilestoneInput> | MilestonePhotoCreateWithoutMilestoneInput[] | MilestonePhotoUncheckedCreateWithoutMilestoneInput[]
    connectOrCreate?: MilestonePhotoCreateOrConnectWithoutMilestoneInput | MilestonePhotoCreateOrConnectWithoutMilestoneInput[]
    createMany?: MilestonePhotoCreateManyMilestoneInputEnvelope
    connect?: MilestonePhotoWhereUniqueInput | MilestonePhotoWhereUniqueInput[]
  }

  export type MilestonePhotoUncheckedCreateNestedManyWithoutMilestoneInput = {
    create?: XOR<MilestonePhotoCreateWithoutMilestoneInput, MilestonePhotoUncheckedCreateWithoutMilestoneInput> | MilestonePhotoCreateWithoutMilestoneInput[] | MilestonePhotoUncheckedCreateWithoutMilestoneInput[]
    connectOrCreate?: MilestonePhotoCreateOrConnectWithoutMilestoneInput | MilestonePhotoCreateOrConnectWithoutMilestoneInput[]
    createMany?: MilestonePhotoCreateManyMilestoneInputEnvelope
    connect?: MilestonePhotoWhereUniqueInput | MilestonePhotoWhereUniqueInput[]
  }

  export type BabyUpdateOneRequiredWithoutMilestonesNestedInput = {
    create?: XOR<BabyCreateWithoutMilestonesInput, BabyUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: BabyCreateOrConnectWithoutMilestonesInput
    upsert?: BabyUpsertWithoutMilestonesInput
    connect?: BabyWhereUniqueInput
    update?: XOR<XOR<BabyUpdateToOneWithWhereWithoutMilestonesInput, BabyUpdateWithoutMilestonesInput>, BabyUncheckedUpdateWithoutMilestonesInput>
  }

  export type MilestonePhotoUpdateManyWithoutMilestoneNestedInput = {
    create?: XOR<MilestonePhotoCreateWithoutMilestoneInput, MilestonePhotoUncheckedCreateWithoutMilestoneInput> | MilestonePhotoCreateWithoutMilestoneInput[] | MilestonePhotoUncheckedCreateWithoutMilestoneInput[]
    connectOrCreate?: MilestonePhotoCreateOrConnectWithoutMilestoneInput | MilestonePhotoCreateOrConnectWithoutMilestoneInput[]
    upsert?: MilestonePhotoUpsertWithWhereUniqueWithoutMilestoneInput | MilestonePhotoUpsertWithWhereUniqueWithoutMilestoneInput[]
    createMany?: MilestonePhotoCreateManyMilestoneInputEnvelope
    set?: MilestonePhotoWhereUniqueInput | MilestonePhotoWhereUniqueInput[]
    disconnect?: MilestonePhotoWhereUniqueInput | MilestonePhotoWhereUniqueInput[]
    delete?: MilestonePhotoWhereUniqueInput | MilestonePhotoWhereUniqueInput[]
    connect?: MilestonePhotoWhereUniqueInput | MilestonePhotoWhereUniqueInput[]
    update?: MilestonePhotoUpdateWithWhereUniqueWithoutMilestoneInput | MilestonePhotoUpdateWithWhereUniqueWithoutMilestoneInput[]
    updateMany?: MilestonePhotoUpdateManyWithWhereWithoutMilestoneInput | MilestonePhotoUpdateManyWithWhereWithoutMilestoneInput[]
    deleteMany?: MilestonePhotoScalarWhereInput | MilestonePhotoScalarWhereInput[]
  }

  export type MilestonePhotoUncheckedUpdateManyWithoutMilestoneNestedInput = {
    create?: XOR<MilestonePhotoCreateWithoutMilestoneInput, MilestonePhotoUncheckedCreateWithoutMilestoneInput> | MilestonePhotoCreateWithoutMilestoneInput[] | MilestonePhotoUncheckedCreateWithoutMilestoneInput[]
    connectOrCreate?: MilestonePhotoCreateOrConnectWithoutMilestoneInput | MilestonePhotoCreateOrConnectWithoutMilestoneInput[]
    upsert?: MilestonePhotoUpsertWithWhereUniqueWithoutMilestoneInput | MilestonePhotoUpsertWithWhereUniqueWithoutMilestoneInput[]
    createMany?: MilestonePhotoCreateManyMilestoneInputEnvelope
    set?: MilestonePhotoWhereUniqueInput | MilestonePhotoWhereUniqueInput[]
    disconnect?: MilestonePhotoWhereUniqueInput | MilestonePhotoWhereUniqueInput[]
    delete?: MilestonePhotoWhereUniqueInput | MilestonePhotoWhereUniqueInput[]
    connect?: MilestonePhotoWhereUniqueInput | MilestonePhotoWhereUniqueInput[]
    update?: MilestonePhotoUpdateWithWhereUniqueWithoutMilestoneInput | MilestonePhotoUpdateWithWhereUniqueWithoutMilestoneInput[]
    updateMany?: MilestonePhotoUpdateManyWithWhereWithoutMilestoneInput | MilestonePhotoUpdateManyWithWhereWithoutMilestoneInput[]
    deleteMany?: MilestonePhotoScalarWhereInput | MilestonePhotoScalarWhereInput[]
  }

  export type BabyCreateNestedOneWithoutHealthRecordsInput = {
    create?: XOR<BabyCreateWithoutHealthRecordsInput, BabyUncheckedCreateWithoutHealthRecordsInput>
    connectOrCreate?: BabyCreateOrConnectWithoutHealthRecordsInput
    connect?: BabyWhereUniqueInput
  }

  export type BabyUpdateOneRequiredWithoutHealthRecordsNestedInput = {
    create?: XOR<BabyCreateWithoutHealthRecordsInput, BabyUncheckedCreateWithoutHealthRecordsInput>
    connectOrCreate?: BabyCreateOrConnectWithoutHealthRecordsInput
    upsert?: BabyUpsertWithoutHealthRecordsInput
    connect?: BabyWhereUniqueInput
    update?: XOR<XOR<BabyUpdateToOneWithWhereWithoutHealthRecordsInput, BabyUpdateWithoutHealthRecordsInput>, BabyUncheckedUpdateWithoutHealthRecordsInput>
  }

  export type BabyCreateNestedOneWithoutMeasurementsInput = {
    create?: XOR<BabyCreateWithoutMeasurementsInput, BabyUncheckedCreateWithoutMeasurementsInput>
    connectOrCreate?: BabyCreateOrConnectWithoutMeasurementsInput
    connect?: BabyWhereUniqueInput
  }

  export type BabyUpdateOneRequiredWithoutMeasurementsNestedInput = {
    create?: XOR<BabyCreateWithoutMeasurementsInput, BabyUncheckedCreateWithoutMeasurementsInput>
    connectOrCreate?: BabyCreateOrConnectWithoutMeasurementsInput
    upsert?: BabyUpsertWithoutMeasurementsInput
    connect?: BabyWhereUniqueInput
    update?: XOR<XOR<BabyUpdateToOneWithWhereWithoutMeasurementsInput, BabyUpdateWithoutMeasurementsInput>, BabyUncheckedUpdateWithoutMeasurementsInput>
  }

  export type BabyCreateNestedOneWithoutAlbumsInput = {
    create?: XOR<BabyCreateWithoutAlbumsInput, BabyUncheckedCreateWithoutAlbumsInput>
    connectOrCreate?: BabyCreateOrConnectWithoutAlbumsInput
    connect?: BabyWhereUniqueInput
  }

  export type AlbumPhotoCreateNestedManyWithoutAlbumInput = {
    create?: XOR<AlbumPhotoCreateWithoutAlbumInput, AlbumPhotoUncheckedCreateWithoutAlbumInput> | AlbumPhotoCreateWithoutAlbumInput[] | AlbumPhotoUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: AlbumPhotoCreateOrConnectWithoutAlbumInput | AlbumPhotoCreateOrConnectWithoutAlbumInput[]
    createMany?: AlbumPhotoCreateManyAlbumInputEnvelope
    connect?: AlbumPhotoWhereUniqueInput | AlbumPhotoWhereUniqueInput[]
  }

  export type AlbumAccessCreateNestedManyWithoutAlbumInput = {
    create?: XOR<AlbumAccessCreateWithoutAlbumInput, AlbumAccessUncheckedCreateWithoutAlbumInput> | AlbumAccessCreateWithoutAlbumInput[] | AlbumAccessUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: AlbumAccessCreateOrConnectWithoutAlbumInput | AlbumAccessCreateOrConnectWithoutAlbumInput[]
    createMany?: AlbumAccessCreateManyAlbumInputEnvelope
    connect?: AlbumAccessWhereUniqueInput | AlbumAccessWhereUniqueInput[]
  }

  export type AlbumPhotoUncheckedCreateNestedManyWithoutAlbumInput = {
    create?: XOR<AlbumPhotoCreateWithoutAlbumInput, AlbumPhotoUncheckedCreateWithoutAlbumInput> | AlbumPhotoCreateWithoutAlbumInput[] | AlbumPhotoUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: AlbumPhotoCreateOrConnectWithoutAlbumInput | AlbumPhotoCreateOrConnectWithoutAlbumInput[]
    createMany?: AlbumPhotoCreateManyAlbumInputEnvelope
    connect?: AlbumPhotoWhereUniqueInput | AlbumPhotoWhereUniqueInput[]
  }

  export type AlbumAccessUncheckedCreateNestedManyWithoutAlbumInput = {
    create?: XOR<AlbumAccessCreateWithoutAlbumInput, AlbumAccessUncheckedCreateWithoutAlbumInput> | AlbumAccessCreateWithoutAlbumInput[] | AlbumAccessUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: AlbumAccessCreateOrConnectWithoutAlbumInput | AlbumAccessCreateOrConnectWithoutAlbumInput[]
    createMany?: AlbumAccessCreateManyAlbumInputEnvelope
    connect?: AlbumAccessWhereUniqueInput | AlbumAccessWhereUniqueInput[]
  }

  export type BabyUpdateOneRequiredWithoutAlbumsNestedInput = {
    create?: XOR<BabyCreateWithoutAlbumsInput, BabyUncheckedCreateWithoutAlbumsInput>
    connectOrCreate?: BabyCreateOrConnectWithoutAlbumsInput
    upsert?: BabyUpsertWithoutAlbumsInput
    connect?: BabyWhereUniqueInput
    update?: XOR<XOR<BabyUpdateToOneWithWhereWithoutAlbumsInput, BabyUpdateWithoutAlbumsInput>, BabyUncheckedUpdateWithoutAlbumsInput>
  }

  export type AlbumPhotoUpdateManyWithoutAlbumNestedInput = {
    create?: XOR<AlbumPhotoCreateWithoutAlbumInput, AlbumPhotoUncheckedCreateWithoutAlbumInput> | AlbumPhotoCreateWithoutAlbumInput[] | AlbumPhotoUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: AlbumPhotoCreateOrConnectWithoutAlbumInput | AlbumPhotoCreateOrConnectWithoutAlbumInput[]
    upsert?: AlbumPhotoUpsertWithWhereUniqueWithoutAlbumInput | AlbumPhotoUpsertWithWhereUniqueWithoutAlbumInput[]
    createMany?: AlbumPhotoCreateManyAlbumInputEnvelope
    set?: AlbumPhotoWhereUniqueInput | AlbumPhotoWhereUniqueInput[]
    disconnect?: AlbumPhotoWhereUniqueInput | AlbumPhotoWhereUniqueInput[]
    delete?: AlbumPhotoWhereUniqueInput | AlbumPhotoWhereUniqueInput[]
    connect?: AlbumPhotoWhereUniqueInput | AlbumPhotoWhereUniqueInput[]
    update?: AlbumPhotoUpdateWithWhereUniqueWithoutAlbumInput | AlbumPhotoUpdateWithWhereUniqueWithoutAlbumInput[]
    updateMany?: AlbumPhotoUpdateManyWithWhereWithoutAlbumInput | AlbumPhotoUpdateManyWithWhereWithoutAlbumInput[]
    deleteMany?: AlbumPhotoScalarWhereInput | AlbumPhotoScalarWhereInput[]
  }

  export type AlbumAccessUpdateManyWithoutAlbumNestedInput = {
    create?: XOR<AlbumAccessCreateWithoutAlbumInput, AlbumAccessUncheckedCreateWithoutAlbumInput> | AlbumAccessCreateWithoutAlbumInput[] | AlbumAccessUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: AlbumAccessCreateOrConnectWithoutAlbumInput | AlbumAccessCreateOrConnectWithoutAlbumInput[]
    upsert?: AlbumAccessUpsertWithWhereUniqueWithoutAlbumInput | AlbumAccessUpsertWithWhereUniqueWithoutAlbumInput[]
    createMany?: AlbumAccessCreateManyAlbumInputEnvelope
    set?: AlbumAccessWhereUniqueInput | AlbumAccessWhereUniqueInput[]
    disconnect?: AlbumAccessWhereUniqueInput | AlbumAccessWhereUniqueInput[]
    delete?: AlbumAccessWhereUniqueInput | AlbumAccessWhereUniqueInput[]
    connect?: AlbumAccessWhereUniqueInput | AlbumAccessWhereUniqueInput[]
    update?: AlbumAccessUpdateWithWhereUniqueWithoutAlbumInput | AlbumAccessUpdateWithWhereUniqueWithoutAlbumInput[]
    updateMany?: AlbumAccessUpdateManyWithWhereWithoutAlbumInput | AlbumAccessUpdateManyWithWhereWithoutAlbumInput[]
    deleteMany?: AlbumAccessScalarWhereInput | AlbumAccessScalarWhereInput[]
  }

  export type AlbumPhotoUncheckedUpdateManyWithoutAlbumNestedInput = {
    create?: XOR<AlbumPhotoCreateWithoutAlbumInput, AlbumPhotoUncheckedCreateWithoutAlbumInput> | AlbumPhotoCreateWithoutAlbumInput[] | AlbumPhotoUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: AlbumPhotoCreateOrConnectWithoutAlbumInput | AlbumPhotoCreateOrConnectWithoutAlbumInput[]
    upsert?: AlbumPhotoUpsertWithWhereUniqueWithoutAlbumInput | AlbumPhotoUpsertWithWhereUniqueWithoutAlbumInput[]
    createMany?: AlbumPhotoCreateManyAlbumInputEnvelope
    set?: AlbumPhotoWhereUniqueInput | AlbumPhotoWhereUniqueInput[]
    disconnect?: AlbumPhotoWhereUniqueInput | AlbumPhotoWhereUniqueInput[]
    delete?: AlbumPhotoWhereUniqueInput | AlbumPhotoWhereUniqueInput[]
    connect?: AlbumPhotoWhereUniqueInput | AlbumPhotoWhereUniqueInput[]
    update?: AlbumPhotoUpdateWithWhereUniqueWithoutAlbumInput | AlbumPhotoUpdateWithWhereUniqueWithoutAlbumInput[]
    updateMany?: AlbumPhotoUpdateManyWithWhereWithoutAlbumInput | AlbumPhotoUpdateManyWithWhereWithoutAlbumInput[]
    deleteMany?: AlbumPhotoScalarWhereInput | AlbumPhotoScalarWhereInput[]
  }

  export type AlbumAccessUncheckedUpdateManyWithoutAlbumNestedInput = {
    create?: XOR<AlbumAccessCreateWithoutAlbumInput, AlbumAccessUncheckedCreateWithoutAlbumInput> | AlbumAccessCreateWithoutAlbumInput[] | AlbumAccessUncheckedCreateWithoutAlbumInput[]
    connectOrCreate?: AlbumAccessCreateOrConnectWithoutAlbumInput | AlbumAccessCreateOrConnectWithoutAlbumInput[]
    upsert?: AlbumAccessUpsertWithWhereUniqueWithoutAlbumInput | AlbumAccessUpsertWithWhereUniqueWithoutAlbumInput[]
    createMany?: AlbumAccessCreateManyAlbumInputEnvelope
    set?: AlbumAccessWhereUniqueInput | AlbumAccessWhereUniqueInput[]
    disconnect?: AlbumAccessWhereUniqueInput | AlbumAccessWhereUniqueInput[]
    delete?: AlbumAccessWhereUniqueInput | AlbumAccessWhereUniqueInput[]
    connect?: AlbumAccessWhereUniqueInput | AlbumAccessWhereUniqueInput[]
    update?: AlbumAccessUpdateWithWhereUniqueWithoutAlbumInput | AlbumAccessUpdateWithWhereUniqueWithoutAlbumInput[]
    updateMany?: AlbumAccessUpdateManyWithWhereWithoutAlbumInput | AlbumAccessUpdateManyWithWhereWithoutAlbumInput[]
    deleteMany?: AlbumAccessScalarWhereInput | AlbumAccessScalarWhereInput[]
  }

  export type BabyPhotoCreateNestedManyWithoutPhotoInput = {
    create?: XOR<BabyPhotoCreateWithoutPhotoInput, BabyPhotoUncheckedCreateWithoutPhotoInput> | BabyPhotoCreateWithoutPhotoInput[] | BabyPhotoUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: BabyPhotoCreateOrConnectWithoutPhotoInput | BabyPhotoCreateOrConnectWithoutPhotoInput[]
    createMany?: BabyPhotoCreateManyPhotoInputEnvelope
    connect?: BabyPhotoWhereUniqueInput | BabyPhotoWhereUniqueInput[]
  }

  export type AlbumPhotoCreateNestedManyWithoutPhotoInput = {
    create?: XOR<AlbumPhotoCreateWithoutPhotoInput, AlbumPhotoUncheckedCreateWithoutPhotoInput> | AlbumPhotoCreateWithoutPhotoInput[] | AlbumPhotoUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: AlbumPhotoCreateOrConnectWithoutPhotoInput | AlbumPhotoCreateOrConnectWithoutPhotoInput[]
    createMany?: AlbumPhotoCreateManyPhotoInputEnvelope
    connect?: AlbumPhotoWhereUniqueInput | AlbumPhotoWhereUniqueInput[]
  }

  export type ActivityPhotoCreateNestedManyWithoutPhotoInput = {
    create?: XOR<ActivityPhotoCreateWithoutPhotoInput, ActivityPhotoUncheckedCreateWithoutPhotoInput> | ActivityPhotoCreateWithoutPhotoInput[] | ActivityPhotoUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ActivityPhotoCreateOrConnectWithoutPhotoInput | ActivityPhotoCreateOrConnectWithoutPhotoInput[]
    createMany?: ActivityPhotoCreateManyPhotoInputEnvelope
    connect?: ActivityPhotoWhereUniqueInput | ActivityPhotoWhereUniqueInput[]
  }

  export type MilestonePhotoCreateNestedManyWithoutPhotoInput = {
    create?: XOR<MilestonePhotoCreateWithoutPhotoInput, MilestonePhotoUncheckedCreateWithoutPhotoInput> | MilestonePhotoCreateWithoutPhotoInput[] | MilestonePhotoUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: MilestonePhotoCreateOrConnectWithoutPhotoInput | MilestonePhotoCreateOrConnectWithoutPhotoInput[]
    createMany?: MilestonePhotoCreateManyPhotoInputEnvelope
    connect?: MilestonePhotoWhereUniqueInput | MilestonePhotoWhereUniqueInput[]
  }

  export type BabyPhotoUncheckedCreateNestedManyWithoutPhotoInput = {
    create?: XOR<BabyPhotoCreateWithoutPhotoInput, BabyPhotoUncheckedCreateWithoutPhotoInput> | BabyPhotoCreateWithoutPhotoInput[] | BabyPhotoUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: BabyPhotoCreateOrConnectWithoutPhotoInput | BabyPhotoCreateOrConnectWithoutPhotoInput[]
    createMany?: BabyPhotoCreateManyPhotoInputEnvelope
    connect?: BabyPhotoWhereUniqueInput | BabyPhotoWhereUniqueInput[]
  }

  export type AlbumPhotoUncheckedCreateNestedManyWithoutPhotoInput = {
    create?: XOR<AlbumPhotoCreateWithoutPhotoInput, AlbumPhotoUncheckedCreateWithoutPhotoInput> | AlbumPhotoCreateWithoutPhotoInput[] | AlbumPhotoUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: AlbumPhotoCreateOrConnectWithoutPhotoInput | AlbumPhotoCreateOrConnectWithoutPhotoInput[]
    createMany?: AlbumPhotoCreateManyPhotoInputEnvelope
    connect?: AlbumPhotoWhereUniqueInput | AlbumPhotoWhereUniqueInput[]
  }

  export type ActivityPhotoUncheckedCreateNestedManyWithoutPhotoInput = {
    create?: XOR<ActivityPhotoCreateWithoutPhotoInput, ActivityPhotoUncheckedCreateWithoutPhotoInput> | ActivityPhotoCreateWithoutPhotoInput[] | ActivityPhotoUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ActivityPhotoCreateOrConnectWithoutPhotoInput | ActivityPhotoCreateOrConnectWithoutPhotoInput[]
    createMany?: ActivityPhotoCreateManyPhotoInputEnvelope
    connect?: ActivityPhotoWhereUniqueInput | ActivityPhotoWhereUniqueInput[]
  }

  export type MilestonePhotoUncheckedCreateNestedManyWithoutPhotoInput = {
    create?: XOR<MilestonePhotoCreateWithoutPhotoInput, MilestonePhotoUncheckedCreateWithoutPhotoInput> | MilestonePhotoCreateWithoutPhotoInput[] | MilestonePhotoUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: MilestonePhotoCreateOrConnectWithoutPhotoInput | MilestonePhotoCreateOrConnectWithoutPhotoInput[]
    createMany?: MilestonePhotoCreateManyPhotoInputEnvelope
    connect?: MilestonePhotoWhereUniqueInput | MilestonePhotoWhereUniqueInput[]
  }

  export type BabyPhotoUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<BabyPhotoCreateWithoutPhotoInput, BabyPhotoUncheckedCreateWithoutPhotoInput> | BabyPhotoCreateWithoutPhotoInput[] | BabyPhotoUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: BabyPhotoCreateOrConnectWithoutPhotoInput | BabyPhotoCreateOrConnectWithoutPhotoInput[]
    upsert?: BabyPhotoUpsertWithWhereUniqueWithoutPhotoInput | BabyPhotoUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: BabyPhotoCreateManyPhotoInputEnvelope
    set?: BabyPhotoWhereUniqueInput | BabyPhotoWhereUniqueInput[]
    disconnect?: BabyPhotoWhereUniqueInput | BabyPhotoWhereUniqueInput[]
    delete?: BabyPhotoWhereUniqueInput | BabyPhotoWhereUniqueInput[]
    connect?: BabyPhotoWhereUniqueInput | BabyPhotoWhereUniqueInput[]
    update?: BabyPhotoUpdateWithWhereUniqueWithoutPhotoInput | BabyPhotoUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: BabyPhotoUpdateManyWithWhereWithoutPhotoInput | BabyPhotoUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: BabyPhotoScalarWhereInput | BabyPhotoScalarWhereInput[]
  }

  export type AlbumPhotoUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<AlbumPhotoCreateWithoutPhotoInput, AlbumPhotoUncheckedCreateWithoutPhotoInput> | AlbumPhotoCreateWithoutPhotoInput[] | AlbumPhotoUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: AlbumPhotoCreateOrConnectWithoutPhotoInput | AlbumPhotoCreateOrConnectWithoutPhotoInput[]
    upsert?: AlbumPhotoUpsertWithWhereUniqueWithoutPhotoInput | AlbumPhotoUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: AlbumPhotoCreateManyPhotoInputEnvelope
    set?: AlbumPhotoWhereUniqueInput | AlbumPhotoWhereUniqueInput[]
    disconnect?: AlbumPhotoWhereUniqueInput | AlbumPhotoWhereUniqueInput[]
    delete?: AlbumPhotoWhereUniqueInput | AlbumPhotoWhereUniqueInput[]
    connect?: AlbumPhotoWhereUniqueInput | AlbumPhotoWhereUniqueInput[]
    update?: AlbumPhotoUpdateWithWhereUniqueWithoutPhotoInput | AlbumPhotoUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: AlbumPhotoUpdateManyWithWhereWithoutPhotoInput | AlbumPhotoUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: AlbumPhotoScalarWhereInput | AlbumPhotoScalarWhereInput[]
  }

  export type ActivityPhotoUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<ActivityPhotoCreateWithoutPhotoInput, ActivityPhotoUncheckedCreateWithoutPhotoInput> | ActivityPhotoCreateWithoutPhotoInput[] | ActivityPhotoUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ActivityPhotoCreateOrConnectWithoutPhotoInput | ActivityPhotoCreateOrConnectWithoutPhotoInput[]
    upsert?: ActivityPhotoUpsertWithWhereUniqueWithoutPhotoInput | ActivityPhotoUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: ActivityPhotoCreateManyPhotoInputEnvelope
    set?: ActivityPhotoWhereUniqueInput | ActivityPhotoWhereUniqueInput[]
    disconnect?: ActivityPhotoWhereUniqueInput | ActivityPhotoWhereUniqueInput[]
    delete?: ActivityPhotoWhereUniqueInput | ActivityPhotoWhereUniqueInput[]
    connect?: ActivityPhotoWhereUniqueInput | ActivityPhotoWhereUniqueInput[]
    update?: ActivityPhotoUpdateWithWhereUniqueWithoutPhotoInput | ActivityPhotoUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: ActivityPhotoUpdateManyWithWhereWithoutPhotoInput | ActivityPhotoUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: ActivityPhotoScalarWhereInput | ActivityPhotoScalarWhereInput[]
  }

  export type MilestonePhotoUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<MilestonePhotoCreateWithoutPhotoInput, MilestonePhotoUncheckedCreateWithoutPhotoInput> | MilestonePhotoCreateWithoutPhotoInput[] | MilestonePhotoUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: MilestonePhotoCreateOrConnectWithoutPhotoInput | MilestonePhotoCreateOrConnectWithoutPhotoInput[]
    upsert?: MilestonePhotoUpsertWithWhereUniqueWithoutPhotoInput | MilestonePhotoUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: MilestonePhotoCreateManyPhotoInputEnvelope
    set?: MilestonePhotoWhereUniqueInput | MilestonePhotoWhereUniqueInput[]
    disconnect?: MilestonePhotoWhereUniqueInput | MilestonePhotoWhereUniqueInput[]
    delete?: MilestonePhotoWhereUniqueInput | MilestonePhotoWhereUniqueInput[]
    connect?: MilestonePhotoWhereUniqueInput | MilestonePhotoWhereUniqueInput[]
    update?: MilestonePhotoUpdateWithWhereUniqueWithoutPhotoInput | MilestonePhotoUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: MilestonePhotoUpdateManyWithWhereWithoutPhotoInput | MilestonePhotoUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: MilestonePhotoScalarWhereInput | MilestonePhotoScalarWhereInput[]
  }

  export type BabyPhotoUncheckedUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<BabyPhotoCreateWithoutPhotoInput, BabyPhotoUncheckedCreateWithoutPhotoInput> | BabyPhotoCreateWithoutPhotoInput[] | BabyPhotoUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: BabyPhotoCreateOrConnectWithoutPhotoInput | BabyPhotoCreateOrConnectWithoutPhotoInput[]
    upsert?: BabyPhotoUpsertWithWhereUniqueWithoutPhotoInput | BabyPhotoUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: BabyPhotoCreateManyPhotoInputEnvelope
    set?: BabyPhotoWhereUniqueInput | BabyPhotoWhereUniqueInput[]
    disconnect?: BabyPhotoWhereUniqueInput | BabyPhotoWhereUniqueInput[]
    delete?: BabyPhotoWhereUniqueInput | BabyPhotoWhereUniqueInput[]
    connect?: BabyPhotoWhereUniqueInput | BabyPhotoWhereUniqueInput[]
    update?: BabyPhotoUpdateWithWhereUniqueWithoutPhotoInput | BabyPhotoUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: BabyPhotoUpdateManyWithWhereWithoutPhotoInput | BabyPhotoUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: BabyPhotoScalarWhereInput | BabyPhotoScalarWhereInput[]
  }

  export type AlbumPhotoUncheckedUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<AlbumPhotoCreateWithoutPhotoInput, AlbumPhotoUncheckedCreateWithoutPhotoInput> | AlbumPhotoCreateWithoutPhotoInput[] | AlbumPhotoUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: AlbumPhotoCreateOrConnectWithoutPhotoInput | AlbumPhotoCreateOrConnectWithoutPhotoInput[]
    upsert?: AlbumPhotoUpsertWithWhereUniqueWithoutPhotoInput | AlbumPhotoUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: AlbumPhotoCreateManyPhotoInputEnvelope
    set?: AlbumPhotoWhereUniqueInput | AlbumPhotoWhereUniqueInput[]
    disconnect?: AlbumPhotoWhereUniqueInput | AlbumPhotoWhereUniqueInput[]
    delete?: AlbumPhotoWhereUniqueInput | AlbumPhotoWhereUniqueInput[]
    connect?: AlbumPhotoWhereUniqueInput | AlbumPhotoWhereUniqueInput[]
    update?: AlbumPhotoUpdateWithWhereUniqueWithoutPhotoInput | AlbumPhotoUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: AlbumPhotoUpdateManyWithWhereWithoutPhotoInput | AlbumPhotoUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: AlbumPhotoScalarWhereInput | AlbumPhotoScalarWhereInput[]
  }

  export type ActivityPhotoUncheckedUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<ActivityPhotoCreateWithoutPhotoInput, ActivityPhotoUncheckedCreateWithoutPhotoInput> | ActivityPhotoCreateWithoutPhotoInput[] | ActivityPhotoUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ActivityPhotoCreateOrConnectWithoutPhotoInput | ActivityPhotoCreateOrConnectWithoutPhotoInput[]
    upsert?: ActivityPhotoUpsertWithWhereUniqueWithoutPhotoInput | ActivityPhotoUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: ActivityPhotoCreateManyPhotoInputEnvelope
    set?: ActivityPhotoWhereUniqueInput | ActivityPhotoWhereUniqueInput[]
    disconnect?: ActivityPhotoWhereUniqueInput | ActivityPhotoWhereUniqueInput[]
    delete?: ActivityPhotoWhereUniqueInput | ActivityPhotoWhereUniqueInput[]
    connect?: ActivityPhotoWhereUniqueInput | ActivityPhotoWhereUniqueInput[]
    update?: ActivityPhotoUpdateWithWhereUniqueWithoutPhotoInput | ActivityPhotoUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: ActivityPhotoUpdateManyWithWhereWithoutPhotoInput | ActivityPhotoUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: ActivityPhotoScalarWhereInput | ActivityPhotoScalarWhereInput[]
  }

  export type MilestonePhotoUncheckedUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<MilestonePhotoCreateWithoutPhotoInput, MilestonePhotoUncheckedCreateWithoutPhotoInput> | MilestonePhotoCreateWithoutPhotoInput[] | MilestonePhotoUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: MilestonePhotoCreateOrConnectWithoutPhotoInput | MilestonePhotoCreateOrConnectWithoutPhotoInput[]
    upsert?: MilestonePhotoUpsertWithWhereUniqueWithoutPhotoInput | MilestonePhotoUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: MilestonePhotoCreateManyPhotoInputEnvelope
    set?: MilestonePhotoWhereUniqueInput | MilestonePhotoWhereUniqueInput[]
    disconnect?: MilestonePhotoWhereUniqueInput | MilestonePhotoWhereUniqueInput[]
    delete?: MilestonePhotoWhereUniqueInput | MilestonePhotoWhereUniqueInput[]
    connect?: MilestonePhotoWhereUniqueInput | MilestonePhotoWhereUniqueInput[]
    update?: MilestonePhotoUpdateWithWhereUniqueWithoutPhotoInput | MilestonePhotoUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: MilestonePhotoUpdateManyWithWhereWithoutPhotoInput | MilestonePhotoUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: MilestonePhotoScalarWhereInput | MilestonePhotoScalarWhereInput[]
  }

  export type BabyCreateNestedOneWithoutPhotosInput = {
    create?: XOR<BabyCreateWithoutPhotosInput, BabyUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: BabyCreateOrConnectWithoutPhotosInput
    connect?: BabyWhereUniqueInput
  }

  export type PhotoCreateNestedOneWithoutBabyPhotosInput = {
    create?: XOR<PhotoCreateWithoutBabyPhotosInput, PhotoUncheckedCreateWithoutBabyPhotosInput>
    connectOrCreate?: PhotoCreateOrConnectWithoutBabyPhotosInput
    connect?: PhotoWhereUniqueInput
  }

  export type BabyUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<BabyCreateWithoutPhotosInput, BabyUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: BabyCreateOrConnectWithoutPhotosInput
    upsert?: BabyUpsertWithoutPhotosInput
    connect?: BabyWhereUniqueInput
    update?: XOR<XOR<BabyUpdateToOneWithWhereWithoutPhotosInput, BabyUpdateWithoutPhotosInput>, BabyUncheckedUpdateWithoutPhotosInput>
  }

  export type PhotoUpdateOneRequiredWithoutBabyPhotosNestedInput = {
    create?: XOR<PhotoCreateWithoutBabyPhotosInput, PhotoUncheckedCreateWithoutBabyPhotosInput>
    connectOrCreate?: PhotoCreateOrConnectWithoutBabyPhotosInput
    upsert?: PhotoUpsertWithoutBabyPhotosInput
    connect?: PhotoWhereUniqueInput
    update?: XOR<XOR<PhotoUpdateToOneWithWhereWithoutBabyPhotosInput, PhotoUpdateWithoutBabyPhotosInput>, PhotoUncheckedUpdateWithoutBabyPhotosInput>
  }

  export type AlbumCreateNestedOneWithoutPhotosInput = {
    create?: XOR<AlbumCreateWithoutPhotosInput, AlbumUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: AlbumCreateOrConnectWithoutPhotosInput
    connect?: AlbumWhereUniqueInput
  }

  export type PhotoCreateNestedOneWithoutAlbumPhotosInput = {
    create?: XOR<PhotoCreateWithoutAlbumPhotosInput, PhotoUncheckedCreateWithoutAlbumPhotosInput>
    connectOrCreate?: PhotoCreateOrConnectWithoutAlbumPhotosInput
    connect?: PhotoWhereUniqueInput
  }

  export type AlbumUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<AlbumCreateWithoutPhotosInput, AlbumUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: AlbumCreateOrConnectWithoutPhotosInput
    upsert?: AlbumUpsertWithoutPhotosInput
    connect?: AlbumWhereUniqueInput
    update?: XOR<XOR<AlbumUpdateToOneWithWhereWithoutPhotosInput, AlbumUpdateWithoutPhotosInput>, AlbumUncheckedUpdateWithoutPhotosInput>
  }

  export type PhotoUpdateOneRequiredWithoutAlbumPhotosNestedInput = {
    create?: XOR<PhotoCreateWithoutAlbumPhotosInput, PhotoUncheckedCreateWithoutAlbumPhotosInput>
    connectOrCreate?: PhotoCreateOrConnectWithoutAlbumPhotosInput
    upsert?: PhotoUpsertWithoutAlbumPhotosInput
    connect?: PhotoWhereUniqueInput
    update?: XOR<XOR<PhotoUpdateToOneWithWhereWithoutAlbumPhotosInput, PhotoUpdateWithoutAlbumPhotosInput>, PhotoUncheckedUpdateWithoutAlbumPhotosInput>
  }

  export type ActivityCreateNestedOneWithoutPhotosInput = {
    create?: XOR<ActivityCreateWithoutPhotosInput, ActivityUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutPhotosInput
    connect?: ActivityWhereUniqueInput
  }

  export type PhotoCreateNestedOneWithoutActivityPhotosInput = {
    create?: XOR<PhotoCreateWithoutActivityPhotosInput, PhotoUncheckedCreateWithoutActivityPhotosInput>
    connectOrCreate?: PhotoCreateOrConnectWithoutActivityPhotosInput
    connect?: PhotoWhereUniqueInput
  }

  export type ActivityUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<ActivityCreateWithoutPhotosInput, ActivityUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutPhotosInput
    upsert?: ActivityUpsertWithoutPhotosInput
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutPhotosInput, ActivityUpdateWithoutPhotosInput>, ActivityUncheckedUpdateWithoutPhotosInput>
  }

  export type PhotoUpdateOneRequiredWithoutActivityPhotosNestedInput = {
    create?: XOR<PhotoCreateWithoutActivityPhotosInput, PhotoUncheckedCreateWithoutActivityPhotosInput>
    connectOrCreate?: PhotoCreateOrConnectWithoutActivityPhotosInput
    upsert?: PhotoUpsertWithoutActivityPhotosInput
    connect?: PhotoWhereUniqueInput
    update?: XOR<XOR<PhotoUpdateToOneWithWhereWithoutActivityPhotosInput, PhotoUpdateWithoutActivityPhotosInput>, PhotoUncheckedUpdateWithoutActivityPhotosInput>
  }

  export type MilestoneCreateNestedOneWithoutPhotosInput = {
    create?: XOR<MilestoneCreateWithoutPhotosInput, MilestoneUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: MilestoneCreateOrConnectWithoutPhotosInput
    connect?: MilestoneWhereUniqueInput
  }

  export type PhotoCreateNestedOneWithoutMilestonePhotosInput = {
    create?: XOR<PhotoCreateWithoutMilestonePhotosInput, PhotoUncheckedCreateWithoutMilestonePhotosInput>
    connectOrCreate?: PhotoCreateOrConnectWithoutMilestonePhotosInput
    connect?: PhotoWhereUniqueInput
  }

  export type MilestoneUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<MilestoneCreateWithoutPhotosInput, MilestoneUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: MilestoneCreateOrConnectWithoutPhotosInput
    upsert?: MilestoneUpsertWithoutPhotosInput
    connect?: MilestoneWhereUniqueInput
    update?: XOR<XOR<MilestoneUpdateToOneWithWhereWithoutPhotosInput, MilestoneUpdateWithoutPhotosInput>, MilestoneUncheckedUpdateWithoutPhotosInput>
  }

  export type PhotoUpdateOneRequiredWithoutMilestonePhotosNestedInput = {
    create?: XOR<PhotoCreateWithoutMilestonePhotosInput, PhotoUncheckedCreateWithoutMilestonePhotosInput>
    connectOrCreate?: PhotoCreateOrConnectWithoutMilestonePhotosInput
    upsert?: PhotoUpsertWithoutMilestonePhotosInput
    connect?: PhotoWhereUniqueInput
    update?: XOR<XOR<PhotoUpdateToOneWithWhereWithoutMilestonePhotosInput, PhotoUpdateWithoutMilestonePhotosInput>, PhotoUncheckedUpdateWithoutMilestonePhotosInput>
  }

  export type AlbumAccessCreatepermissionsInput = {
    set: string[]
  }

  export type AlbumCreateNestedOneWithoutAccessInput = {
    create?: XOR<AlbumCreateWithoutAccessInput, AlbumUncheckedCreateWithoutAccessInput>
    connectOrCreate?: AlbumCreateOrConnectWithoutAccessInput
    connect?: AlbumWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAlbumAccessInput = {
    create?: XOR<UserCreateWithoutAlbumAccessInput, UserUncheckedCreateWithoutAlbumAccessInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlbumAccessInput
    connect?: UserWhereUniqueInput
  }

  export type AlbumAccessUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AlbumUpdateOneRequiredWithoutAccessNestedInput = {
    create?: XOR<AlbumCreateWithoutAccessInput, AlbumUncheckedCreateWithoutAccessInput>
    connectOrCreate?: AlbumCreateOrConnectWithoutAccessInput
    upsert?: AlbumUpsertWithoutAccessInput
    connect?: AlbumWhereUniqueInput
    update?: XOR<XOR<AlbumUpdateToOneWithWhereWithoutAccessInput, AlbumUpdateWithoutAccessInput>, AlbumUncheckedUpdateWithoutAccessInput>
  }

  export type UserUpdateOneRequiredWithoutAlbumAccessNestedInput = {
    create?: XOR<UserCreateWithoutAlbumAccessInput, UserUncheckedCreateWithoutAlbumAccessInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlbumAccessInput
    upsert?: UserUpsertWithoutAlbumAccessInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAlbumAccessInput, UserUpdateWithoutAlbumAccessInput>, UserUncheckedUpdateWithoutAlbumAccessInput>
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostsInput, UserUpdateWithoutPostsInput>, UserUncheckedUpdateWithoutPostsInput>
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    connect?: PostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    upsert?: PostUpsertWithoutCommentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutCommentsInput, PostUpdateWithoutCommentsInput>, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type BabyCreateNestedOneWithoutParentInvitesInput = {
    create?: XOR<BabyCreateWithoutParentInvitesInput, BabyUncheckedCreateWithoutParentInvitesInput>
    connectOrCreate?: BabyCreateOrConnectWithoutParentInvitesInput
    connect?: BabyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutParentInviteInput = {
    create?: XOR<UserCreateWithoutParentInviteInput, UserUncheckedCreateWithoutParentInviteInput>
    connectOrCreate?: UserCreateOrConnectWithoutParentInviteInput
    connect?: UserWhereUniqueInput
  }

  export type BabyUpdateOneRequiredWithoutParentInvitesNestedInput = {
    create?: XOR<BabyCreateWithoutParentInvitesInput, BabyUncheckedCreateWithoutParentInvitesInput>
    connectOrCreate?: BabyCreateOrConnectWithoutParentInvitesInput
    upsert?: BabyUpsertWithoutParentInvitesInput
    connect?: BabyWhereUniqueInput
    update?: XOR<XOR<BabyUpdateToOneWithWhereWithoutParentInvitesInput, BabyUpdateWithoutParentInvitesInput>, BabyUncheckedUpdateWithoutParentInvitesInput>
  }

  export type UserUpdateOneRequiredWithoutParentInviteNestedInput = {
    create?: XOR<UserCreateWithoutParentInviteInput, UserUncheckedCreateWithoutParentInviteInput>
    connectOrCreate?: UserCreateOrConnectWithoutParentInviteInput
    upsert?: UserUpsertWithoutParentInviteInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutParentInviteInput, UserUpdateWithoutParentInviteInput>, UserUncheckedUpdateWithoutParentInviteInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BabyCaregiverCreateWithoutUserInput = {
    relationship: string
    permissions?: BabyCaregiverCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    baby: BabyCreateNestedOneWithoutCaregiversInput
  }

  export type BabyCaregiverUncheckedCreateWithoutUserInput = {
    id?: number
    relationship: string
    permissions?: BabyCaregiverCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    babyId: number
  }

  export type BabyCaregiverCreateOrConnectWithoutUserInput = {
    where: BabyCaregiverWhereUniqueInput
    create: XOR<BabyCaregiverCreateWithoutUserInput, BabyCaregiverUncheckedCreateWithoutUserInput>
  }

  export type BabyCaregiverCreateManyUserInputEnvelope = {
    data: BabyCaregiverCreateManyUserInput | BabyCaregiverCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BabyCreateWithoutOwnerInput = {
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    caregivers?: BabyCaregiverCreateNestedManyWithoutBabyInput
    eliminations?: EliminationCreateNestedManyWithoutBabyInput
    feedings?: FeedingCreateNestedManyWithoutBabyInput
    sleepsleepSessions?: SleepCreateNestedManyWithoutBabyInput
    activities?: ActivityCreateNestedManyWithoutBabyInput
    photos?: BabyPhotoCreateNestedManyWithoutBabyInput
    milestones?: MilestoneCreateNestedManyWithoutBabyInput
    healthRecords?: HealthRecordCreateNestedManyWithoutBabyInput
    measurements?: MeasurementCreateNestedManyWithoutBabyInput
    albums?: AlbumCreateNestedManyWithoutBabyInput
    parentInvites?: ParentInviteCreateNestedManyWithoutBabyInput
  }

  export type BabyUncheckedCreateWithoutOwnerInput = {
    id?: number
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    caregivers?: BabyCaregiverUncheckedCreateNestedManyWithoutBabyInput
    eliminations?: EliminationUncheckedCreateNestedManyWithoutBabyInput
    feedings?: FeedingUncheckedCreateNestedManyWithoutBabyInput
    sleepsleepSessions?: SleepUncheckedCreateNestedManyWithoutBabyInput
    activities?: ActivityUncheckedCreateNestedManyWithoutBabyInput
    photos?: BabyPhotoUncheckedCreateNestedManyWithoutBabyInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutBabyInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutBabyInput
    measurements?: MeasurementUncheckedCreateNestedManyWithoutBabyInput
    albums?: AlbumUncheckedCreateNestedManyWithoutBabyInput
    parentInvites?: ParentInviteUncheckedCreateNestedManyWithoutBabyInput
  }

  export type BabyCreateOrConnectWithoutOwnerInput = {
    where: BabyWhereUniqueInput
    create: XOR<BabyCreateWithoutOwnerInput, BabyUncheckedCreateWithoutOwnerInput>
  }

  export type BabyCreateManyOwnerInputEnvelope = {
    data: BabyCreateManyOwnerInput | BabyCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutAuthorInput = {
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutAuthorInput = {
    id?: number
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutAuthorInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostCreateManyAuthorInputEnvelope = {
    data: PostCreateManyAuthorInput | PostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutAuthorInput = {
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutAuthorInput = {
    id?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postId: number
  }

  export type CommentCreateOrConnectWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentCreateManyAuthorInputEnvelope = {
    data: CommentCreateManyAuthorInput | CommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ParentInviteCreateWithoutSentByInput = {
    email: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    baby: BabyCreateNestedOneWithoutParentInvitesInput
  }

  export type ParentInviteUncheckedCreateWithoutSentByInput = {
    id?: number
    email: string
    babyId: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentInviteCreateOrConnectWithoutSentByInput = {
    where: ParentInviteWhereUniqueInput
    create: XOR<ParentInviteCreateWithoutSentByInput, ParentInviteUncheckedCreateWithoutSentByInput>
  }

  export type ParentInviteCreateManySentByInputEnvelope = {
    data: ParentInviteCreateManySentByInput | ParentInviteCreateManySentByInput[]
    skipDuplicates?: boolean
  }

  export type AlbumAccessCreateWithoutUserInput = {
    permissions?: AlbumAccessCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    album: AlbumCreateNestedOneWithoutAccessInput
  }

  export type AlbumAccessUncheckedCreateWithoutUserInput = {
    id?: number
    permissions?: AlbumAccessCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    albumId: number
  }

  export type AlbumAccessCreateOrConnectWithoutUserInput = {
    where: AlbumAccessWhereUniqueInput
    create: XOR<AlbumAccessCreateWithoutUserInput, AlbumAccessUncheckedCreateWithoutUserInput>
  }

  export type AlbumAccessCreateManyUserInputEnvelope = {
    data: AlbumAccessCreateManyUserInput | AlbumAccessCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BabyCaregiverUpsertWithWhereUniqueWithoutUserInput = {
    where: BabyCaregiverWhereUniqueInput
    update: XOR<BabyCaregiverUpdateWithoutUserInput, BabyCaregiverUncheckedUpdateWithoutUserInput>
    create: XOR<BabyCaregiverCreateWithoutUserInput, BabyCaregiverUncheckedCreateWithoutUserInput>
  }

  export type BabyCaregiverUpdateWithWhereUniqueWithoutUserInput = {
    where: BabyCaregiverWhereUniqueInput
    data: XOR<BabyCaregiverUpdateWithoutUserInput, BabyCaregiverUncheckedUpdateWithoutUserInput>
  }

  export type BabyCaregiverUpdateManyWithWhereWithoutUserInput = {
    where: BabyCaregiverScalarWhereInput
    data: XOR<BabyCaregiverUpdateManyMutationInput, BabyCaregiverUncheckedUpdateManyWithoutUserInput>
  }

  export type BabyCaregiverScalarWhereInput = {
    AND?: BabyCaregiverScalarWhereInput | BabyCaregiverScalarWhereInput[]
    OR?: BabyCaregiverScalarWhereInput[]
    NOT?: BabyCaregiverScalarWhereInput | BabyCaregiverScalarWhereInput[]
    id?: IntFilter<"BabyCaregiver"> | number
    relationship?: StringFilter<"BabyCaregiver"> | string
    permissions?: StringNullableListFilter<"BabyCaregiver">
    createdAt?: DateTimeFilter<"BabyCaregiver"> | Date | string
    updatedAt?: DateTimeFilter<"BabyCaregiver"> | Date | string
    babyId?: IntFilter<"BabyCaregiver"> | number
    userId?: IntFilter<"BabyCaregiver"> | number
  }

  export type BabyUpsertWithWhereUniqueWithoutOwnerInput = {
    where: BabyWhereUniqueInput
    update: XOR<BabyUpdateWithoutOwnerInput, BabyUncheckedUpdateWithoutOwnerInput>
    create: XOR<BabyCreateWithoutOwnerInput, BabyUncheckedCreateWithoutOwnerInput>
  }

  export type BabyUpdateWithWhereUniqueWithoutOwnerInput = {
    where: BabyWhereUniqueInput
    data: XOR<BabyUpdateWithoutOwnerInput, BabyUncheckedUpdateWithoutOwnerInput>
  }

  export type BabyUpdateManyWithWhereWithoutOwnerInput = {
    where: BabyScalarWhereInput
    data: XOR<BabyUpdateManyMutationInput, BabyUncheckedUpdateManyWithoutOwnerInput>
  }

  export type BabyScalarWhereInput = {
    AND?: BabyScalarWhereInput | BabyScalarWhereInput[]
    OR?: BabyScalarWhereInput[]
    NOT?: BabyScalarWhereInput | BabyScalarWhereInput[]
    id?: IntFilter<"Baby"> | number
    firstName?: StringFilter<"Baby"> | string
    lastName?: StringFilter<"Baby"> | string
    dateOfBirth?: DateTimeFilter<"Baby"> | Date | string
    gender?: StringNullableFilter<"Baby"> | string | null
    createdAt?: DateTimeFilter<"Baby"> | Date | string
    updatedAt?: DateTimeFilter<"Baby"> | Date | string
    ownerId?: IntFilter<"Baby"> | number
  }

  export type PostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
  }

  export type PostUpdateManyWithWhereWithoutAuthorInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: IntFilter<"Post"> | number
    title?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    authorId?: IntFilter<"Post"> | number
  }

  export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
  }

  export type CommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: IntFilter<"Comment"> | number
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    postId?: IntFilter<"Comment"> | number
    authorId?: IntFilter<"Comment"> | number
  }

  export type ParentInviteUpsertWithWhereUniqueWithoutSentByInput = {
    where: ParentInviteWhereUniqueInput
    update: XOR<ParentInviteUpdateWithoutSentByInput, ParentInviteUncheckedUpdateWithoutSentByInput>
    create: XOR<ParentInviteCreateWithoutSentByInput, ParentInviteUncheckedCreateWithoutSentByInput>
  }

  export type ParentInviteUpdateWithWhereUniqueWithoutSentByInput = {
    where: ParentInviteWhereUniqueInput
    data: XOR<ParentInviteUpdateWithoutSentByInput, ParentInviteUncheckedUpdateWithoutSentByInput>
  }

  export type ParentInviteUpdateManyWithWhereWithoutSentByInput = {
    where: ParentInviteScalarWhereInput
    data: XOR<ParentInviteUpdateManyMutationInput, ParentInviteUncheckedUpdateManyWithoutSentByInput>
  }

  export type ParentInviteScalarWhereInput = {
    AND?: ParentInviteScalarWhereInput | ParentInviteScalarWhereInput[]
    OR?: ParentInviteScalarWhereInput[]
    NOT?: ParentInviteScalarWhereInput | ParentInviteScalarWhereInput[]
    id?: IntFilter<"ParentInvite"> | number
    email?: StringFilter<"ParentInvite"> | string
    babyId?: IntFilter<"ParentInvite"> | number
    senderId?: IntFilter<"ParentInvite"> | number
    status?: StringFilter<"ParentInvite"> | string
    createdAt?: DateTimeFilter<"ParentInvite"> | Date | string
    updatedAt?: DateTimeFilter<"ParentInvite"> | Date | string
  }

  export type AlbumAccessUpsertWithWhereUniqueWithoutUserInput = {
    where: AlbumAccessWhereUniqueInput
    update: XOR<AlbumAccessUpdateWithoutUserInput, AlbumAccessUncheckedUpdateWithoutUserInput>
    create: XOR<AlbumAccessCreateWithoutUserInput, AlbumAccessUncheckedCreateWithoutUserInput>
  }

  export type AlbumAccessUpdateWithWhereUniqueWithoutUserInput = {
    where: AlbumAccessWhereUniqueInput
    data: XOR<AlbumAccessUpdateWithoutUserInput, AlbumAccessUncheckedUpdateWithoutUserInput>
  }

  export type AlbumAccessUpdateManyWithWhereWithoutUserInput = {
    where: AlbumAccessScalarWhereInput
    data: XOR<AlbumAccessUpdateManyMutationInput, AlbumAccessUncheckedUpdateManyWithoutUserInput>
  }

  export type AlbumAccessScalarWhereInput = {
    AND?: AlbumAccessScalarWhereInput | AlbumAccessScalarWhereInput[]
    OR?: AlbumAccessScalarWhereInput[]
    NOT?: AlbumAccessScalarWhereInput | AlbumAccessScalarWhereInput[]
    id?: IntFilter<"AlbumAccess"> | number
    permissions?: StringNullableListFilter<"AlbumAccess">
    createdAt?: DateTimeFilter<"AlbumAccess"> | Date | string
    updatedAt?: DateTimeFilter<"AlbumAccess"> | Date | string
    albumId?: IntFilter<"AlbumAccess"> | number
    userId?: IntFilter<"AlbumAccess"> | number
  }

  export type UserCreateWithoutOwnedBabiesInput = {
    email: string
    passwordHash: string
    firstName?: string
    lastName?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babies?: BabyCaregiverCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    ParentInvite?: ParentInviteCreateNestedManyWithoutSentByInput
    AlbumAccess?: AlbumAccessCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOwnedBabiesInput = {
    id?: number
    email: string
    passwordHash: string
    firstName?: string
    lastName?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babies?: BabyCaregiverUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ParentInvite?: ParentInviteUncheckedCreateNestedManyWithoutSentByInput
    AlbumAccess?: AlbumAccessUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOwnedBabiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedBabiesInput, UserUncheckedCreateWithoutOwnedBabiesInput>
  }

  export type BabyCaregiverCreateWithoutBabyInput = {
    relationship: string
    permissions?: BabyCaregiverCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBabiesInput
  }

  export type BabyCaregiverUncheckedCreateWithoutBabyInput = {
    id?: number
    relationship: string
    permissions?: BabyCaregiverCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
  }

  export type BabyCaregiverCreateOrConnectWithoutBabyInput = {
    where: BabyCaregiverWhereUniqueInput
    create: XOR<BabyCaregiverCreateWithoutBabyInput, BabyCaregiverUncheckedCreateWithoutBabyInput>
  }

  export type BabyCaregiverCreateManyBabyInputEnvelope = {
    data: BabyCaregiverCreateManyBabyInput | BabyCaregiverCreateManyBabyInput[]
    skipDuplicates?: boolean
  }

  export type EliminationCreateWithoutBabyInput = {
    timestamp: Date | string
    type: string
    weight?: number | null
    success: boolean
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EliminationUncheckedCreateWithoutBabyInput = {
    id?: number
    timestamp: Date | string
    type: string
    weight?: number | null
    success: boolean
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EliminationCreateOrConnectWithoutBabyInput = {
    where: EliminationWhereUniqueInput
    create: XOR<EliminationCreateWithoutBabyInput, EliminationUncheckedCreateWithoutBabyInput>
  }

  export type EliminationCreateManyBabyInputEnvelope = {
    data: EliminationCreateManyBabyInput | EliminationCreateManyBabyInput[]
    skipDuplicates?: boolean
  }

  export type FeedingCreateWithoutBabyInput = {
    startTime: Date | string
    endTime?: Date | string | null
    type: string
    side?: string | null
    amount?: number | null
    food?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedingUncheckedCreateWithoutBabyInput = {
    id?: number
    startTime: Date | string
    endTime?: Date | string | null
    type: string
    side?: string | null
    amount?: number | null
    food?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedingCreateOrConnectWithoutBabyInput = {
    where: FeedingWhereUniqueInput
    create: XOR<FeedingCreateWithoutBabyInput, FeedingUncheckedCreateWithoutBabyInput>
  }

  export type FeedingCreateManyBabyInputEnvelope = {
    data: FeedingCreateManyBabyInput | FeedingCreateManyBabyInput[]
    skipDuplicates?: boolean
  }

  export type SleepCreateWithoutBabyInput = {
    startTime: Date | string
    endTime?: Date | string | null
    how?: string | null
    whereFellAsleep?: string | null
    whereSlept?: string | null
    type: string
    quality?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SleepUncheckedCreateWithoutBabyInput = {
    id?: number
    startTime: Date | string
    endTime?: Date | string | null
    how?: string | null
    whereFellAsleep?: string | null
    whereSlept?: string | null
    type: string
    quality?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SleepCreateOrConnectWithoutBabyInput = {
    where: SleepWhereUniqueInput
    create: XOR<SleepCreateWithoutBabyInput, SleepUncheckedCreateWithoutBabyInput>
  }

  export type SleepCreateManyBabyInputEnvelope = {
    data: SleepCreateManyBabyInput | SleepCreateManyBabyInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutBabyInput = {
    startTime: Date | string
    endTime?: Date | string | null
    type: string
    description?: string | null
    milestone?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: ActivityPhotoCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutBabyInput = {
    id?: number
    startTime: Date | string
    endTime?: Date | string | null
    type: string
    description?: string | null
    milestone?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: ActivityPhotoUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutBabyInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutBabyInput, ActivityUncheckedCreateWithoutBabyInput>
  }

  export type ActivityCreateManyBabyInputEnvelope = {
    data: ActivityCreateManyBabyInput | ActivityCreateManyBabyInput[]
    skipDuplicates?: boolean
  }

  export type BabyPhotoCreateWithoutBabyInput = {
    createdAt?: Date | string
    photo: PhotoCreateNestedOneWithoutBabyPhotosInput
  }

  export type BabyPhotoUncheckedCreateWithoutBabyInput = {
    photoId: number
    createdAt?: Date | string
  }

  export type BabyPhotoCreateOrConnectWithoutBabyInput = {
    where: BabyPhotoWhereUniqueInput
    create: XOR<BabyPhotoCreateWithoutBabyInput, BabyPhotoUncheckedCreateWithoutBabyInput>
  }

  export type BabyPhotoCreateManyBabyInputEnvelope = {
    data: BabyPhotoCreateManyBabyInput | BabyPhotoCreateManyBabyInput[]
    skipDuplicates?: boolean
  }

  export type MilestoneCreateWithoutBabyInput = {
    date: Date | string
    category: string
    title: string
    description?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: MilestonePhotoCreateNestedManyWithoutMilestoneInput
  }

  export type MilestoneUncheckedCreateWithoutBabyInput = {
    id?: number
    date: Date | string
    category: string
    title: string
    description?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: MilestonePhotoUncheckedCreateNestedManyWithoutMilestoneInput
  }

  export type MilestoneCreateOrConnectWithoutBabyInput = {
    where: MilestoneWhereUniqueInput
    create: XOR<MilestoneCreateWithoutBabyInput, MilestoneUncheckedCreateWithoutBabyInput>
  }

  export type MilestoneCreateManyBabyInputEnvelope = {
    data: MilestoneCreateManyBabyInput | MilestoneCreateManyBabyInput[]
    skipDuplicates?: boolean
  }

  export type HealthRecordCreateWithoutBabyInput = {
    timestamp: Date | string
    type: string
    value?: number | null
    description?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthRecordUncheckedCreateWithoutBabyInput = {
    id?: number
    timestamp: Date | string
    type: string
    value?: number | null
    description?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthRecordCreateOrConnectWithoutBabyInput = {
    where: HealthRecordWhereUniqueInput
    create: XOR<HealthRecordCreateWithoutBabyInput, HealthRecordUncheckedCreateWithoutBabyInput>
  }

  export type HealthRecordCreateManyBabyInputEnvelope = {
    data: HealthRecordCreateManyBabyInput | HealthRecordCreateManyBabyInput[]
    skipDuplicates?: boolean
  }

  export type MeasurementCreateWithoutBabyInput = {
    date: Date | string
    weight?: number | null
    height?: number | null
    headCirc?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeasurementUncheckedCreateWithoutBabyInput = {
    id?: number
    date: Date | string
    weight?: number | null
    height?: number | null
    headCirc?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeasurementCreateOrConnectWithoutBabyInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutBabyInput, MeasurementUncheckedCreateWithoutBabyInput>
  }

  export type MeasurementCreateManyBabyInputEnvelope = {
    data: MeasurementCreateManyBabyInput | MeasurementCreateManyBabyInput[]
    skipDuplicates?: boolean
  }

  export type AlbumCreateWithoutBabyInput = {
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: AlbumPhotoCreateNestedManyWithoutAlbumInput
    access?: AlbumAccessCreateNestedManyWithoutAlbumInput
  }

  export type AlbumUncheckedCreateWithoutBabyInput = {
    id?: number
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: AlbumPhotoUncheckedCreateNestedManyWithoutAlbumInput
    access?: AlbumAccessUncheckedCreateNestedManyWithoutAlbumInput
  }

  export type AlbumCreateOrConnectWithoutBabyInput = {
    where: AlbumWhereUniqueInput
    create: XOR<AlbumCreateWithoutBabyInput, AlbumUncheckedCreateWithoutBabyInput>
  }

  export type AlbumCreateManyBabyInputEnvelope = {
    data: AlbumCreateManyBabyInput | AlbumCreateManyBabyInput[]
    skipDuplicates?: boolean
  }

  export type ParentInviteCreateWithoutBabyInput = {
    email: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sentBy: UserCreateNestedOneWithoutParentInviteInput
  }

  export type ParentInviteUncheckedCreateWithoutBabyInput = {
    id?: number
    email: string
    senderId: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentInviteCreateOrConnectWithoutBabyInput = {
    where: ParentInviteWhereUniqueInput
    create: XOR<ParentInviteCreateWithoutBabyInput, ParentInviteUncheckedCreateWithoutBabyInput>
  }

  export type ParentInviteCreateManyBabyInputEnvelope = {
    data: ParentInviteCreateManyBabyInput | ParentInviteCreateManyBabyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOwnedBabiesInput = {
    update: XOR<UserUpdateWithoutOwnedBabiesInput, UserUncheckedUpdateWithoutOwnedBabiesInput>
    create: XOR<UserCreateWithoutOwnedBabiesInput, UserUncheckedCreateWithoutOwnedBabiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedBabiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedBabiesInput, UserUncheckedUpdateWithoutOwnedBabiesInput>
  }

  export type UserUpdateWithoutOwnedBabiesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babies?: BabyCaregiverUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    ParentInvite?: ParentInviteUpdateManyWithoutSentByNestedInput
    AlbumAccess?: AlbumAccessUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedBabiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babies?: BabyCaregiverUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    ParentInvite?: ParentInviteUncheckedUpdateManyWithoutSentByNestedInput
    AlbumAccess?: AlbumAccessUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BabyCaregiverUpsertWithWhereUniqueWithoutBabyInput = {
    where: BabyCaregiverWhereUniqueInput
    update: XOR<BabyCaregiverUpdateWithoutBabyInput, BabyCaregiverUncheckedUpdateWithoutBabyInput>
    create: XOR<BabyCaregiverCreateWithoutBabyInput, BabyCaregiverUncheckedCreateWithoutBabyInput>
  }

  export type BabyCaregiverUpdateWithWhereUniqueWithoutBabyInput = {
    where: BabyCaregiverWhereUniqueInput
    data: XOR<BabyCaregiverUpdateWithoutBabyInput, BabyCaregiverUncheckedUpdateWithoutBabyInput>
  }

  export type BabyCaregiverUpdateManyWithWhereWithoutBabyInput = {
    where: BabyCaregiverScalarWhereInput
    data: XOR<BabyCaregiverUpdateManyMutationInput, BabyCaregiverUncheckedUpdateManyWithoutBabyInput>
  }

  export type EliminationUpsertWithWhereUniqueWithoutBabyInput = {
    where: EliminationWhereUniqueInput
    update: XOR<EliminationUpdateWithoutBabyInput, EliminationUncheckedUpdateWithoutBabyInput>
    create: XOR<EliminationCreateWithoutBabyInput, EliminationUncheckedCreateWithoutBabyInput>
  }

  export type EliminationUpdateWithWhereUniqueWithoutBabyInput = {
    where: EliminationWhereUniqueInput
    data: XOR<EliminationUpdateWithoutBabyInput, EliminationUncheckedUpdateWithoutBabyInput>
  }

  export type EliminationUpdateManyWithWhereWithoutBabyInput = {
    where: EliminationScalarWhereInput
    data: XOR<EliminationUpdateManyMutationInput, EliminationUncheckedUpdateManyWithoutBabyInput>
  }

  export type EliminationScalarWhereInput = {
    AND?: EliminationScalarWhereInput | EliminationScalarWhereInput[]
    OR?: EliminationScalarWhereInput[]
    NOT?: EliminationScalarWhereInput | EliminationScalarWhereInput[]
    id?: IntFilter<"Elimination"> | number
    timestamp?: DateTimeFilter<"Elimination"> | Date | string
    type?: StringFilter<"Elimination"> | string
    weight?: FloatNullableFilter<"Elimination"> | number | null
    success?: BoolFilter<"Elimination"> | boolean
    location?: StringNullableFilter<"Elimination"> | string | null
    notes?: StringNullableFilter<"Elimination"> | string | null
    createdAt?: DateTimeFilter<"Elimination"> | Date | string
    updatedAt?: DateTimeFilter<"Elimination"> | Date | string
    babyId?: IntFilter<"Elimination"> | number
  }

  export type FeedingUpsertWithWhereUniqueWithoutBabyInput = {
    where: FeedingWhereUniqueInput
    update: XOR<FeedingUpdateWithoutBabyInput, FeedingUncheckedUpdateWithoutBabyInput>
    create: XOR<FeedingCreateWithoutBabyInput, FeedingUncheckedCreateWithoutBabyInput>
  }

  export type FeedingUpdateWithWhereUniqueWithoutBabyInput = {
    where: FeedingWhereUniqueInput
    data: XOR<FeedingUpdateWithoutBabyInput, FeedingUncheckedUpdateWithoutBabyInput>
  }

  export type FeedingUpdateManyWithWhereWithoutBabyInput = {
    where: FeedingScalarWhereInput
    data: XOR<FeedingUpdateManyMutationInput, FeedingUncheckedUpdateManyWithoutBabyInput>
  }

  export type FeedingScalarWhereInput = {
    AND?: FeedingScalarWhereInput | FeedingScalarWhereInput[]
    OR?: FeedingScalarWhereInput[]
    NOT?: FeedingScalarWhereInput | FeedingScalarWhereInput[]
    id?: IntFilter<"Feeding"> | number
    startTime?: DateTimeFilter<"Feeding"> | Date | string
    endTime?: DateTimeNullableFilter<"Feeding"> | Date | string | null
    type?: StringFilter<"Feeding"> | string
    side?: StringNullableFilter<"Feeding"> | string | null
    amount?: FloatNullableFilter<"Feeding"> | number | null
    food?: StringNullableFilter<"Feeding"> | string | null
    notes?: StringNullableFilter<"Feeding"> | string | null
    createdAt?: DateTimeFilter<"Feeding"> | Date | string
    updatedAt?: DateTimeFilter<"Feeding"> | Date | string
    babyId?: IntFilter<"Feeding"> | number
  }

  export type SleepUpsertWithWhereUniqueWithoutBabyInput = {
    where: SleepWhereUniqueInput
    update: XOR<SleepUpdateWithoutBabyInput, SleepUncheckedUpdateWithoutBabyInput>
    create: XOR<SleepCreateWithoutBabyInput, SleepUncheckedCreateWithoutBabyInput>
  }

  export type SleepUpdateWithWhereUniqueWithoutBabyInput = {
    where: SleepWhereUniqueInput
    data: XOR<SleepUpdateWithoutBabyInput, SleepUncheckedUpdateWithoutBabyInput>
  }

  export type SleepUpdateManyWithWhereWithoutBabyInput = {
    where: SleepScalarWhereInput
    data: XOR<SleepUpdateManyMutationInput, SleepUncheckedUpdateManyWithoutBabyInput>
  }

  export type SleepScalarWhereInput = {
    AND?: SleepScalarWhereInput | SleepScalarWhereInput[]
    OR?: SleepScalarWhereInput[]
    NOT?: SleepScalarWhereInput | SleepScalarWhereInput[]
    id?: IntFilter<"Sleep"> | number
    startTime?: DateTimeFilter<"Sleep"> | Date | string
    endTime?: DateTimeNullableFilter<"Sleep"> | Date | string | null
    how?: StringNullableFilter<"Sleep"> | string | null
    whereFellAsleep?: StringNullableFilter<"Sleep"> | string | null
    whereSlept?: StringNullableFilter<"Sleep"> | string | null
    type?: StringFilter<"Sleep"> | string
    quality?: IntNullableFilter<"Sleep"> | number | null
    notes?: StringNullableFilter<"Sleep"> | string | null
    createdAt?: DateTimeFilter<"Sleep"> | Date | string
    updatedAt?: DateTimeFilter<"Sleep"> | Date | string
    babyId?: IntFilter<"Sleep"> | number
  }

  export type ActivityUpsertWithWhereUniqueWithoutBabyInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutBabyInput, ActivityUncheckedUpdateWithoutBabyInput>
    create: XOR<ActivityCreateWithoutBabyInput, ActivityUncheckedCreateWithoutBabyInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutBabyInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutBabyInput, ActivityUncheckedUpdateWithoutBabyInput>
  }

  export type ActivityUpdateManyWithWhereWithoutBabyInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutBabyInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    OR?: ActivityScalarWhereInput[]
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    id?: IntFilter<"Activity"> | number
    startTime?: DateTimeFilter<"Activity"> | Date | string
    endTime?: DateTimeNullableFilter<"Activity"> | Date | string | null
    type?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    milestone?: BoolFilter<"Activity"> | boolean
    notes?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    babyId?: IntFilter<"Activity"> | number
  }

  export type BabyPhotoUpsertWithWhereUniqueWithoutBabyInput = {
    where: BabyPhotoWhereUniqueInput
    update: XOR<BabyPhotoUpdateWithoutBabyInput, BabyPhotoUncheckedUpdateWithoutBabyInput>
    create: XOR<BabyPhotoCreateWithoutBabyInput, BabyPhotoUncheckedCreateWithoutBabyInput>
  }

  export type BabyPhotoUpdateWithWhereUniqueWithoutBabyInput = {
    where: BabyPhotoWhereUniqueInput
    data: XOR<BabyPhotoUpdateWithoutBabyInput, BabyPhotoUncheckedUpdateWithoutBabyInput>
  }

  export type BabyPhotoUpdateManyWithWhereWithoutBabyInput = {
    where: BabyPhotoScalarWhereInput
    data: XOR<BabyPhotoUpdateManyMutationInput, BabyPhotoUncheckedUpdateManyWithoutBabyInput>
  }

  export type BabyPhotoScalarWhereInput = {
    AND?: BabyPhotoScalarWhereInput | BabyPhotoScalarWhereInput[]
    OR?: BabyPhotoScalarWhereInput[]
    NOT?: BabyPhotoScalarWhereInput | BabyPhotoScalarWhereInput[]
    babyId?: IntFilter<"BabyPhoto"> | number
    photoId?: IntFilter<"BabyPhoto"> | number
    createdAt?: DateTimeFilter<"BabyPhoto"> | Date | string
  }

  export type MilestoneUpsertWithWhereUniqueWithoutBabyInput = {
    where: MilestoneWhereUniqueInput
    update: XOR<MilestoneUpdateWithoutBabyInput, MilestoneUncheckedUpdateWithoutBabyInput>
    create: XOR<MilestoneCreateWithoutBabyInput, MilestoneUncheckedCreateWithoutBabyInput>
  }

  export type MilestoneUpdateWithWhereUniqueWithoutBabyInput = {
    where: MilestoneWhereUniqueInput
    data: XOR<MilestoneUpdateWithoutBabyInput, MilestoneUncheckedUpdateWithoutBabyInput>
  }

  export type MilestoneUpdateManyWithWhereWithoutBabyInput = {
    where: MilestoneScalarWhereInput
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyWithoutBabyInput>
  }

  export type MilestoneScalarWhereInput = {
    AND?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    OR?: MilestoneScalarWhereInput[]
    NOT?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    id?: IntFilter<"Milestone"> | number
    date?: DateTimeFilter<"Milestone"> | Date | string
    category?: StringFilter<"Milestone"> | string
    title?: StringFilter<"Milestone"> | string
    description?: StringNullableFilter<"Milestone"> | string | null
    notes?: StringNullableFilter<"Milestone"> | string | null
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
    updatedAt?: DateTimeFilter<"Milestone"> | Date | string
    babyId?: IntFilter<"Milestone"> | number
  }

  export type HealthRecordUpsertWithWhereUniqueWithoutBabyInput = {
    where: HealthRecordWhereUniqueInput
    update: XOR<HealthRecordUpdateWithoutBabyInput, HealthRecordUncheckedUpdateWithoutBabyInput>
    create: XOR<HealthRecordCreateWithoutBabyInput, HealthRecordUncheckedCreateWithoutBabyInput>
  }

  export type HealthRecordUpdateWithWhereUniqueWithoutBabyInput = {
    where: HealthRecordWhereUniqueInput
    data: XOR<HealthRecordUpdateWithoutBabyInput, HealthRecordUncheckedUpdateWithoutBabyInput>
  }

  export type HealthRecordUpdateManyWithWhereWithoutBabyInput = {
    where: HealthRecordScalarWhereInput
    data: XOR<HealthRecordUpdateManyMutationInput, HealthRecordUncheckedUpdateManyWithoutBabyInput>
  }

  export type HealthRecordScalarWhereInput = {
    AND?: HealthRecordScalarWhereInput | HealthRecordScalarWhereInput[]
    OR?: HealthRecordScalarWhereInput[]
    NOT?: HealthRecordScalarWhereInput | HealthRecordScalarWhereInput[]
    id?: IntFilter<"HealthRecord"> | number
    timestamp?: DateTimeFilter<"HealthRecord"> | Date | string
    type?: StringFilter<"HealthRecord"> | string
    value?: FloatNullableFilter<"HealthRecord"> | number | null
    description?: StringNullableFilter<"HealthRecord"> | string | null
    notes?: StringNullableFilter<"HealthRecord"> | string | null
    createdAt?: DateTimeFilter<"HealthRecord"> | Date | string
    updatedAt?: DateTimeFilter<"HealthRecord"> | Date | string
    babyId?: IntFilter<"HealthRecord"> | number
  }

  export type MeasurementUpsertWithWhereUniqueWithoutBabyInput = {
    where: MeasurementWhereUniqueInput
    update: XOR<MeasurementUpdateWithoutBabyInput, MeasurementUncheckedUpdateWithoutBabyInput>
    create: XOR<MeasurementCreateWithoutBabyInput, MeasurementUncheckedCreateWithoutBabyInput>
  }

  export type MeasurementUpdateWithWhereUniqueWithoutBabyInput = {
    where: MeasurementWhereUniqueInput
    data: XOR<MeasurementUpdateWithoutBabyInput, MeasurementUncheckedUpdateWithoutBabyInput>
  }

  export type MeasurementUpdateManyWithWhereWithoutBabyInput = {
    where: MeasurementScalarWhereInput
    data: XOR<MeasurementUpdateManyMutationInput, MeasurementUncheckedUpdateManyWithoutBabyInput>
  }

  export type MeasurementScalarWhereInput = {
    AND?: MeasurementScalarWhereInput | MeasurementScalarWhereInput[]
    OR?: MeasurementScalarWhereInput[]
    NOT?: MeasurementScalarWhereInput | MeasurementScalarWhereInput[]
    id?: IntFilter<"Measurement"> | number
    date?: DateTimeFilter<"Measurement"> | Date | string
    weight?: FloatNullableFilter<"Measurement"> | number | null
    height?: FloatNullableFilter<"Measurement"> | number | null
    headCirc?: FloatNullableFilter<"Measurement"> | number | null
    notes?: StringNullableFilter<"Measurement"> | string | null
    createdAt?: DateTimeFilter<"Measurement"> | Date | string
    updatedAt?: DateTimeFilter<"Measurement"> | Date | string
    babyId?: IntFilter<"Measurement"> | number
  }

  export type AlbumUpsertWithWhereUniqueWithoutBabyInput = {
    where: AlbumWhereUniqueInput
    update: XOR<AlbumUpdateWithoutBabyInput, AlbumUncheckedUpdateWithoutBabyInput>
    create: XOR<AlbumCreateWithoutBabyInput, AlbumUncheckedCreateWithoutBabyInput>
  }

  export type AlbumUpdateWithWhereUniqueWithoutBabyInput = {
    where: AlbumWhereUniqueInput
    data: XOR<AlbumUpdateWithoutBabyInput, AlbumUncheckedUpdateWithoutBabyInput>
  }

  export type AlbumUpdateManyWithWhereWithoutBabyInput = {
    where: AlbumScalarWhereInput
    data: XOR<AlbumUpdateManyMutationInput, AlbumUncheckedUpdateManyWithoutBabyInput>
  }

  export type AlbumScalarWhereInput = {
    AND?: AlbumScalarWhereInput | AlbumScalarWhereInput[]
    OR?: AlbumScalarWhereInput[]
    NOT?: AlbumScalarWhereInput | AlbumScalarWhereInput[]
    id?: IntFilter<"Album"> | number
    title?: StringFilter<"Album"> | string
    description?: StringNullableFilter<"Album"> | string | null
    createdAt?: DateTimeFilter<"Album"> | Date | string
    updatedAt?: DateTimeFilter<"Album"> | Date | string
    babyId?: IntFilter<"Album"> | number
  }

  export type ParentInviteUpsertWithWhereUniqueWithoutBabyInput = {
    where: ParentInviteWhereUniqueInput
    update: XOR<ParentInviteUpdateWithoutBabyInput, ParentInviteUncheckedUpdateWithoutBabyInput>
    create: XOR<ParentInviteCreateWithoutBabyInput, ParentInviteUncheckedCreateWithoutBabyInput>
  }

  export type ParentInviteUpdateWithWhereUniqueWithoutBabyInput = {
    where: ParentInviteWhereUniqueInput
    data: XOR<ParentInviteUpdateWithoutBabyInput, ParentInviteUncheckedUpdateWithoutBabyInput>
  }

  export type ParentInviteUpdateManyWithWhereWithoutBabyInput = {
    where: ParentInviteScalarWhereInput
    data: XOR<ParentInviteUpdateManyMutationInput, ParentInviteUncheckedUpdateManyWithoutBabyInput>
  }

  export type BabyCreateWithoutCaregiversInput = {
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedBabiesInput
    eliminations?: EliminationCreateNestedManyWithoutBabyInput
    feedings?: FeedingCreateNestedManyWithoutBabyInput
    sleepsleepSessions?: SleepCreateNestedManyWithoutBabyInput
    activities?: ActivityCreateNestedManyWithoutBabyInput
    photos?: BabyPhotoCreateNestedManyWithoutBabyInput
    milestones?: MilestoneCreateNestedManyWithoutBabyInput
    healthRecords?: HealthRecordCreateNestedManyWithoutBabyInput
    measurements?: MeasurementCreateNestedManyWithoutBabyInput
    albums?: AlbumCreateNestedManyWithoutBabyInput
    parentInvites?: ParentInviteCreateNestedManyWithoutBabyInput
  }

  export type BabyUncheckedCreateWithoutCaregiversInput = {
    id?: number
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: number
    eliminations?: EliminationUncheckedCreateNestedManyWithoutBabyInput
    feedings?: FeedingUncheckedCreateNestedManyWithoutBabyInput
    sleepsleepSessions?: SleepUncheckedCreateNestedManyWithoutBabyInput
    activities?: ActivityUncheckedCreateNestedManyWithoutBabyInput
    photos?: BabyPhotoUncheckedCreateNestedManyWithoutBabyInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutBabyInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutBabyInput
    measurements?: MeasurementUncheckedCreateNestedManyWithoutBabyInput
    albums?: AlbumUncheckedCreateNestedManyWithoutBabyInput
    parentInvites?: ParentInviteUncheckedCreateNestedManyWithoutBabyInput
  }

  export type BabyCreateOrConnectWithoutCaregiversInput = {
    where: BabyWhereUniqueInput
    create: XOR<BabyCreateWithoutCaregiversInput, BabyUncheckedCreateWithoutCaregiversInput>
  }

  export type UserCreateWithoutBabiesInput = {
    email: string
    passwordHash: string
    firstName?: string
    lastName?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedBabies?: BabyCreateNestedManyWithoutOwnerInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    ParentInvite?: ParentInviteCreateNestedManyWithoutSentByInput
    AlbumAccess?: AlbumAccessCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBabiesInput = {
    id?: number
    email: string
    passwordHash: string
    firstName?: string
    lastName?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedBabies?: BabyUncheckedCreateNestedManyWithoutOwnerInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ParentInvite?: ParentInviteUncheckedCreateNestedManyWithoutSentByInput
    AlbumAccess?: AlbumAccessUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBabiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBabiesInput, UserUncheckedCreateWithoutBabiesInput>
  }

  export type BabyUpsertWithoutCaregiversInput = {
    update: XOR<BabyUpdateWithoutCaregiversInput, BabyUncheckedUpdateWithoutCaregiversInput>
    create: XOR<BabyCreateWithoutCaregiversInput, BabyUncheckedCreateWithoutCaregiversInput>
    where?: BabyWhereInput
  }

  export type BabyUpdateToOneWithWhereWithoutCaregiversInput = {
    where?: BabyWhereInput
    data: XOR<BabyUpdateWithoutCaregiversInput, BabyUncheckedUpdateWithoutCaregiversInput>
  }

  export type BabyUpdateWithoutCaregiversInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedBabiesNestedInput
    eliminations?: EliminationUpdateManyWithoutBabyNestedInput
    feedings?: FeedingUpdateManyWithoutBabyNestedInput
    sleepsleepSessions?: SleepUpdateManyWithoutBabyNestedInput
    activities?: ActivityUpdateManyWithoutBabyNestedInput
    photos?: BabyPhotoUpdateManyWithoutBabyNestedInput
    milestones?: MilestoneUpdateManyWithoutBabyNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutBabyNestedInput
    measurements?: MeasurementUpdateManyWithoutBabyNestedInput
    albums?: AlbumUpdateManyWithoutBabyNestedInput
    parentInvites?: ParentInviteUpdateManyWithoutBabyNestedInput
  }

  export type BabyUncheckedUpdateWithoutCaregiversInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: IntFieldUpdateOperationsInput | number
    eliminations?: EliminationUncheckedUpdateManyWithoutBabyNestedInput
    feedings?: FeedingUncheckedUpdateManyWithoutBabyNestedInput
    sleepsleepSessions?: SleepUncheckedUpdateManyWithoutBabyNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutBabyNestedInput
    photos?: BabyPhotoUncheckedUpdateManyWithoutBabyNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutBabyNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutBabyNestedInput
    measurements?: MeasurementUncheckedUpdateManyWithoutBabyNestedInput
    albums?: AlbumUncheckedUpdateManyWithoutBabyNestedInput
    parentInvites?: ParentInviteUncheckedUpdateManyWithoutBabyNestedInput
  }

  export type UserUpsertWithoutBabiesInput = {
    update: XOR<UserUpdateWithoutBabiesInput, UserUncheckedUpdateWithoutBabiesInput>
    create: XOR<UserCreateWithoutBabiesInput, UserUncheckedCreateWithoutBabiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBabiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBabiesInput, UserUncheckedUpdateWithoutBabiesInput>
  }

  export type UserUpdateWithoutBabiesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedBabies?: BabyUpdateManyWithoutOwnerNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    ParentInvite?: ParentInviteUpdateManyWithoutSentByNestedInput
    AlbumAccess?: AlbumAccessUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBabiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedBabies?: BabyUncheckedUpdateManyWithoutOwnerNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    ParentInvite?: ParentInviteUncheckedUpdateManyWithoutSentByNestedInput
    AlbumAccess?: AlbumAccessUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BabyCreateWithoutEliminationsInput = {
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedBabiesInput
    caregivers?: BabyCaregiverCreateNestedManyWithoutBabyInput
    feedings?: FeedingCreateNestedManyWithoutBabyInput
    sleepsleepSessions?: SleepCreateNestedManyWithoutBabyInput
    activities?: ActivityCreateNestedManyWithoutBabyInput
    photos?: BabyPhotoCreateNestedManyWithoutBabyInput
    milestones?: MilestoneCreateNestedManyWithoutBabyInput
    healthRecords?: HealthRecordCreateNestedManyWithoutBabyInput
    measurements?: MeasurementCreateNestedManyWithoutBabyInput
    albums?: AlbumCreateNestedManyWithoutBabyInput
    parentInvites?: ParentInviteCreateNestedManyWithoutBabyInput
  }

  export type BabyUncheckedCreateWithoutEliminationsInput = {
    id?: number
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: number
    caregivers?: BabyCaregiverUncheckedCreateNestedManyWithoutBabyInput
    feedings?: FeedingUncheckedCreateNestedManyWithoutBabyInput
    sleepsleepSessions?: SleepUncheckedCreateNestedManyWithoutBabyInput
    activities?: ActivityUncheckedCreateNestedManyWithoutBabyInput
    photos?: BabyPhotoUncheckedCreateNestedManyWithoutBabyInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutBabyInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutBabyInput
    measurements?: MeasurementUncheckedCreateNestedManyWithoutBabyInput
    albums?: AlbumUncheckedCreateNestedManyWithoutBabyInput
    parentInvites?: ParentInviteUncheckedCreateNestedManyWithoutBabyInput
  }

  export type BabyCreateOrConnectWithoutEliminationsInput = {
    where: BabyWhereUniqueInput
    create: XOR<BabyCreateWithoutEliminationsInput, BabyUncheckedCreateWithoutEliminationsInput>
  }

  export type BabyUpsertWithoutEliminationsInput = {
    update: XOR<BabyUpdateWithoutEliminationsInput, BabyUncheckedUpdateWithoutEliminationsInput>
    create: XOR<BabyCreateWithoutEliminationsInput, BabyUncheckedCreateWithoutEliminationsInput>
    where?: BabyWhereInput
  }

  export type BabyUpdateToOneWithWhereWithoutEliminationsInput = {
    where?: BabyWhereInput
    data: XOR<BabyUpdateWithoutEliminationsInput, BabyUncheckedUpdateWithoutEliminationsInput>
  }

  export type BabyUpdateWithoutEliminationsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedBabiesNestedInput
    caregivers?: BabyCaregiverUpdateManyWithoutBabyNestedInput
    feedings?: FeedingUpdateManyWithoutBabyNestedInput
    sleepsleepSessions?: SleepUpdateManyWithoutBabyNestedInput
    activities?: ActivityUpdateManyWithoutBabyNestedInput
    photos?: BabyPhotoUpdateManyWithoutBabyNestedInput
    milestones?: MilestoneUpdateManyWithoutBabyNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutBabyNestedInput
    measurements?: MeasurementUpdateManyWithoutBabyNestedInput
    albums?: AlbumUpdateManyWithoutBabyNestedInput
    parentInvites?: ParentInviteUpdateManyWithoutBabyNestedInput
  }

  export type BabyUncheckedUpdateWithoutEliminationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: IntFieldUpdateOperationsInput | number
    caregivers?: BabyCaregiverUncheckedUpdateManyWithoutBabyNestedInput
    feedings?: FeedingUncheckedUpdateManyWithoutBabyNestedInput
    sleepsleepSessions?: SleepUncheckedUpdateManyWithoutBabyNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutBabyNestedInput
    photos?: BabyPhotoUncheckedUpdateManyWithoutBabyNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutBabyNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutBabyNestedInput
    measurements?: MeasurementUncheckedUpdateManyWithoutBabyNestedInput
    albums?: AlbumUncheckedUpdateManyWithoutBabyNestedInput
    parentInvites?: ParentInviteUncheckedUpdateManyWithoutBabyNestedInput
  }

  export type BabyCreateWithoutFeedingsInput = {
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedBabiesInput
    caregivers?: BabyCaregiverCreateNestedManyWithoutBabyInput
    eliminations?: EliminationCreateNestedManyWithoutBabyInput
    sleepsleepSessions?: SleepCreateNestedManyWithoutBabyInput
    activities?: ActivityCreateNestedManyWithoutBabyInput
    photos?: BabyPhotoCreateNestedManyWithoutBabyInput
    milestones?: MilestoneCreateNestedManyWithoutBabyInput
    healthRecords?: HealthRecordCreateNestedManyWithoutBabyInput
    measurements?: MeasurementCreateNestedManyWithoutBabyInput
    albums?: AlbumCreateNestedManyWithoutBabyInput
    parentInvites?: ParentInviteCreateNestedManyWithoutBabyInput
  }

  export type BabyUncheckedCreateWithoutFeedingsInput = {
    id?: number
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: number
    caregivers?: BabyCaregiverUncheckedCreateNestedManyWithoutBabyInput
    eliminations?: EliminationUncheckedCreateNestedManyWithoutBabyInput
    sleepsleepSessions?: SleepUncheckedCreateNestedManyWithoutBabyInput
    activities?: ActivityUncheckedCreateNestedManyWithoutBabyInput
    photos?: BabyPhotoUncheckedCreateNestedManyWithoutBabyInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutBabyInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutBabyInput
    measurements?: MeasurementUncheckedCreateNestedManyWithoutBabyInput
    albums?: AlbumUncheckedCreateNestedManyWithoutBabyInput
    parentInvites?: ParentInviteUncheckedCreateNestedManyWithoutBabyInput
  }

  export type BabyCreateOrConnectWithoutFeedingsInput = {
    where: BabyWhereUniqueInput
    create: XOR<BabyCreateWithoutFeedingsInput, BabyUncheckedCreateWithoutFeedingsInput>
  }

  export type BabyUpsertWithoutFeedingsInput = {
    update: XOR<BabyUpdateWithoutFeedingsInput, BabyUncheckedUpdateWithoutFeedingsInput>
    create: XOR<BabyCreateWithoutFeedingsInput, BabyUncheckedCreateWithoutFeedingsInput>
    where?: BabyWhereInput
  }

  export type BabyUpdateToOneWithWhereWithoutFeedingsInput = {
    where?: BabyWhereInput
    data: XOR<BabyUpdateWithoutFeedingsInput, BabyUncheckedUpdateWithoutFeedingsInput>
  }

  export type BabyUpdateWithoutFeedingsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedBabiesNestedInput
    caregivers?: BabyCaregiverUpdateManyWithoutBabyNestedInput
    eliminations?: EliminationUpdateManyWithoutBabyNestedInput
    sleepsleepSessions?: SleepUpdateManyWithoutBabyNestedInput
    activities?: ActivityUpdateManyWithoutBabyNestedInput
    photos?: BabyPhotoUpdateManyWithoutBabyNestedInput
    milestones?: MilestoneUpdateManyWithoutBabyNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutBabyNestedInput
    measurements?: MeasurementUpdateManyWithoutBabyNestedInput
    albums?: AlbumUpdateManyWithoutBabyNestedInput
    parentInvites?: ParentInviteUpdateManyWithoutBabyNestedInput
  }

  export type BabyUncheckedUpdateWithoutFeedingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: IntFieldUpdateOperationsInput | number
    caregivers?: BabyCaregiverUncheckedUpdateManyWithoutBabyNestedInput
    eliminations?: EliminationUncheckedUpdateManyWithoutBabyNestedInput
    sleepsleepSessions?: SleepUncheckedUpdateManyWithoutBabyNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutBabyNestedInput
    photos?: BabyPhotoUncheckedUpdateManyWithoutBabyNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutBabyNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutBabyNestedInput
    measurements?: MeasurementUncheckedUpdateManyWithoutBabyNestedInput
    albums?: AlbumUncheckedUpdateManyWithoutBabyNestedInput
    parentInvites?: ParentInviteUncheckedUpdateManyWithoutBabyNestedInput
  }

  export type BabyCreateWithoutSleepsleepSessionsInput = {
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedBabiesInput
    caregivers?: BabyCaregiverCreateNestedManyWithoutBabyInput
    eliminations?: EliminationCreateNestedManyWithoutBabyInput
    feedings?: FeedingCreateNestedManyWithoutBabyInput
    activities?: ActivityCreateNestedManyWithoutBabyInput
    photos?: BabyPhotoCreateNestedManyWithoutBabyInput
    milestones?: MilestoneCreateNestedManyWithoutBabyInput
    healthRecords?: HealthRecordCreateNestedManyWithoutBabyInput
    measurements?: MeasurementCreateNestedManyWithoutBabyInput
    albums?: AlbumCreateNestedManyWithoutBabyInput
    parentInvites?: ParentInviteCreateNestedManyWithoutBabyInput
  }

  export type BabyUncheckedCreateWithoutSleepsleepSessionsInput = {
    id?: number
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: number
    caregivers?: BabyCaregiverUncheckedCreateNestedManyWithoutBabyInput
    eliminations?: EliminationUncheckedCreateNestedManyWithoutBabyInput
    feedings?: FeedingUncheckedCreateNestedManyWithoutBabyInput
    activities?: ActivityUncheckedCreateNestedManyWithoutBabyInput
    photos?: BabyPhotoUncheckedCreateNestedManyWithoutBabyInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutBabyInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutBabyInput
    measurements?: MeasurementUncheckedCreateNestedManyWithoutBabyInput
    albums?: AlbumUncheckedCreateNestedManyWithoutBabyInput
    parentInvites?: ParentInviteUncheckedCreateNestedManyWithoutBabyInput
  }

  export type BabyCreateOrConnectWithoutSleepsleepSessionsInput = {
    where: BabyWhereUniqueInput
    create: XOR<BabyCreateWithoutSleepsleepSessionsInput, BabyUncheckedCreateWithoutSleepsleepSessionsInput>
  }

  export type BabyUpsertWithoutSleepsleepSessionsInput = {
    update: XOR<BabyUpdateWithoutSleepsleepSessionsInput, BabyUncheckedUpdateWithoutSleepsleepSessionsInput>
    create: XOR<BabyCreateWithoutSleepsleepSessionsInput, BabyUncheckedCreateWithoutSleepsleepSessionsInput>
    where?: BabyWhereInput
  }

  export type BabyUpdateToOneWithWhereWithoutSleepsleepSessionsInput = {
    where?: BabyWhereInput
    data: XOR<BabyUpdateWithoutSleepsleepSessionsInput, BabyUncheckedUpdateWithoutSleepsleepSessionsInput>
  }

  export type BabyUpdateWithoutSleepsleepSessionsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedBabiesNestedInput
    caregivers?: BabyCaregiverUpdateManyWithoutBabyNestedInput
    eliminations?: EliminationUpdateManyWithoutBabyNestedInput
    feedings?: FeedingUpdateManyWithoutBabyNestedInput
    activities?: ActivityUpdateManyWithoutBabyNestedInput
    photos?: BabyPhotoUpdateManyWithoutBabyNestedInput
    milestones?: MilestoneUpdateManyWithoutBabyNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutBabyNestedInput
    measurements?: MeasurementUpdateManyWithoutBabyNestedInput
    albums?: AlbumUpdateManyWithoutBabyNestedInput
    parentInvites?: ParentInviteUpdateManyWithoutBabyNestedInput
  }

  export type BabyUncheckedUpdateWithoutSleepsleepSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: IntFieldUpdateOperationsInput | number
    caregivers?: BabyCaregiverUncheckedUpdateManyWithoutBabyNestedInput
    eliminations?: EliminationUncheckedUpdateManyWithoutBabyNestedInput
    feedings?: FeedingUncheckedUpdateManyWithoutBabyNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutBabyNestedInput
    photos?: BabyPhotoUncheckedUpdateManyWithoutBabyNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutBabyNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutBabyNestedInput
    measurements?: MeasurementUncheckedUpdateManyWithoutBabyNestedInput
    albums?: AlbumUncheckedUpdateManyWithoutBabyNestedInput
    parentInvites?: ParentInviteUncheckedUpdateManyWithoutBabyNestedInput
  }

  export type BabyCreateWithoutActivitiesInput = {
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedBabiesInput
    caregivers?: BabyCaregiverCreateNestedManyWithoutBabyInput
    eliminations?: EliminationCreateNestedManyWithoutBabyInput
    feedings?: FeedingCreateNestedManyWithoutBabyInput
    sleepsleepSessions?: SleepCreateNestedManyWithoutBabyInput
    photos?: BabyPhotoCreateNestedManyWithoutBabyInput
    milestones?: MilestoneCreateNestedManyWithoutBabyInput
    healthRecords?: HealthRecordCreateNestedManyWithoutBabyInput
    measurements?: MeasurementCreateNestedManyWithoutBabyInput
    albums?: AlbumCreateNestedManyWithoutBabyInput
    parentInvites?: ParentInviteCreateNestedManyWithoutBabyInput
  }

  export type BabyUncheckedCreateWithoutActivitiesInput = {
    id?: number
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: number
    caregivers?: BabyCaregiverUncheckedCreateNestedManyWithoutBabyInput
    eliminations?: EliminationUncheckedCreateNestedManyWithoutBabyInput
    feedings?: FeedingUncheckedCreateNestedManyWithoutBabyInput
    sleepsleepSessions?: SleepUncheckedCreateNestedManyWithoutBabyInput
    photos?: BabyPhotoUncheckedCreateNestedManyWithoutBabyInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutBabyInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutBabyInput
    measurements?: MeasurementUncheckedCreateNestedManyWithoutBabyInput
    albums?: AlbumUncheckedCreateNestedManyWithoutBabyInput
    parentInvites?: ParentInviteUncheckedCreateNestedManyWithoutBabyInput
  }

  export type BabyCreateOrConnectWithoutActivitiesInput = {
    where: BabyWhereUniqueInput
    create: XOR<BabyCreateWithoutActivitiesInput, BabyUncheckedCreateWithoutActivitiesInput>
  }

  export type ActivityPhotoCreateWithoutActivityInput = {
    createdAt?: Date | string
    photo: PhotoCreateNestedOneWithoutActivityPhotosInput
  }

  export type ActivityPhotoUncheckedCreateWithoutActivityInput = {
    photoId: number
    createdAt?: Date | string
  }

  export type ActivityPhotoCreateOrConnectWithoutActivityInput = {
    where: ActivityPhotoWhereUniqueInput
    create: XOR<ActivityPhotoCreateWithoutActivityInput, ActivityPhotoUncheckedCreateWithoutActivityInput>
  }

  export type ActivityPhotoCreateManyActivityInputEnvelope = {
    data: ActivityPhotoCreateManyActivityInput | ActivityPhotoCreateManyActivityInput[]
    skipDuplicates?: boolean
  }

  export type BabyUpsertWithoutActivitiesInput = {
    update: XOR<BabyUpdateWithoutActivitiesInput, BabyUncheckedUpdateWithoutActivitiesInput>
    create: XOR<BabyCreateWithoutActivitiesInput, BabyUncheckedCreateWithoutActivitiesInput>
    where?: BabyWhereInput
  }

  export type BabyUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: BabyWhereInput
    data: XOR<BabyUpdateWithoutActivitiesInput, BabyUncheckedUpdateWithoutActivitiesInput>
  }

  export type BabyUpdateWithoutActivitiesInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedBabiesNestedInput
    caregivers?: BabyCaregiverUpdateManyWithoutBabyNestedInput
    eliminations?: EliminationUpdateManyWithoutBabyNestedInput
    feedings?: FeedingUpdateManyWithoutBabyNestedInput
    sleepsleepSessions?: SleepUpdateManyWithoutBabyNestedInput
    photos?: BabyPhotoUpdateManyWithoutBabyNestedInput
    milestones?: MilestoneUpdateManyWithoutBabyNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutBabyNestedInput
    measurements?: MeasurementUpdateManyWithoutBabyNestedInput
    albums?: AlbumUpdateManyWithoutBabyNestedInput
    parentInvites?: ParentInviteUpdateManyWithoutBabyNestedInput
  }

  export type BabyUncheckedUpdateWithoutActivitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: IntFieldUpdateOperationsInput | number
    caregivers?: BabyCaregiverUncheckedUpdateManyWithoutBabyNestedInput
    eliminations?: EliminationUncheckedUpdateManyWithoutBabyNestedInput
    feedings?: FeedingUncheckedUpdateManyWithoutBabyNestedInput
    sleepsleepSessions?: SleepUncheckedUpdateManyWithoutBabyNestedInput
    photos?: BabyPhotoUncheckedUpdateManyWithoutBabyNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutBabyNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutBabyNestedInput
    measurements?: MeasurementUncheckedUpdateManyWithoutBabyNestedInput
    albums?: AlbumUncheckedUpdateManyWithoutBabyNestedInput
    parentInvites?: ParentInviteUncheckedUpdateManyWithoutBabyNestedInput
  }

  export type ActivityPhotoUpsertWithWhereUniqueWithoutActivityInput = {
    where: ActivityPhotoWhereUniqueInput
    update: XOR<ActivityPhotoUpdateWithoutActivityInput, ActivityPhotoUncheckedUpdateWithoutActivityInput>
    create: XOR<ActivityPhotoCreateWithoutActivityInput, ActivityPhotoUncheckedCreateWithoutActivityInput>
  }

  export type ActivityPhotoUpdateWithWhereUniqueWithoutActivityInput = {
    where: ActivityPhotoWhereUniqueInput
    data: XOR<ActivityPhotoUpdateWithoutActivityInput, ActivityPhotoUncheckedUpdateWithoutActivityInput>
  }

  export type ActivityPhotoUpdateManyWithWhereWithoutActivityInput = {
    where: ActivityPhotoScalarWhereInput
    data: XOR<ActivityPhotoUpdateManyMutationInput, ActivityPhotoUncheckedUpdateManyWithoutActivityInput>
  }

  export type ActivityPhotoScalarWhereInput = {
    AND?: ActivityPhotoScalarWhereInput | ActivityPhotoScalarWhereInput[]
    OR?: ActivityPhotoScalarWhereInput[]
    NOT?: ActivityPhotoScalarWhereInput | ActivityPhotoScalarWhereInput[]
    activityId?: IntFilter<"ActivityPhoto"> | number
    photoId?: IntFilter<"ActivityPhoto"> | number
    createdAt?: DateTimeFilter<"ActivityPhoto"> | Date | string
  }

  export type BabyCreateWithoutMilestonesInput = {
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedBabiesInput
    caregivers?: BabyCaregiverCreateNestedManyWithoutBabyInput
    eliminations?: EliminationCreateNestedManyWithoutBabyInput
    feedings?: FeedingCreateNestedManyWithoutBabyInput
    sleepsleepSessions?: SleepCreateNestedManyWithoutBabyInput
    activities?: ActivityCreateNestedManyWithoutBabyInput
    photos?: BabyPhotoCreateNestedManyWithoutBabyInput
    healthRecords?: HealthRecordCreateNestedManyWithoutBabyInput
    measurements?: MeasurementCreateNestedManyWithoutBabyInput
    albums?: AlbumCreateNestedManyWithoutBabyInput
    parentInvites?: ParentInviteCreateNestedManyWithoutBabyInput
  }

  export type BabyUncheckedCreateWithoutMilestonesInput = {
    id?: number
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: number
    caregivers?: BabyCaregiverUncheckedCreateNestedManyWithoutBabyInput
    eliminations?: EliminationUncheckedCreateNestedManyWithoutBabyInput
    feedings?: FeedingUncheckedCreateNestedManyWithoutBabyInput
    sleepsleepSessions?: SleepUncheckedCreateNestedManyWithoutBabyInput
    activities?: ActivityUncheckedCreateNestedManyWithoutBabyInput
    photos?: BabyPhotoUncheckedCreateNestedManyWithoutBabyInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutBabyInput
    measurements?: MeasurementUncheckedCreateNestedManyWithoutBabyInput
    albums?: AlbumUncheckedCreateNestedManyWithoutBabyInput
    parentInvites?: ParentInviteUncheckedCreateNestedManyWithoutBabyInput
  }

  export type BabyCreateOrConnectWithoutMilestonesInput = {
    where: BabyWhereUniqueInput
    create: XOR<BabyCreateWithoutMilestonesInput, BabyUncheckedCreateWithoutMilestonesInput>
  }

  export type MilestonePhotoCreateWithoutMilestoneInput = {
    createdAt?: Date | string
    photo: PhotoCreateNestedOneWithoutMilestonePhotosInput
  }

  export type MilestonePhotoUncheckedCreateWithoutMilestoneInput = {
    photoId: number
    createdAt?: Date | string
  }

  export type MilestonePhotoCreateOrConnectWithoutMilestoneInput = {
    where: MilestonePhotoWhereUniqueInput
    create: XOR<MilestonePhotoCreateWithoutMilestoneInput, MilestonePhotoUncheckedCreateWithoutMilestoneInput>
  }

  export type MilestonePhotoCreateManyMilestoneInputEnvelope = {
    data: MilestonePhotoCreateManyMilestoneInput | MilestonePhotoCreateManyMilestoneInput[]
    skipDuplicates?: boolean
  }

  export type BabyUpsertWithoutMilestonesInput = {
    update: XOR<BabyUpdateWithoutMilestonesInput, BabyUncheckedUpdateWithoutMilestonesInput>
    create: XOR<BabyCreateWithoutMilestonesInput, BabyUncheckedCreateWithoutMilestonesInput>
    where?: BabyWhereInput
  }

  export type BabyUpdateToOneWithWhereWithoutMilestonesInput = {
    where?: BabyWhereInput
    data: XOR<BabyUpdateWithoutMilestonesInput, BabyUncheckedUpdateWithoutMilestonesInput>
  }

  export type BabyUpdateWithoutMilestonesInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedBabiesNestedInput
    caregivers?: BabyCaregiverUpdateManyWithoutBabyNestedInput
    eliminations?: EliminationUpdateManyWithoutBabyNestedInput
    feedings?: FeedingUpdateManyWithoutBabyNestedInput
    sleepsleepSessions?: SleepUpdateManyWithoutBabyNestedInput
    activities?: ActivityUpdateManyWithoutBabyNestedInput
    photos?: BabyPhotoUpdateManyWithoutBabyNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutBabyNestedInput
    measurements?: MeasurementUpdateManyWithoutBabyNestedInput
    albums?: AlbumUpdateManyWithoutBabyNestedInput
    parentInvites?: ParentInviteUpdateManyWithoutBabyNestedInput
  }

  export type BabyUncheckedUpdateWithoutMilestonesInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: IntFieldUpdateOperationsInput | number
    caregivers?: BabyCaregiverUncheckedUpdateManyWithoutBabyNestedInput
    eliminations?: EliminationUncheckedUpdateManyWithoutBabyNestedInput
    feedings?: FeedingUncheckedUpdateManyWithoutBabyNestedInput
    sleepsleepSessions?: SleepUncheckedUpdateManyWithoutBabyNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutBabyNestedInput
    photos?: BabyPhotoUncheckedUpdateManyWithoutBabyNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutBabyNestedInput
    measurements?: MeasurementUncheckedUpdateManyWithoutBabyNestedInput
    albums?: AlbumUncheckedUpdateManyWithoutBabyNestedInput
    parentInvites?: ParentInviteUncheckedUpdateManyWithoutBabyNestedInput
  }

  export type MilestonePhotoUpsertWithWhereUniqueWithoutMilestoneInput = {
    where: MilestonePhotoWhereUniqueInput
    update: XOR<MilestonePhotoUpdateWithoutMilestoneInput, MilestonePhotoUncheckedUpdateWithoutMilestoneInput>
    create: XOR<MilestonePhotoCreateWithoutMilestoneInput, MilestonePhotoUncheckedCreateWithoutMilestoneInput>
  }

  export type MilestonePhotoUpdateWithWhereUniqueWithoutMilestoneInput = {
    where: MilestonePhotoWhereUniqueInput
    data: XOR<MilestonePhotoUpdateWithoutMilestoneInput, MilestonePhotoUncheckedUpdateWithoutMilestoneInput>
  }

  export type MilestonePhotoUpdateManyWithWhereWithoutMilestoneInput = {
    where: MilestonePhotoScalarWhereInput
    data: XOR<MilestonePhotoUpdateManyMutationInput, MilestonePhotoUncheckedUpdateManyWithoutMilestoneInput>
  }

  export type MilestonePhotoScalarWhereInput = {
    AND?: MilestonePhotoScalarWhereInput | MilestonePhotoScalarWhereInput[]
    OR?: MilestonePhotoScalarWhereInput[]
    NOT?: MilestonePhotoScalarWhereInput | MilestonePhotoScalarWhereInput[]
    milestoneId?: IntFilter<"MilestonePhoto"> | number
    photoId?: IntFilter<"MilestonePhoto"> | number
    createdAt?: DateTimeFilter<"MilestonePhoto"> | Date | string
  }

  export type BabyCreateWithoutHealthRecordsInput = {
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedBabiesInput
    caregivers?: BabyCaregiverCreateNestedManyWithoutBabyInput
    eliminations?: EliminationCreateNestedManyWithoutBabyInput
    feedings?: FeedingCreateNestedManyWithoutBabyInput
    sleepsleepSessions?: SleepCreateNestedManyWithoutBabyInput
    activities?: ActivityCreateNestedManyWithoutBabyInput
    photos?: BabyPhotoCreateNestedManyWithoutBabyInput
    milestones?: MilestoneCreateNestedManyWithoutBabyInput
    measurements?: MeasurementCreateNestedManyWithoutBabyInput
    albums?: AlbumCreateNestedManyWithoutBabyInput
    parentInvites?: ParentInviteCreateNestedManyWithoutBabyInput
  }

  export type BabyUncheckedCreateWithoutHealthRecordsInput = {
    id?: number
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: number
    caregivers?: BabyCaregiverUncheckedCreateNestedManyWithoutBabyInput
    eliminations?: EliminationUncheckedCreateNestedManyWithoutBabyInput
    feedings?: FeedingUncheckedCreateNestedManyWithoutBabyInput
    sleepsleepSessions?: SleepUncheckedCreateNestedManyWithoutBabyInput
    activities?: ActivityUncheckedCreateNestedManyWithoutBabyInput
    photos?: BabyPhotoUncheckedCreateNestedManyWithoutBabyInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutBabyInput
    measurements?: MeasurementUncheckedCreateNestedManyWithoutBabyInput
    albums?: AlbumUncheckedCreateNestedManyWithoutBabyInput
    parentInvites?: ParentInviteUncheckedCreateNestedManyWithoutBabyInput
  }

  export type BabyCreateOrConnectWithoutHealthRecordsInput = {
    where: BabyWhereUniqueInput
    create: XOR<BabyCreateWithoutHealthRecordsInput, BabyUncheckedCreateWithoutHealthRecordsInput>
  }

  export type BabyUpsertWithoutHealthRecordsInput = {
    update: XOR<BabyUpdateWithoutHealthRecordsInput, BabyUncheckedUpdateWithoutHealthRecordsInput>
    create: XOR<BabyCreateWithoutHealthRecordsInput, BabyUncheckedCreateWithoutHealthRecordsInput>
    where?: BabyWhereInput
  }

  export type BabyUpdateToOneWithWhereWithoutHealthRecordsInput = {
    where?: BabyWhereInput
    data: XOR<BabyUpdateWithoutHealthRecordsInput, BabyUncheckedUpdateWithoutHealthRecordsInput>
  }

  export type BabyUpdateWithoutHealthRecordsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedBabiesNestedInput
    caregivers?: BabyCaregiverUpdateManyWithoutBabyNestedInput
    eliminations?: EliminationUpdateManyWithoutBabyNestedInput
    feedings?: FeedingUpdateManyWithoutBabyNestedInput
    sleepsleepSessions?: SleepUpdateManyWithoutBabyNestedInput
    activities?: ActivityUpdateManyWithoutBabyNestedInput
    photos?: BabyPhotoUpdateManyWithoutBabyNestedInput
    milestones?: MilestoneUpdateManyWithoutBabyNestedInput
    measurements?: MeasurementUpdateManyWithoutBabyNestedInput
    albums?: AlbumUpdateManyWithoutBabyNestedInput
    parentInvites?: ParentInviteUpdateManyWithoutBabyNestedInput
  }

  export type BabyUncheckedUpdateWithoutHealthRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: IntFieldUpdateOperationsInput | number
    caregivers?: BabyCaregiverUncheckedUpdateManyWithoutBabyNestedInput
    eliminations?: EliminationUncheckedUpdateManyWithoutBabyNestedInput
    feedings?: FeedingUncheckedUpdateManyWithoutBabyNestedInput
    sleepsleepSessions?: SleepUncheckedUpdateManyWithoutBabyNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutBabyNestedInput
    photos?: BabyPhotoUncheckedUpdateManyWithoutBabyNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutBabyNestedInput
    measurements?: MeasurementUncheckedUpdateManyWithoutBabyNestedInput
    albums?: AlbumUncheckedUpdateManyWithoutBabyNestedInput
    parentInvites?: ParentInviteUncheckedUpdateManyWithoutBabyNestedInput
  }

  export type BabyCreateWithoutMeasurementsInput = {
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedBabiesInput
    caregivers?: BabyCaregiverCreateNestedManyWithoutBabyInput
    eliminations?: EliminationCreateNestedManyWithoutBabyInput
    feedings?: FeedingCreateNestedManyWithoutBabyInput
    sleepsleepSessions?: SleepCreateNestedManyWithoutBabyInput
    activities?: ActivityCreateNestedManyWithoutBabyInput
    photos?: BabyPhotoCreateNestedManyWithoutBabyInput
    milestones?: MilestoneCreateNestedManyWithoutBabyInput
    healthRecords?: HealthRecordCreateNestedManyWithoutBabyInput
    albums?: AlbumCreateNestedManyWithoutBabyInput
    parentInvites?: ParentInviteCreateNestedManyWithoutBabyInput
  }

  export type BabyUncheckedCreateWithoutMeasurementsInput = {
    id?: number
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: number
    caregivers?: BabyCaregiverUncheckedCreateNestedManyWithoutBabyInput
    eliminations?: EliminationUncheckedCreateNestedManyWithoutBabyInput
    feedings?: FeedingUncheckedCreateNestedManyWithoutBabyInput
    sleepsleepSessions?: SleepUncheckedCreateNestedManyWithoutBabyInput
    activities?: ActivityUncheckedCreateNestedManyWithoutBabyInput
    photos?: BabyPhotoUncheckedCreateNestedManyWithoutBabyInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutBabyInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutBabyInput
    albums?: AlbumUncheckedCreateNestedManyWithoutBabyInput
    parentInvites?: ParentInviteUncheckedCreateNestedManyWithoutBabyInput
  }

  export type BabyCreateOrConnectWithoutMeasurementsInput = {
    where: BabyWhereUniqueInput
    create: XOR<BabyCreateWithoutMeasurementsInput, BabyUncheckedCreateWithoutMeasurementsInput>
  }

  export type BabyUpsertWithoutMeasurementsInput = {
    update: XOR<BabyUpdateWithoutMeasurementsInput, BabyUncheckedUpdateWithoutMeasurementsInput>
    create: XOR<BabyCreateWithoutMeasurementsInput, BabyUncheckedCreateWithoutMeasurementsInput>
    where?: BabyWhereInput
  }

  export type BabyUpdateToOneWithWhereWithoutMeasurementsInput = {
    where?: BabyWhereInput
    data: XOR<BabyUpdateWithoutMeasurementsInput, BabyUncheckedUpdateWithoutMeasurementsInput>
  }

  export type BabyUpdateWithoutMeasurementsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedBabiesNestedInput
    caregivers?: BabyCaregiverUpdateManyWithoutBabyNestedInput
    eliminations?: EliminationUpdateManyWithoutBabyNestedInput
    feedings?: FeedingUpdateManyWithoutBabyNestedInput
    sleepsleepSessions?: SleepUpdateManyWithoutBabyNestedInput
    activities?: ActivityUpdateManyWithoutBabyNestedInput
    photos?: BabyPhotoUpdateManyWithoutBabyNestedInput
    milestones?: MilestoneUpdateManyWithoutBabyNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutBabyNestedInput
    albums?: AlbumUpdateManyWithoutBabyNestedInput
    parentInvites?: ParentInviteUpdateManyWithoutBabyNestedInput
  }

  export type BabyUncheckedUpdateWithoutMeasurementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: IntFieldUpdateOperationsInput | number
    caregivers?: BabyCaregiverUncheckedUpdateManyWithoutBabyNestedInput
    eliminations?: EliminationUncheckedUpdateManyWithoutBabyNestedInput
    feedings?: FeedingUncheckedUpdateManyWithoutBabyNestedInput
    sleepsleepSessions?: SleepUncheckedUpdateManyWithoutBabyNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutBabyNestedInput
    photos?: BabyPhotoUncheckedUpdateManyWithoutBabyNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutBabyNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutBabyNestedInput
    albums?: AlbumUncheckedUpdateManyWithoutBabyNestedInput
    parentInvites?: ParentInviteUncheckedUpdateManyWithoutBabyNestedInput
  }

  export type BabyCreateWithoutAlbumsInput = {
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedBabiesInput
    caregivers?: BabyCaregiverCreateNestedManyWithoutBabyInput
    eliminations?: EliminationCreateNestedManyWithoutBabyInput
    feedings?: FeedingCreateNestedManyWithoutBabyInput
    sleepsleepSessions?: SleepCreateNestedManyWithoutBabyInput
    activities?: ActivityCreateNestedManyWithoutBabyInput
    photos?: BabyPhotoCreateNestedManyWithoutBabyInput
    milestones?: MilestoneCreateNestedManyWithoutBabyInput
    healthRecords?: HealthRecordCreateNestedManyWithoutBabyInput
    measurements?: MeasurementCreateNestedManyWithoutBabyInput
    parentInvites?: ParentInviteCreateNestedManyWithoutBabyInput
  }

  export type BabyUncheckedCreateWithoutAlbumsInput = {
    id?: number
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: number
    caregivers?: BabyCaregiverUncheckedCreateNestedManyWithoutBabyInput
    eliminations?: EliminationUncheckedCreateNestedManyWithoutBabyInput
    feedings?: FeedingUncheckedCreateNestedManyWithoutBabyInput
    sleepsleepSessions?: SleepUncheckedCreateNestedManyWithoutBabyInput
    activities?: ActivityUncheckedCreateNestedManyWithoutBabyInput
    photos?: BabyPhotoUncheckedCreateNestedManyWithoutBabyInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutBabyInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutBabyInput
    measurements?: MeasurementUncheckedCreateNestedManyWithoutBabyInput
    parentInvites?: ParentInviteUncheckedCreateNestedManyWithoutBabyInput
  }

  export type BabyCreateOrConnectWithoutAlbumsInput = {
    where: BabyWhereUniqueInput
    create: XOR<BabyCreateWithoutAlbumsInput, BabyUncheckedCreateWithoutAlbumsInput>
  }

  export type AlbumPhotoCreateWithoutAlbumInput = {
    createdAt?: Date | string
    photo: PhotoCreateNestedOneWithoutAlbumPhotosInput
  }

  export type AlbumPhotoUncheckedCreateWithoutAlbumInput = {
    photoId: number
    createdAt?: Date | string
  }

  export type AlbumPhotoCreateOrConnectWithoutAlbumInput = {
    where: AlbumPhotoWhereUniqueInput
    create: XOR<AlbumPhotoCreateWithoutAlbumInput, AlbumPhotoUncheckedCreateWithoutAlbumInput>
  }

  export type AlbumPhotoCreateManyAlbumInputEnvelope = {
    data: AlbumPhotoCreateManyAlbumInput | AlbumPhotoCreateManyAlbumInput[]
    skipDuplicates?: boolean
  }

  export type AlbumAccessCreateWithoutAlbumInput = {
    permissions?: AlbumAccessCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAlbumAccessInput
  }

  export type AlbumAccessUncheckedCreateWithoutAlbumInput = {
    id?: number
    permissions?: AlbumAccessCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
  }

  export type AlbumAccessCreateOrConnectWithoutAlbumInput = {
    where: AlbumAccessWhereUniqueInput
    create: XOR<AlbumAccessCreateWithoutAlbumInput, AlbumAccessUncheckedCreateWithoutAlbumInput>
  }

  export type AlbumAccessCreateManyAlbumInputEnvelope = {
    data: AlbumAccessCreateManyAlbumInput | AlbumAccessCreateManyAlbumInput[]
    skipDuplicates?: boolean
  }

  export type BabyUpsertWithoutAlbumsInput = {
    update: XOR<BabyUpdateWithoutAlbumsInput, BabyUncheckedUpdateWithoutAlbumsInput>
    create: XOR<BabyCreateWithoutAlbumsInput, BabyUncheckedCreateWithoutAlbumsInput>
    where?: BabyWhereInput
  }

  export type BabyUpdateToOneWithWhereWithoutAlbumsInput = {
    where?: BabyWhereInput
    data: XOR<BabyUpdateWithoutAlbumsInput, BabyUncheckedUpdateWithoutAlbumsInput>
  }

  export type BabyUpdateWithoutAlbumsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedBabiesNestedInput
    caregivers?: BabyCaregiverUpdateManyWithoutBabyNestedInput
    eliminations?: EliminationUpdateManyWithoutBabyNestedInput
    feedings?: FeedingUpdateManyWithoutBabyNestedInput
    sleepsleepSessions?: SleepUpdateManyWithoutBabyNestedInput
    activities?: ActivityUpdateManyWithoutBabyNestedInput
    photos?: BabyPhotoUpdateManyWithoutBabyNestedInput
    milestones?: MilestoneUpdateManyWithoutBabyNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutBabyNestedInput
    measurements?: MeasurementUpdateManyWithoutBabyNestedInput
    parentInvites?: ParentInviteUpdateManyWithoutBabyNestedInput
  }

  export type BabyUncheckedUpdateWithoutAlbumsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: IntFieldUpdateOperationsInput | number
    caregivers?: BabyCaregiverUncheckedUpdateManyWithoutBabyNestedInput
    eliminations?: EliminationUncheckedUpdateManyWithoutBabyNestedInput
    feedings?: FeedingUncheckedUpdateManyWithoutBabyNestedInput
    sleepsleepSessions?: SleepUncheckedUpdateManyWithoutBabyNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutBabyNestedInput
    photos?: BabyPhotoUncheckedUpdateManyWithoutBabyNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutBabyNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutBabyNestedInput
    measurements?: MeasurementUncheckedUpdateManyWithoutBabyNestedInput
    parentInvites?: ParentInviteUncheckedUpdateManyWithoutBabyNestedInput
  }

  export type AlbumPhotoUpsertWithWhereUniqueWithoutAlbumInput = {
    where: AlbumPhotoWhereUniqueInput
    update: XOR<AlbumPhotoUpdateWithoutAlbumInput, AlbumPhotoUncheckedUpdateWithoutAlbumInput>
    create: XOR<AlbumPhotoCreateWithoutAlbumInput, AlbumPhotoUncheckedCreateWithoutAlbumInput>
  }

  export type AlbumPhotoUpdateWithWhereUniqueWithoutAlbumInput = {
    where: AlbumPhotoWhereUniqueInput
    data: XOR<AlbumPhotoUpdateWithoutAlbumInput, AlbumPhotoUncheckedUpdateWithoutAlbumInput>
  }

  export type AlbumPhotoUpdateManyWithWhereWithoutAlbumInput = {
    where: AlbumPhotoScalarWhereInput
    data: XOR<AlbumPhotoUpdateManyMutationInput, AlbumPhotoUncheckedUpdateManyWithoutAlbumInput>
  }

  export type AlbumPhotoScalarWhereInput = {
    AND?: AlbumPhotoScalarWhereInput | AlbumPhotoScalarWhereInput[]
    OR?: AlbumPhotoScalarWhereInput[]
    NOT?: AlbumPhotoScalarWhereInput | AlbumPhotoScalarWhereInput[]
    albumId?: IntFilter<"AlbumPhoto"> | number
    photoId?: IntFilter<"AlbumPhoto"> | number
    createdAt?: DateTimeFilter<"AlbumPhoto"> | Date | string
  }

  export type AlbumAccessUpsertWithWhereUniqueWithoutAlbumInput = {
    where: AlbumAccessWhereUniqueInput
    update: XOR<AlbumAccessUpdateWithoutAlbumInput, AlbumAccessUncheckedUpdateWithoutAlbumInput>
    create: XOR<AlbumAccessCreateWithoutAlbumInput, AlbumAccessUncheckedCreateWithoutAlbumInput>
  }

  export type AlbumAccessUpdateWithWhereUniqueWithoutAlbumInput = {
    where: AlbumAccessWhereUniqueInput
    data: XOR<AlbumAccessUpdateWithoutAlbumInput, AlbumAccessUncheckedUpdateWithoutAlbumInput>
  }

  export type AlbumAccessUpdateManyWithWhereWithoutAlbumInput = {
    where: AlbumAccessScalarWhereInput
    data: XOR<AlbumAccessUpdateManyMutationInput, AlbumAccessUncheckedUpdateManyWithoutAlbumInput>
  }

  export type BabyPhotoCreateWithoutPhotoInput = {
    createdAt?: Date | string
    baby: BabyCreateNestedOneWithoutPhotosInput
  }

  export type BabyPhotoUncheckedCreateWithoutPhotoInput = {
    babyId: number
    createdAt?: Date | string
  }

  export type BabyPhotoCreateOrConnectWithoutPhotoInput = {
    where: BabyPhotoWhereUniqueInput
    create: XOR<BabyPhotoCreateWithoutPhotoInput, BabyPhotoUncheckedCreateWithoutPhotoInput>
  }

  export type BabyPhotoCreateManyPhotoInputEnvelope = {
    data: BabyPhotoCreateManyPhotoInput | BabyPhotoCreateManyPhotoInput[]
    skipDuplicates?: boolean
  }

  export type AlbumPhotoCreateWithoutPhotoInput = {
    createdAt?: Date | string
    album: AlbumCreateNestedOneWithoutPhotosInput
  }

  export type AlbumPhotoUncheckedCreateWithoutPhotoInput = {
    albumId: number
    createdAt?: Date | string
  }

  export type AlbumPhotoCreateOrConnectWithoutPhotoInput = {
    where: AlbumPhotoWhereUniqueInput
    create: XOR<AlbumPhotoCreateWithoutPhotoInput, AlbumPhotoUncheckedCreateWithoutPhotoInput>
  }

  export type AlbumPhotoCreateManyPhotoInputEnvelope = {
    data: AlbumPhotoCreateManyPhotoInput | AlbumPhotoCreateManyPhotoInput[]
    skipDuplicates?: boolean
  }

  export type ActivityPhotoCreateWithoutPhotoInput = {
    createdAt?: Date | string
    activity: ActivityCreateNestedOneWithoutPhotosInput
  }

  export type ActivityPhotoUncheckedCreateWithoutPhotoInput = {
    activityId: number
    createdAt?: Date | string
  }

  export type ActivityPhotoCreateOrConnectWithoutPhotoInput = {
    where: ActivityPhotoWhereUniqueInput
    create: XOR<ActivityPhotoCreateWithoutPhotoInput, ActivityPhotoUncheckedCreateWithoutPhotoInput>
  }

  export type ActivityPhotoCreateManyPhotoInputEnvelope = {
    data: ActivityPhotoCreateManyPhotoInput | ActivityPhotoCreateManyPhotoInput[]
    skipDuplicates?: boolean
  }

  export type MilestonePhotoCreateWithoutPhotoInput = {
    createdAt?: Date | string
    milestone: MilestoneCreateNestedOneWithoutPhotosInput
  }

  export type MilestonePhotoUncheckedCreateWithoutPhotoInput = {
    milestoneId: number
    createdAt?: Date | string
  }

  export type MilestonePhotoCreateOrConnectWithoutPhotoInput = {
    where: MilestonePhotoWhereUniqueInput
    create: XOR<MilestonePhotoCreateWithoutPhotoInput, MilestonePhotoUncheckedCreateWithoutPhotoInput>
  }

  export type MilestonePhotoCreateManyPhotoInputEnvelope = {
    data: MilestonePhotoCreateManyPhotoInput | MilestonePhotoCreateManyPhotoInput[]
    skipDuplicates?: boolean
  }

  export type BabyPhotoUpsertWithWhereUniqueWithoutPhotoInput = {
    where: BabyPhotoWhereUniqueInput
    update: XOR<BabyPhotoUpdateWithoutPhotoInput, BabyPhotoUncheckedUpdateWithoutPhotoInput>
    create: XOR<BabyPhotoCreateWithoutPhotoInput, BabyPhotoUncheckedCreateWithoutPhotoInput>
  }

  export type BabyPhotoUpdateWithWhereUniqueWithoutPhotoInput = {
    where: BabyPhotoWhereUniqueInput
    data: XOR<BabyPhotoUpdateWithoutPhotoInput, BabyPhotoUncheckedUpdateWithoutPhotoInput>
  }

  export type BabyPhotoUpdateManyWithWhereWithoutPhotoInput = {
    where: BabyPhotoScalarWhereInput
    data: XOR<BabyPhotoUpdateManyMutationInput, BabyPhotoUncheckedUpdateManyWithoutPhotoInput>
  }

  export type AlbumPhotoUpsertWithWhereUniqueWithoutPhotoInput = {
    where: AlbumPhotoWhereUniqueInput
    update: XOR<AlbumPhotoUpdateWithoutPhotoInput, AlbumPhotoUncheckedUpdateWithoutPhotoInput>
    create: XOR<AlbumPhotoCreateWithoutPhotoInput, AlbumPhotoUncheckedCreateWithoutPhotoInput>
  }

  export type AlbumPhotoUpdateWithWhereUniqueWithoutPhotoInput = {
    where: AlbumPhotoWhereUniqueInput
    data: XOR<AlbumPhotoUpdateWithoutPhotoInput, AlbumPhotoUncheckedUpdateWithoutPhotoInput>
  }

  export type AlbumPhotoUpdateManyWithWhereWithoutPhotoInput = {
    where: AlbumPhotoScalarWhereInput
    data: XOR<AlbumPhotoUpdateManyMutationInput, AlbumPhotoUncheckedUpdateManyWithoutPhotoInput>
  }

  export type ActivityPhotoUpsertWithWhereUniqueWithoutPhotoInput = {
    where: ActivityPhotoWhereUniqueInput
    update: XOR<ActivityPhotoUpdateWithoutPhotoInput, ActivityPhotoUncheckedUpdateWithoutPhotoInput>
    create: XOR<ActivityPhotoCreateWithoutPhotoInput, ActivityPhotoUncheckedCreateWithoutPhotoInput>
  }

  export type ActivityPhotoUpdateWithWhereUniqueWithoutPhotoInput = {
    where: ActivityPhotoWhereUniqueInput
    data: XOR<ActivityPhotoUpdateWithoutPhotoInput, ActivityPhotoUncheckedUpdateWithoutPhotoInput>
  }

  export type ActivityPhotoUpdateManyWithWhereWithoutPhotoInput = {
    where: ActivityPhotoScalarWhereInput
    data: XOR<ActivityPhotoUpdateManyMutationInput, ActivityPhotoUncheckedUpdateManyWithoutPhotoInput>
  }

  export type MilestonePhotoUpsertWithWhereUniqueWithoutPhotoInput = {
    where: MilestonePhotoWhereUniqueInput
    update: XOR<MilestonePhotoUpdateWithoutPhotoInput, MilestonePhotoUncheckedUpdateWithoutPhotoInput>
    create: XOR<MilestonePhotoCreateWithoutPhotoInput, MilestonePhotoUncheckedCreateWithoutPhotoInput>
  }

  export type MilestonePhotoUpdateWithWhereUniqueWithoutPhotoInput = {
    where: MilestonePhotoWhereUniqueInput
    data: XOR<MilestonePhotoUpdateWithoutPhotoInput, MilestonePhotoUncheckedUpdateWithoutPhotoInput>
  }

  export type MilestonePhotoUpdateManyWithWhereWithoutPhotoInput = {
    where: MilestonePhotoScalarWhereInput
    data: XOR<MilestonePhotoUpdateManyMutationInput, MilestonePhotoUncheckedUpdateManyWithoutPhotoInput>
  }

  export type BabyCreateWithoutPhotosInput = {
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedBabiesInput
    caregivers?: BabyCaregiverCreateNestedManyWithoutBabyInput
    eliminations?: EliminationCreateNestedManyWithoutBabyInput
    feedings?: FeedingCreateNestedManyWithoutBabyInput
    sleepsleepSessions?: SleepCreateNestedManyWithoutBabyInput
    activities?: ActivityCreateNestedManyWithoutBabyInput
    milestones?: MilestoneCreateNestedManyWithoutBabyInput
    healthRecords?: HealthRecordCreateNestedManyWithoutBabyInput
    measurements?: MeasurementCreateNestedManyWithoutBabyInput
    albums?: AlbumCreateNestedManyWithoutBabyInput
    parentInvites?: ParentInviteCreateNestedManyWithoutBabyInput
  }

  export type BabyUncheckedCreateWithoutPhotosInput = {
    id?: number
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: number
    caregivers?: BabyCaregiverUncheckedCreateNestedManyWithoutBabyInput
    eliminations?: EliminationUncheckedCreateNestedManyWithoutBabyInput
    feedings?: FeedingUncheckedCreateNestedManyWithoutBabyInput
    sleepsleepSessions?: SleepUncheckedCreateNestedManyWithoutBabyInput
    activities?: ActivityUncheckedCreateNestedManyWithoutBabyInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutBabyInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutBabyInput
    measurements?: MeasurementUncheckedCreateNestedManyWithoutBabyInput
    albums?: AlbumUncheckedCreateNestedManyWithoutBabyInput
    parentInvites?: ParentInviteUncheckedCreateNestedManyWithoutBabyInput
  }

  export type BabyCreateOrConnectWithoutPhotosInput = {
    where: BabyWhereUniqueInput
    create: XOR<BabyCreateWithoutPhotosInput, BabyUncheckedCreateWithoutPhotosInput>
  }

  export type PhotoCreateWithoutBabyPhotosInput = {
    url: string
    caption?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    albumPhotos?: AlbumPhotoCreateNestedManyWithoutPhotoInput
    activityPhotos?: ActivityPhotoCreateNestedManyWithoutPhotoInput
    milestonePhotos?: MilestonePhotoCreateNestedManyWithoutPhotoInput
  }

  export type PhotoUncheckedCreateWithoutBabyPhotosInput = {
    id?: number
    url: string
    caption?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    albumPhotos?: AlbumPhotoUncheckedCreateNestedManyWithoutPhotoInput
    activityPhotos?: ActivityPhotoUncheckedCreateNestedManyWithoutPhotoInput
    milestonePhotos?: MilestonePhotoUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type PhotoCreateOrConnectWithoutBabyPhotosInput = {
    where: PhotoWhereUniqueInput
    create: XOR<PhotoCreateWithoutBabyPhotosInput, PhotoUncheckedCreateWithoutBabyPhotosInput>
  }

  export type BabyUpsertWithoutPhotosInput = {
    update: XOR<BabyUpdateWithoutPhotosInput, BabyUncheckedUpdateWithoutPhotosInput>
    create: XOR<BabyCreateWithoutPhotosInput, BabyUncheckedCreateWithoutPhotosInput>
    where?: BabyWhereInput
  }

  export type BabyUpdateToOneWithWhereWithoutPhotosInput = {
    where?: BabyWhereInput
    data: XOR<BabyUpdateWithoutPhotosInput, BabyUncheckedUpdateWithoutPhotosInput>
  }

  export type BabyUpdateWithoutPhotosInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedBabiesNestedInput
    caregivers?: BabyCaregiverUpdateManyWithoutBabyNestedInput
    eliminations?: EliminationUpdateManyWithoutBabyNestedInput
    feedings?: FeedingUpdateManyWithoutBabyNestedInput
    sleepsleepSessions?: SleepUpdateManyWithoutBabyNestedInput
    activities?: ActivityUpdateManyWithoutBabyNestedInput
    milestones?: MilestoneUpdateManyWithoutBabyNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutBabyNestedInput
    measurements?: MeasurementUpdateManyWithoutBabyNestedInput
    albums?: AlbumUpdateManyWithoutBabyNestedInput
    parentInvites?: ParentInviteUpdateManyWithoutBabyNestedInput
  }

  export type BabyUncheckedUpdateWithoutPhotosInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: IntFieldUpdateOperationsInput | number
    caregivers?: BabyCaregiverUncheckedUpdateManyWithoutBabyNestedInput
    eliminations?: EliminationUncheckedUpdateManyWithoutBabyNestedInput
    feedings?: FeedingUncheckedUpdateManyWithoutBabyNestedInput
    sleepsleepSessions?: SleepUncheckedUpdateManyWithoutBabyNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutBabyNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutBabyNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutBabyNestedInput
    measurements?: MeasurementUncheckedUpdateManyWithoutBabyNestedInput
    albums?: AlbumUncheckedUpdateManyWithoutBabyNestedInput
    parentInvites?: ParentInviteUncheckedUpdateManyWithoutBabyNestedInput
  }

  export type PhotoUpsertWithoutBabyPhotosInput = {
    update: XOR<PhotoUpdateWithoutBabyPhotosInput, PhotoUncheckedUpdateWithoutBabyPhotosInput>
    create: XOR<PhotoCreateWithoutBabyPhotosInput, PhotoUncheckedCreateWithoutBabyPhotosInput>
    where?: PhotoWhereInput
  }

  export type PhotoUpdateToOneWithWhereWithoutBabyPhotosInput = {
    where?: PhotoWhereInput
    data: XOR<PhotoUpdateWithoutBabyPhotosInput, PhotoUncheckedUpdateWithoutBabyPhotosInput>
  }

  export type PhotoUpdateWithoutBabyPhotosInput = {
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albumPhotos?: AlbumPhotoUpdateManyWithoutPhotoNestedInput
    activityPhotos?: ActivityPhotoUpdateManyWithoutPhotoNestedInput
    milestonePhotos?: MilestonePhotoUpdateManyWithoutPhotoNestedInput
  }

  export type PhotoUncheckedUpdateWithoutBabyPhotosInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albumPhotos?: AlbumPhotoUncheckedUpdateManyWithoutPhotoNestedInput
    activityPhotos?: ActivityPhotoUncheckedUpdateManyWithoutPhotoNestedInput
    milestonePhotos?: MilestonePhotoUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type AlbumCreateWithoutPhotosInput = {
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    baby: BabyCreateNestedOneWithoutAlbumsInput
    access?: AlbumAccessCreateNestedManyWithoutAlbumInput
  }

  export type AlbumUncheckedCreateWithoutPhotosInput = {
    id?: number
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babyId: number
    access?: AlbumAccessUncheckedCreateNestedManyWithoutAlbumInput
  }

  export type AlbumCreateOrConnectWithoutPhotosInput = {
    where: AlbumWhereUniqueInput
    create: XOR<AlbumCreateWithoutPhotosInput, AlbumUncheckedCreateWithoutPhotosInput>
  }

  export type PhotoCreateWithoutAlbumPhotosInput = {
    url: string
    caption?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    babyPhotos?: BabyPhotoCreateNestedManyWithoutPhotoInput
    activityPhotos?: ActivityPhotoCreateNestedManyWithoutPhotoInput
    milestonePhotos?: MilestonePhotoCreateNestedManyWithoutPhotoInput
  }

  export type PhotoUncheckedCreateWithoutAlbumPhotosInput = {
    id?: number
    url: string
    caption?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    babyPhotos?: BabyPhotoUncheckedCreateNestedManyWithoutPhotoInput
    activityPhotos?: ActivityPhotoUncheckedCreateNestedManyWithoutPhotoInput
    milestonePhotos?: MilestonePhotoUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type PhotoCreateOrConnectWithoutAlbumPhotosInput = {
    where: PhotoWhereUniqueInput
    create: XOR<PhotoCreateWithoutAlbumPhotosInput, PhotoUncheckedCreateWithoutAlbumPhotosInput>
  }

  export type AlbumUpsertWithoutPhotosInput = {
    update: XOR<AlbumUpdateWithoutPhotosInput, AlbumUncheckedUpdateWithoutPhotosInput>
    create: XOR<AlbumCreateWithoutPhotosInput, AlbumUncheckedCreateWithoutPhotosInput>
    where?: AlbumWhereInput
  }

  export type AlbumUpdateToOneWithWhereWithoutPhotosInput = {
    where?: AlbumWhereInput
    data: XOR<AlbumUpdateWithoutPhotosInput, AlbumUncheckedUpdateWithoutPhotosInput>
  }

  export type AlbumUpdateWithoutPhotosInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baby?: BabyUpdateOneRequiredWithoutAlbumsNestedInput
    access?: AlbumAccessUpdateManyWithoutAlbumNestedInput
  }

  export type AlbumUncheckedUpdateWithoutPhotosInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyId?: IntFieldUpdateOperationsInput | number
    access?: AlbumAccessUncheckedUpdateManyWithoutAlbumNestedInput
  }

  export type PhotoUpsertWithoutAlbumPhotosInput = {
    update: XOR<PhotoUpdateWithoutAlbumPhotosInput, PhotoUncheckedUpdateWithoutAlbumPhotosInput>
    create: XOR<PhotoCreateWithoutAlbumPhotosInput, PhotoUncheckedCreateWithoutAlbumPhotosInput>
    where?: PhotoWhereInput
  }

  export type PhotoUpdateToOneWithWhereWithoutAlbumPhotosInput = {
    where?: PhotoWhereInput
    data: XOR<PhotoUpdateWithoutAlbumPhotosInput, PhotoUncheckedUpdateWithoutAlbumPhotosInput>
  }

  export type PhotoUpdateWithoutAlbumPhotosInput = {
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyPhotos?: BabyPhotoUpdateManyWithoutPhotoNestedInput
    activityPhotos?: ActivityPhotoUpdateManyWithoutPhotoNestedInput
    milestonePhotos?: MilestonePhotoUpdateManyWithoutPhotoNestedInput
  }

  export type PhotoUncheckedUpdateWithoutAlbumPhotosInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyPhotos?: BabyPhotoUncheckedUpdateManyWithoutPhotoNestedInput
    activityPhotos?: ActivityPhotoUncheckedUpdateManyWithoutPhotoNestedInput
    milestonePhotos?: MilestonePhotoUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type ActivityCreateWithoutPhotosInput = {
    startTime: Date | string
    endTime?: Date | string | null
    type: string
    description?: string | null
    milestone?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    baby: BabyCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutPhotosInput = {
    id?: number
    startTime: Date | string
    endTime?: Date | string | null
    type: string
    description?: string | null
    milestone?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babyId: number
  }

  export type ActivityCreateOrConnectWithoutPhotosInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutPhotosInput, ActivityUncheckedCreateWithoutPhotosInput>
  }

  export type PhotoCreateWithoutActivityPhotosInput = {
    url: string
    caption?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    babyPhotos?: BabyPhotoCreateNestedManyWithoutPhotoInput
    albumPhotos?: AlbumPhotoCreateNestedManyWithoutPhotoInput
    milestonePhotos?: MilestonePhotoCreateNestedManyWithoutPhotoInput
  }

  export type PhotoUncheckedCreateWithoutActivityPhotosInput = {
    id?: number
    url: string
    caption?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    babyPhotos?: BabyPhotoUncheckedCreateNestedManyWithoutPhotoInput
    albumPhotos?: AlbumPhotoUncheckedCreateNestedManyWithoutPhotoInput
    milestonePhotos?: MilestonePhotoUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type PhotoCreateOrConnectWithoutActivityPhotosInput = {
    where: PhotoWhereUniqueInput
    create: XOR<PhotoCreateWithoutActivityPhotosInput, PhotoUncheckedCreateWithoutActivityPhotosInput>
  }

  export type ActivityUpsertWithoutPhotosInput = {
    update: XOR<ActivityUpdateWithoutPhotosInput, ActivityUncheckedUpdateWithoutPhotosInput>
    create: XOR<ActivityCreateWithoutPhotosInput, ActivityUncheckedCreateWithoutPhotosInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutPhotosInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutPhotosInput, ActivityUncheckedUpdateWithoutPhotosInput>
  }

  export type ActivityUpdateWithoutPhotosInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    milestone?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baby?: BabyUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutPhotosInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    milestone?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyId?: IntFieldUpdateOperationsInput | number
  }

  export type PhotoUpsertWithoutActivityPhotosInput = {
    update: XOR<PhotoUpdateWithoutActivityPhotosInput, PhotoUncheckedUpdateWithoutActivityPhotosInput>
    create: XOR<PhotoCreateWithoutActivityPhotosInput, PhotoUncheckedCreateWithoutActivityPhotosInput>
    where?: PhotoWhereInput
  }

  export type PhotoUpdateToOneWithWhereWithoutActivityPhotosInput = {
    where?: PhotoWhereInput
    data: XOR<PhotoUpdateWithoutActivityPhotosInput, PhotoUncheckedUpdateWithoutActivityPhotosInput>
  }

  export type PhotoUpdateWithoutActivityPhotosInput = {
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyPhotos?: BabyPhotoUpdateManyWithoutPhotoNestedInput
    albumPhotos?: AlbumPhotoUpdateManyWithoutPhotoNestedInput
    milestonePhotos?: MilestonePhotoUpdateManyWithoutPhotoNestedInput
  }

  export type PhotoUncheckedUpdateWithoutActivityPhotosInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyPhotos?: BabyPhotoUncheckedUpdateManyWithoutPhotoNestedInput
    albumPhotos?: AlbumPhotoUncheckedUpdateManyWithoutPhotoNestedInput
    milestonePhotos?: MilestonePhotoUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type MilestoneCreateWithoutPhotosInput = {
    date: Date | string
    category: string
    title: string
    description?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    baby: BabyCreateNestedOneWithoutMilestonesInput
  }

  export type MilestoneUncheckedCreateWithoutPhotosInput = {
    id?: number
    date: Date | string
    category: string
    title: string
    description?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babyId: number
  }

  export type MilestoneCreateOrConnectWithoutPhotosInput = {
    where: MilestoneWhereUniqueInput
    create: XOR<MilestoneCreateWithoutPhotosInput, MilestoneUncheckedCreateWithoutPhotosInput>
  }

  export type PhotoCreateWithoutMilestonePhotosInput = {
    url: string
    caption?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    babyPhotos?: BabyPhotoCreateNestedManyWithoutPhotoInput
    albumPhotos?: AlbumPhotoCreateNestedManyWithoutPhotoInput
    activityPhotos?: ActivityPhotoCreateNestedManyWithoutPhotoInput
  }

  export type PhotoUncheckedCreateWithoutMilestonePhotosInput = {
    id?: number
    url: string
    caption?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    babyPhotos?: BabyPhotoUncheckedCreateNestedManyWithoutPhotoInput
    albumPhotos?: AlbumPhotoUncheckedCreateNestedManyWithoutPhotoInput
    activityPhotos?: ActivityPhotoUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type PhotoCreateOrConnectWithoutMilestonePhotosInput = {
    where: PhotoWhereUniqueInput
    create: XOR<PhotoCreateWithoutMilestonePhotosInput, PhotoUncheckedCreateWithoutMilestonePhotosInput>
  }

  export type MilestoneUpsertWithoutPhotosInput = {
    update: XOR<MilestoneUpdateWithoutPhotosInput, MilestoneUncheckedUpdateWithoutPhotosInput>
    create: XOR<MilestoneCreateWithoutPhotosInput, MilestoneUncheckedCreateWithoutPhotosInput>
    where?: MilestoneWhereInput
  }

  export type MilestoneUpdateToOneWithWhereWithoutPhotosInput = {
    where?: MilestoneWhereInput
    data: XOR<MilestoneUpdateWithoutPhotosInput, MilestoneUncheckedUpdateWithoutPhotosInput>
  }

  export type MilestoneUpdateWithoutPhotosInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baby?: BabyUpdateOneRequiredWithoutMilestonesNestedInput
  }

  export type MilestoneUncheckedUpdateWithoutPhotosInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyId?: IntFieldUpdateOperationsInput | number
  }

  export type PhotoUpsertWithoutMilestonePhotosInput = {
    update: XOR<PhotoUpdateWithoutMilestonePhotosInput, PhotoUncheckedUpdateWithoutMilestonePhotosInput>
    create: XOR<PhotoCreateWithoutMilestonePhotosInput, PhotoUncheckedCreateWithoutMilestonePhotosInput>
    where?: PhotoWhereInput
  }

  export type PhotoUpdateToOneWithWhereWithoutMilestonePhotosInput = {
    where?: PhotoWhereInput
    data: XOR<PhotoUpdateWithoutMilestonePhotosInput, PhotoUncheckedUpdateWithoutMilestonePhotosInput>
  }

  export type PhotoUpdateWithoutMilestonePhotosInput = {
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyPhotos?: BabyPhotoUpdateManyWithoutPhotoNestedInput
    albumPhotos?: AlbumPhotoUpdateManyWithoutPhotoNestedInput
    activityPhotos?: ActivityPhotoUpdateManyWithoutPhotoNestedInput
  }

  export type PhotoUncheckedUpdateWithoutMilestonePhotosInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyPhotos?: BabyPhotoUncheckedUpdateManyWithoutPhotoNestedInput
    albumPhotos?: AlbumPhotoUncheckedUpdateManyWithoutPhotoNestedInput
    activityPhotos?: ActivityPhotoUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type AlbumCreateWithoutAccessInput = {
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    baby: BabyCreateNestedOneWithoutAlbumsInput
    photos?: AlbumPhotoCreateNestedManyWithoutAlbumInput
  }

  export type AlbumUncheckedCreateWithoutAccessInput = {
    id?: number
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babyId: number
    photos?: AlbumPhotoUncheckedCreateNestedManyWithoutAlbumInput
  }

  export type AlbumCreateOrConnectWithoutAccessInput = {
    where: AlbumWhereUniqueInput
    create: XOR<AlbumCreateWithoutAccessInput, AlbumUncheckedCreateWithoutAccessInput>
  }

  export type UserCreateWithoutAlbumAccessInput = {
    email: string
    passwordHash: string
    firstName?: string
    lastName?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babies?: BabyCaregiverCreateNestedManyWithoutUserInput
    ownedBabies?: BabyCreateNestedManyWithoutOwnerInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    ParentInvite?: ParentInviteCreateNestedManyWithoutSentByInput
  }

  export type UserUncheckedCreateWithoutAlbumAccessInput = {
    id?: number
    email: string
    passwordHash: string
    firstName?: string
    lastName?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babies?: BabyCaregiverUncheckedCreateNestedManyWithoutUserInput
    ownedBabies?: BabyUncheckedCreateNestedManyWithoutOwnerInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ParentInvite?: ParentInviteUncheckedCreateNestedManyWithoutSentByInput
  }

  export type UserCreateOrConnectWithoutAlbumAccessInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAlbumAccessInput, UserUncheckedCreateWithoutAlbumAccessInput>
  }

  export type AlbumUpsertWithoutAccessInput = {
    update: XOR<AlbumUpdateWithoutAccessInput, AlbumUncheckedUpdateWithoutAccessInput>
    create: XOR<AlbumCreateWithoutAccessInput, AlbumUncheckedCreateWithoutAccessInput>
    where?: AlbumWhereInput
  }

  export type AlbumUpdateToOneWithWhereWithoutAccessInput = {
    where?: AlbumWhereInput
    data: XOR<AlbumUpdateWithoutAccessInput, AlbumUncheckedUpdateWithoutAccessInput>
  }

  export type AlbumUpdateWithoutAccessInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baby?: BabyUpdateOneRequiredWithoutAlbumsNestedInput
    photos?: AlbumPhotoUpdateManyWithoutAlbumNestedInput
  }

  export type AlbumUncheckedUpdateWithoutAccessInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyId?: IntFieldUpdateOperationsInput | number
    photos?: AlbumPhotoUncheckedUpdateManyWithoutAlbumNestedInput
  }

  export type UserUpsertWithoutAlbumAccessInput = {
    update: XOR<UserUpdateWithoutAlbumAccessInput, UserUncheckedUpdateWithoutAlbumAccessInput>
    create: XOR<UserCreateWithoutAlbumAccessInput, UserUncheckedCreateWithoutAlbumAccessInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAlbumAccessInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAlbumAccessInput, UserUncheckedUpdateWithoutAlbumAccessInput>
  }

  export type UserUpdateWithoutAlbumAccessInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babies?: BabyCaregiverUpdateManyWithoutUserNestedInput
    ownedBabies?: BabyUpdateManyWithoutOwnerNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    ParentInvite?: ParentInviteUpdateManyWithoutSentByNestedInput
  }

  export type UserUncheckedUpdateWithoutAlbumAccessInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babies?: BabyCaregiverUncheckedUpdateManyWithoutUserNestedInput
    ownedBabies?: BabyUncheckedUpdateManyWithoutOwnerNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    ParentInvite?: ParentInviteUncheckedUpdateManyWithoutSentByNestedInput
  }

  export type UserCreateWithoutPostsInput = {
    email: string
    passwordHash: string
    firstName?: string
    lastName?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babies?: BabyCaregiverCreateNestedManyWithoutUserInput
    ownedBabies?: BabyCreateNestedManyWithoutOwnerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    ParentInvite?: ParentInviteCreateNestedManyWithoutSentByInput
    AlbumAccess?: AlbumAccessCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    id?: number
    email: string
    passwordHash: string
    firstName?: string
    lastName?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babies?: BabyCaregiverUncheckedCreateNestedManyWithoutUserInput
    ownedBabies?: BabyUncheckedCreateNestedManyWithoutOwnerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ParentInvite?: ParentInviteUncheckedCreateNestedManyWithoutSentByInput
    AlbumAccess?: AlbumAccessUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type CommentCreateWithoutPostInput = {
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: number
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babies?: BabyCaregiverUpdateManyWithoutUserNestedInput
    ownedBabies?: BabyUpdateManyWithoutOwnerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    ParentInvite?: ParentInviteUpdateManyWithoutSentByNestedInput
    AlbumAccess?: AlbumAccessUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babies?: BabyCaregiverUncheckedUpdateManyWithoutUserNestedInput
    ownedBabies?: BabyUncheckedUpdateManyWithoutOwnerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    ParentInvite?: ParentInviteUncheckedUpdateManyWithoutSentByNestedInput
    AlbumAccess?: AlbumAccessUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type PostCreateWithoutCommentsInput = {
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutCommentsInput = {
    id?: number
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: number
  }

  export type PostCreateOrConnectWithoutCommentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    email: string
    passwordHash: string
    firstName?: string
    lastName?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babies?: BabyCaregiverCreateNestedManyWithoutUserInput
    ownedBabies?: BabyCreateNestedManyWithoutOwnerInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    ParentInvite?: ParentInviteCreateNestedManyWithoutSentByInput
    AlbumAccess?: AlbumAccessCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: number
    email: string
    passwordHash: string
    firstName?: string
    lastName?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babies?: BabyCaregiverUncheckedCreateNestedManyWithoutUserInput
    ownedBabies?: BabyUncheckedCreateNestedManyWithoutOwnerInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    ParentInvite?: ParentInviteUncheckedCreateNestedManyWithoutSentByInput
    AlbumAccess?: AlbumAccessUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type PostUpsertWithoutCommentsInput = {
    update: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type PostUpdateWithoutCommentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babies?: BabyCaregiverUpdateManyWithoutUserNestedInput
    ownedBabies?: BabyUpdateManyWithoutOwnerNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    ParentInvite?: ParentInviteUpdateManyWithoutSentByNestedInput
    AlbumAccess?: AlbumAccessUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babies?: BabyCaregiverUncheckedUpdateManyWithoutUserNestedInput
    ownedBabies?: BabyUncheckedUpdateManyWithoutOwnerNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    ParentInvite?: ParentInviteUncheckedUpdateManyWithoutSentByNestedInput
    AlbumAccess?: AlbumAccessUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BabyCreateWithoutParentInvitesInput = {
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedBabiesInput
    caregivers?: BabyCaregiverCreateNestedManyWithoutBabyInput
    eliminations?: EliminationCreateNestedManyWithoutBabyInput
    feedings?: FeedingCreateNestedManyWithoutBabyInput
    sleepsleepSessions?: SleepCreateNestedManyWithoutBabyInput
    activities?: ActivityCreateNestedManyWithoutBabyInput
    photos?: BabyPhotoCreateNestedManyWithoutBabyInput
    milestones?: MilestoneCreateNestedManyWithoutBabyInput
    healthRecords?: HealthRecordCreateNestedManyWithoutBabyInput
    measurements?: MeasurementCreateNestedManyWithoutBabyInput
    albums?: AlbumCreateNestedManyWithoutBabyInput
  }

  export type BabyUncheckedCreateWithoutParentInvitesInput = {
    id?: number
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: number
    caregivers?: BabyCaregiverUncheckedCreateNestedManyWithoutBabyInput
    eliminations?: EliminationUncheckedCreateNestedManyWithoutBabyInput
    feedings?: FeedingUncheckedCreateNestedManyWithoutBabyInput
    sleepsleepSessions?: SleepUncheckedCreateNestedManyWithoutBabyInput
    activities?: ActivityUncheckedCreateNestedManyWithoutBabyInput
    photos?: BabyPhotoUncheckedCreateNestedManyWithoutBabyInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutBabyInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutBabyInput
    measurements?: MeasurementUncheckedCreateNestedManyWithoutBabyInput
    albums?: AlbumUncheckedCreateNestedManyWithoutBabyInput
  }

  export type BabyCreateOrConnectWithoutParentInvitesInput = {
    where: BabyWhereUniqueInput
    create: XOR<BabyCreateWithoutParentInvitesInput, BabyUncheckedCreateWithoutParentInvitesInput>
  }

  export type UserCreateWithoutParentInviteInput = {
    email: string
    passwordHash: string
    firstName?: string
    lastName?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babies?: BabyCaregiverCreateNestedManyWithoutUserInput
    ownedBabies?: BabyCreateNestedManyWithoutOwnerInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    AlbumAccess?: AlbumAccessCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutParentInviteInput = {
    id?: number
    email: string
    passwordHash: string
    firstName?: string
    lastName?: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    babies?: BabyCaregiverUncheckedCreateNestedManyWithoutUserInput
    ownedBabies?: BabyUncheckedCreateNestedManyWithoutOwnerInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    AlbumAccess?: AlbumAccessUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutParentInviteInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutParentInviteInput, UserUncheckedCreateWithoutParentInviteInput>
  }

  export type BabyUpsertWithoutParentInvitesInput = {
    update: XOR<BabyUpdateWithoutParentInvitesInput, BabyUncheckedUpdateWithoutParentInvitesInput>
    create: XOR<BabyCreateWithoutParentInvitesInput, BabyUncheckedCreateWithoutParentInvitesInput>
    where?: BabyWhereInput
  }

  export type BabyUpdateToOneWithWhereWithoutParentInvitesInput = {
    where?: BabyWhereInput
    data: XOR<BabyUpdateWithoutParentInvitesInput, BabyUncheckedUpdateWithoutParentInvitesInput>
  }

  export type BabyUpdateWithoutParentInvitesInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedBabiesNestedInput
    caregivers?: BabyCaregiverUpdateManyWithoutBabyNestedInput
    eliminations?: EliminationUpdateManyWithoutBabyNestedInput
    feedings?: FeedingUpdateManyWithoutBabyNestedInput
    sleepsleepSessions?: SleepUpdateManyWithoutBabyNestedInput
    activities?: ActivityUpdateManyWithoutBabyNestedInput
    photos?: BabyPhotoUpdateManyWithoutBabyNestedInput
    milestones?: MilestoneUpdateManyWithoutBabyNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutBabyNestedInput
    measurements?: MeasurementUpdateManyWithoutBabyNestedInput
    albums?: AlbumUpdateManyWithoutBabyNestedInput
  }

  export type BabyUncheckedUpdateWithoutParentInvitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: IntFieldUpdateOperationsInput | number
    caregivers?: BabyCaregiverUncheckedUpdateManyWithoutBabyNestedInput
    eliminations?: EliminationUncheckedUpdateManyWithoutBabyNestedInput
    feedings?: FeedingUncheckedUpdateManyWithoutBabyNestedInput
    sleepsleepSessions?: SleepUncheckedUpdateManyWithoutBabyNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutBabyNestedInput
    photos?: BabyPhotoUncheckedUpdateManyWithoutBabyNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutBabyNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutBabyNestedInput
    measurements?: MeasurementUncheckedUpdateManyWithoutBabyNestedInput
    albums?: AlbumUncheckedUpdateManyWithoutBabyNestedInput
  }

  export type UserUpsertWithoutParentInviteInput = {
    update: XOR<UserUpdateWithoutParentInviteInput, UserUncheckedUpdateWithoutParentInviteInput>
    create: XOR<UserCreateWithoutParentInviteInput, UserUncheckedCreateWithoutParentInviteInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutParentInviteInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutParentInviteInput, UserUncheckedUpdateWithoutParentInviteInput>
  }

  export type UserUpdateWithoutParentInviteInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babies?: BabyCaregiverUpdateManyWithoutUserNestedInput
    ownedBabies?: BabyUpdateManyWithoutOwnerNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    AlbumAccess?: AlbumAccessUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutParentInviteInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babies?: BabyCaregiverUncheckedUpdateManyWithoutUserNestedInput
    ownedBabies?: BabyUncheckedUpdateManyWithoutOwnerNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    AlbumAccess?: AlbumAccessUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BabyCaregiverCreateManyUserInput = {
    id?: number
    relationship: string
    permissions?: BabyCaregiverCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    babyId: number
  }

  export type BabyCreateManyOwnerInput = {
    id?: number
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateManyAuthorInput = {
    id?: number
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyAuthorInput = {
    id?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postId: number
  }

  export type ParentInviteCreateManySentByInput = {
    id?: number
    email: string
    babyId: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlbumAccessCreateManyUserInput = {
    id?: number
    permissions?: AlbumAccessCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    albumId: number
  }

  export type BabyCaregiverUpdateWithoutUserInput = {
    relationship?: StringFieldUpdateOperationsInput | string
    permissions?: BabyCaregiverUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baby?: BabyUpdateOneRequiredWithoutCaregiversNestedInput
  }

  export type BabyCaregiverUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    relationship?: StringFieldUpdateOperationsInput | string
    permissions?: BabyCaregiverUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyId?: IntFieldUpdateOperationsInput | number
  }

  export type BabyCaregiverUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    relationship?: StringFieldUpdateOperationsInput | string
    permissions?: BabyCaregiverUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    babyId?: IntFieldUpdateOperationsInput | number
  }

  export type BabyUpdateWithoutOwnerInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caregivers?: BabyCaregiverUpdateManyWithoutBabyNestedInput
    eliminations?: EliminationUpdateManyWithoutBabyNestedInput
    feedings?: FeedingUpdateManyWithoutBabyNestedInput
    sleepsleepSessions?: SleepUpdateManyWithoutBabyNestedInput
    activities?: ActivityUpdateManyWithoutBabyNestedInput
    photos?: BabyPhotoUpdateManyWithoutBabyNestedInput
    milestones?: MilestoneUpdateManyWithoutBabyNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutBabyNestedInput
    measurements?: MeasurementUpdateManyWithoutBabyNestedInput
    albums?: AlbumUpdateManyWithoutBabyNestedInput
    parentInvites?: ParentInviteUpdateManyWithoutBabyNestedInput
  }

  export type BabyUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caregivers?: BabyCaregiverUncheckedUpdateManyWithoutBabyNestedInput
    eliminations?: EliminationUncheckedUpdateManyWithoutBabyNestedInput
    feedings?: FeedingUncheckedUpdateManyWithoutBabyNestedInput
    sleepsleepSessions?: SleepUncheckedUpdateManyWithoutBabyNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutBabyNestedInput
    photos?: BabyPhotoUncheckedUpdateManyWithoutBabyNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutBabyNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutBabyNestedInput
    measurements?: MeasurementUncheckedUpdateManyWithoutBabyNestedInput
    albums?: AlbumUncheckedUpdateManyWithoutBabyNestedInput
    parentInvites?: ParentInviteUncheckedUpdateManyWithoutBabyNestedInput
  }

  export type BabyUncheckedUpdateManyWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutAuthorInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutAuthorInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: IntFieldUpdateOperationsInput | number
  }

  export type CommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: IntFieldUpdateOperationsInput | number
  }

  export type ParentInviteUpdateWithoutSentByInput = {
    email?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baby?: BabyUpdateOneRequiredWithoutParentInvitesNestedInput
  }

  export type ParentInviteUncheckedUpdateWithoutSentByInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    babyId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentInviteUncheckedUpdateManyWithoutSentByInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    babyId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlbumAccessUpdateWithoutUserInput = {
    permissions?: AlbumAccessUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    album?: AlbumUpdateOneRequiredWithoutAccessNestedInput
  }

  export type AlbumAccessUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissions?: AlbumAccessUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albumId?: IntFieldUpdateOperationsInput | number
  }

  export type AlbumAccessUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissions?: AlbumAccessUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    albumId?: IntFieldUpdateOperationsInput | number
  }

  export type BabyCaregiverCreateManyBabyInput = {
    id?: number
    relationship: string
    permissions?: BabyCaregiverCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
  }

  export type EliminationCreateManyBabyInput = {
    id?: number
    timestamp: Date | string
    type: string
    weight?: number | null
    success: boolean
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedingCreateManyBabyInput = {
    id?: number
    startTime: Date | string
    endTime?: Date | string | null
    type: string
    side?: string | null
    amount?: number | null
    food?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SleepCreateManyBabyInput = {
    id?: number
    startTime: Date | string
    endTime?: Date | string | null
    how?: string | null
    whereFellAsleep?: string | null
    whereSlept?: string | null
    type: string
    quality?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateManyBabyInput = {
    id?: number
    startTime: Date | string
    endTime?: Date | string | null
    type: string
    description?: string | null
    milestone?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BabyPhotoCreateManyBabyInput = {
    photoId: number
    createdAt?: Date | string
  }

  export type MilestoneCreateManyBabyInput = {
    id?: number
    date: Date | string
    category: string
    title: string
    description?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthRecordCreateManyBabyInput = {
    id?: number
    timestamp: Date | string
    type: string
    value?: number | null
    description?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeasurementCreateManyBabyInput = {
    id?: number
    date: Date | string
    weight?: number | null
    height?: number | null
    headCirc?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlbumCreateManyBabyInput = {
    id?: number
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentInviteCreateManyBabyInput = {
    id?: number
    email: string
    senderId: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BabyCaregiverUpdateWithoutBabyInput = {
    relationship?: StringFieldUpdateOperationsInput | string
    permissions?: BabyCaregiverUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBabiesNestedInput
  }

  export type BabyCaregiverUncheckedUpdateWithoutBabyInput = {
    id?: IntFieldUpdateOperationsInput | number
    relationship?: StringFieldUpdateOperationsInput | string
    permissions?: BabyCaregiverUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type BabyCaregiverUncheckedUpdateManyWithoutBabyInput = {
    id?: IntFieldUpdateOperationsInput | number
    relationship?: StringFieldUpdateOperationsInput | string
    permissions?: BabyCaregiverUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type EliminationUpdateWithoutBabyInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EliminationUncheckedUpdateWithoutBabyInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EliminationUncheckedUpdateManyWithoutBabyInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedingUpdateWithoutBabyInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    side?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    food?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedingUncheckedUpdateWithoutBabyInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    side?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    food?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedingUncheckedUpdateManyWithoutBabyInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    side?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    food?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SleepUpdateWithoutBabyInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    how?: NullableStringFieldUpdateOperationsInput | string | null
    whereFellAsleep?: NullableStringFieldUpdateOperationsInput | string | null
    whereSlept?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SleepUncheckedUpdateWithoutBabyInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    how?: NullableStringFieldUpdateOperationsInput | string | null
    whereFellAsleep?: NullableStringFieldUpdateOperationsInput | string | null
    whereSlept?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SleepUncheckedUpdateManyWithoutBabyInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    how?: NullableStringFieldUpdateOperationsInput | string | null
    whereFellAsleep?: NullableStringFieldUpdateOperationsInput | string | null
    whereSlept?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutBabyInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    milestone?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: ActivityPhotoUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutBabyInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    milestone?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: ActivityPhotoUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateManyWithoutBabyInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    milestone?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BabyPhotoUpdateWithoutBabyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: PhotoUpdateOneRequiredWithoutBabyPhotosNestedInput
  }

  export type BabyPhotoUncheckedUpdateWithoutBabyInput = {
    photoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BabyPhotoUncheckedUpdateManyWithoutBabyInput = {
    photoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUpdateWithoutBabyInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: MilestonePhotoUpdateManyWithoutMilestoneNestedInput
  }

  export type MilestoneUncheckedUpdateWithoutBabyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: MilestonePhotoUncheckedUpdateManyWithoutMilestoneNestedInput
  }

  export type MilestoneUncheckedUpdateManyWithoutBabyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthRecordUpdateWithoutBabyInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthRecordUncheckedUpdateWithoutBabyInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthRecordUncheckedUpdateManyWithoutBabyInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeasurementUpdateWithoutBabyInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    headCirc?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeasurementUncheckedUpdateWithoutBabyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    headCirc?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeasurementUncheckedUpdateManyWithoutBabyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    headCirc?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlbumUpdateWithoutBabyInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: AlbumPhotoUpdateManyWithoutAlbumNestedInput
    access?: AlbumAccessUpdateManyWithoutAlbumNestedInput
  }

  export type AlbumUncheckedUpdateWithoutBabyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: AlbumPhotoUncheckedUpdateManyWithoutAlbumNestedInput
    access?: AlbumAccessUncheckedUpdateManyWithoutAlbumNestedInput
  }

  export type AlbumUncheckedUpdateManyWithoutBabyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentInviteUpdateWithoutBabyInput = {
    email?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentBy?: UserUpdateOneRequiredWithoutParentInviteNestedInput
  }

  export type ParentInviteUncheckedUpdateWithoutBabyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senderId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentInviteUncheckedUpdateManyWithoutBabyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senderId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityPhotoCreateManyActivityInput = {
    photoId: number
    createdAt?: Date | string
  }

  export type ActivityPhotoUpdateWithoutActivityInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: PhotoUpdateOneRequiredWithoutActivityPhotosNestedInput
  }

  export type ActivityPhotoUncheckedUpdateWithoutActivityInput = {
    photoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityPhotoUncheckedUpdateManyWithoutActivityInput = {
    photoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestonePhotoCreateManyMilestoneInput = {
    photoId: number
    createdAt?: Date | string
  }

  export type MilestonePhotoUpdateWithoutMilestoneInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: PhotoUpdateOneRequiredWithoutMilestonePhotosNestedInput
  }

  export type MilestonePhotoUncheckedUpdateWithoutMilestoneInput = {
    photoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestonePhotoUncheckedUpdateManyWithoutMilestoneInput = {
    photoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlbumPhotoCreateManyAlbumInput = {
    photoId: number
    createdAt?: Date | string
  }

  export type AlbumAccessCreateManyAlbumInput = {
    id?: number
    permissions?: AlbumAccessCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
  }

  export type AlbumPhotoUpdateWithoutAlbumInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: PhotoUpdateOneRequiredWithoutAlbumPhotosNestedInput
  }

  export type AlbumPhotoUncheckedUpdateWithoutAlbumInput = {
    photoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlbumPhotoUncheckedUpdateManyWithoutAlbumInput = {
    photoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlbumAccessUpdateWithoutAlbumInput = {
    permissions?: AlbumAccessUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAlbumAccessNestedInput
  }

  export type AlbumAccessUncheckedUpdateWithoutAlbumInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissions?: AlbumAccessUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type AlbumAccessUncheckedUpdateManyWithoutAlbumInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissions?: AlbumAccessUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type BabyPhotoCreateManyPhotoInput = {
    babyId: number
    createdAt?: Date | string
  }

  export type AlbumPhotoCreateManyPhotoInput = {
    albumId: number
    createdAt?: Date | string
  }

  export type ActivityPhotoCreateManyPhotoInput = {
    activityId: number
    createdAt?: Date | string
  }

  export type MilestonePhotoCreateManyPhotoInput = {
    milestoneId: number
    createdAt?: Date | string
  }

  export type BabyPhotoUpdateWithoutPhotoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baby?: BabyUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type BabyPhotoUncheckedUpdateWithoutPhotoInput = {
    babyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BabyPhotoUncheckedUpdateManyWithoutPhotoInput = {
    babyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlbumPhotoUpdateWithoutPhotoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    album?: AlbumUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type AlbumPhotoUncheckedUpdateWithoutPhotoInput = {
    albumId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlbumPhotoUncheckedUpdateManyWithoutPhotoInput = {
    albumId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityPhotoUpdateWithoutPhotoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type ActivityPhotoUncheckedUpdateWithoutPhotoInput = {
    activityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityPhotoUncheckedUpdateManyWithoutPhotoInput = {
    activityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestonePhotoUpdateWithoutPhotoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestone?: MilestoneUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type MilestonePhotoUncheckedUpdateWithoutPhotoInput = {
    milestoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestonePhotoUncheckedUpdateManyWithoutPhotoInput = {
    milestoneId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyPostInput = {
    id?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: number
  }

  export type CommentUpdateWithoutPostInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: IntFieldUpdateOperationsInput | number
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BabyCountOutputTypeDefaultArgs instead
     */
    export type BabyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BabyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityCountOutputTypeDefaultArgs instead
     */
    export type ActivityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MilestoneCountOutputTypeDefaultArgs instead
     */
    export type MilestoneCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MilestoneCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlbumCountOutputTypeDefaultArgs instead
     */
    export type AlbumCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlbumCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PhotoCountOutputTypeDefaultArgs instead
     */
    export type PhotoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PhotoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostCountOutputTypeDefaultArgs instead
     */
    export type PostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BabyDefaultArgs instead
     */
    export type BabyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BabyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BabyCaregiverDefaultArgs instead
     */
    export type BabyCaregiverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BabyCaregiverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EliminationDefaultArgs instead
     */
    export type EliminationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EliminationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeedingDefaultArgs instead
     */
    export type FeedingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeedingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SleepDefaultArgs instead
     */
    export type SleepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SleepDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityDefaultArgs instead
     */
    export type ActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MilestoneDefaultArgs instead
     */
    export type MilestoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MilestoneDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HealthRecordDefaultArgs instead
     */
    export type HealthRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HealthRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MeasurementDefaultArgs instead
     */
    export type MeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MeasurementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlbumDefaultArgs instead
     */
    export type AlbumArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlbumDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PhotoDefaultArgs instead
     */
    export type PhotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PhotoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BabyPhotoDefaultArgs instead
     */
    export type BabyPhotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BabyPhotoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlbumPhotoDefaultArgs instead
     */
    export type AlbumPhotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlbumPhotoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityPhotoDefaultArgs instead
     */
    export type ActivityPhotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityPhotoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MilestonePhotoDefaultArgs instead
     */
    export type MilestonePhotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MilestonePhotoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlbumAccessDefaultArgs instead
     */
    export type AlbumAccessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlbumAccessDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostDefaultArgs instead
     */
    export type PostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParentInviteDefaultArgs instead
     */
    export type ParentInviteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParentInviteDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}